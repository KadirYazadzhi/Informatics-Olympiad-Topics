# üå≤ –î—ä—Ä–≤–æ–≤–∏–¥–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –æ—Ç –¥–∞–Ω–Ω–∏: –ï–∫—Å–ø–µ—Ä—Ç–Ω–æ –Ω–∏–≤–æ

## üå≥ –°–µ–≥–º–µ–Ω—Ç–Ω–æ –¥—ä—Ä–≤–æ (Advanced)

### 1. –î–∏–Ω–∞–º–∏—á–Ω–æ –°–µ–≥–º–µ–Ω—Ç–Ω–æ –î—ä—Ä–≤–æ (Dynamic Segment Tree)
–ü—Ä–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ—Ç–æ —Å–µ–≥–º–µ–Ω—Ç–Ω–æ –¥—ä—Ä–≤–æ –∑–∞–¥–µ–ª—è–º–µ –º–∞—Å–∏–≤ –æ—Ç $4N$. –ê–∫–æ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ä—Ç –µ $[0, 10^9]$, –ø–∞–º–µ—Ç—Ç–∞ –Ω—è–º–∞ –¥–∞ —Å—Ç–∏–≥–Ω–µ.
- **–†–µ—à–µ–Ω–∏–µ**: –°—ä–∑–¥–∞–≤–∞–º–µ –≤—ä–∑–ª–∏ —Å–∞–º–æ –ø—Ä–∏ –Ω—É–∂–¥–∞ (lazy creation). –í—Å–µ–∫–∏ –≤—ä–∑–µ–ª –ø–∞–∑–∏ —É–∫–∞–∑–∞—Ç–µ–ª–∏/–∏–Ω–¥–µ–∫—Å–∏ –∫—ä–º –ª—è–≤–æ –∏ –¥—è—Å–Ω–æ –¥–µ—Ç–µ.
- **–°–ª–æ–∂–Ω–æ—Å—Ç**: $O(Q \log (\text{Range}))$ –ø–∞–º–µ—Ç –∏ –≤—Ä–µ–º–µ.

```cpp
struct Node {
    long long sum = 0;
    Node *left = nullptr, *right = nullptr;
    
    void update(int l, int r, int pos, int val) {
        if (l == r) { sum += val; return; }
        int mid = l + (r - l) / 2;
        if (pos <= mid) {
            if (!left) left = new Node();
            left->update(l, mid, pos, val);
        } else {
            if (!right) right = new Node();
            right->update(mid + 1, r, pos, val);
        }
        sum = (left ? left->sum : 0) + (right ? right->sum : 0);
    }
};
```

### 2. Segment Tree Beats (Ji Driver Segment Tree)
–ü–æ–∑–≤–æ–ª—è–≤–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏ –æ—Ç —Ç–∏–ø–∞ $A_i = \min(A_i, X)$ –∑–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª.
- –ü–∞–∑–∏–º `max`, `second_max` –∏ `count_max` –≤—ä–≤ –≤—Å–µ–∫–∏ –≤—ä–∑–µ–ª.
- –ê–∫–æ $X \ge max$, –Ω–µ –ø—Ä–∞–≤–∏–º –Ω–∏—â–æ.
- –ê–∫–æ $second\_max < X < max$, –æ–±–Ω–æ–≤—è–≤–∞–º–µ —Å–∞–º–æ –º–∞–∫—Å–∏–º—É–º–∞.
- –ò–Ω–∞—á–µ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –Ω–∞–≤–ª–∏–∑–∞–º–µ –Ω–∞–¥–æ–ª—É.
- –ê–º–æ—Ä—Ç–∏–∑–∏—Ä–∞–Ω–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç: $O((N+Q) \log N)$.

---

## üå≥ –î—ä—Ä–≤–æ –Ω–∞ –§–µ–Ω—É–∏–∫ (BIT) - –†–∞–∑—à–∏—Ä–µ–Ω–∏—è

### 1. Range Update, Range Query
–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏—è—Ç BIT –ø–æ–¥–¥—ä—Ä–∂–∞ Point Update, Range Query.
–ó–∞ –¥–∞ –ø–æ–¥–¥—ä—Ä–∂–∞–º–µ Range Update $[L, R]$ —Å $+Val$:
- –ò–∑–ø–æ–ª–∑–≤–∞–º–µ –¥–≤–∞ BIT-–∞: $B_1$ –∏ $B_2$.
- $\text{Sum}(x) = \sum_{i=1}^x A_i$. –°–ª–µ–¥ –¥–æ–±–∞–≤—è–Ω–µ –Ω–∞ $v$ –≤ $[L, R]$, —Å—É–º–∞—Ç–∞ –∑–∞ $x \ge R$ —Å–µ —É–≤–µ–ª–∏—á–∞–≤–∞ —Å $v \cdot (R - L + 1)$.
- –§–æ—Ä–º—É–ª–∞: $\text{Query}(x) = \text{sum}(B_1, x) \cdot x - \text{sum}(B_2, x)$.
- Update:
  - `update(B1, L, v)`, `update(B1, R+1, -v)`
  - `update(B2, L, v * (L-1))`, `update(B2, R+1, -v * R)`

### 2. 2D –î—ä—Ä–≤–æ –Ω–∞ –§–µ–Ω—É–∏–∫
–ó–∞ —Ä–∞–±–æ—Ç–∞ —Å –º–∞—Ç—Ä–∏—Ü–∏.
```cpp
void update(int x, int y, int delta) {
    for (int i = x; i <= N; i += i & -i)
        for (int j = y; j <= M; j += j & -j)
            bit[i][j] += delta;
}
```
–°–ª–æ–∂–Ω–æ—Å—Ç: $O(\log N \log M)$.

---

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–î–∏–Ω–∞–º–∏—á–Ω–∏—Ç–µ –¥—ä—Ä–≤–µ—Ç–∞ —Å–∞ –∫–ª—é—á–æ–≤–∏ –ø—Ä–∏ "–æ–≥—Ä–æ–º–Ω–∏" –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏. Segment Tree Beats –µ —Å—Ä–∞–≤–Ω–∏—Ç–µ–ª–Ω–æ –Ω–æ–≤–∞ –∏ –º–æ—â–Ω–∞ —Ç–µ—Ö–Ω–∏–∫–∞, –∫–æ—è—Ç–æ –ø–æ–∑–≤–æ–ª—è–≤–∞ —Ä–µ—à–∞–≤–∞–Ω–µ—Ç–æ –Ω–∞ –∑–∞–¥–∞—á–∏, –∫–æ–∏—Ç–æ –ø—Ä–µ–¥–∏ —Å–µ —Å—á–∏—Ç–∞—Ö–∞ –∑–∞ –Ω–µ—Ä–µ—à–∏–º–∏ –±–µ–∑ sqrt-decompositon.