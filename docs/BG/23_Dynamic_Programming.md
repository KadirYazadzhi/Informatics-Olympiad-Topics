# üîÑ –î–∏–Ω–∞–º–∏—á–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ: –†–∞–∑—à–∏—Ä–µ–Ω–∏ —Ç–µ—Ö–Ω–∏–∫–∏

## üî¢ –î–ü –ø–æ —Ü–∏—Ñ—Ä–∏ (Digit DP)

–ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∑–∞ –∑–∞–¥–∞—á–∏ –æ—Ç —Ç–∏–ø–∞ "–ö–æ–ª–∫–æ —á–∏—Å–ª–∞ –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ $[A, B]$ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–≤–∞—Ç —É—Å–ª–æ–≤–∏–µ $X$?".
–†–µ—à–∞–≤–∞–º–µ –∑–∞–¥–∞—á–∞—Ç–∞ –∑–∞ $[0, B]$ –∏ –≤–∞–¥–∏–º —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –∑–∞ $[0, A-1]$.

**–°—ä—Å—Ç–æ—è–Ω–∏–µ**: `dp(index, count, isLess, isStarted)`
- `index`: –ö–æ—è —Ü–∏—Ñ—Ä–∞ —Ä–∞–∑–≥–ª–µ–∂–¥–∞–º–µ (–æ—Ç–ª—è–≤–æ –Ω–∞–¥—è—Å–Ω–æ).
- `count`: –ü–∞—Ä–∞–º–µ—Ç—ä—Ä—ä—Ç, –∫–æ–π—Ç–æ —Å–ª–µ–¥–∏–º (–Ω–∞–ø—Ä. —Å—É–º–∞ –Ω–∞ —Ü–∏—Ñ—Ä–∏—Ç–µ, –±—Ä–æ–π —Å—Ä–µ—â–∞–Ω–∏—è –Ω–∞ —Ü–∏—Ñ—Ä–∞—Ç–∞ 7 –∏ —Ç.–Ω.).
- `isLess`: –ë—É–ª–µ–≤ —Ñ–ª–∞–≥. `true` –∞–∫–æ —á–∏—Å–ª–æ—Ç–æ, –∫–æ–µ—Ç–æ —Å—Ç—Ä–æ–∏–º, –≤–µ—á–µ –µ —Å—Ç—Ä–æ–≥–æ –ø–æ-–º–∞–ª–∫–æ –æ—Ç –ø—Ä–µ—Ñ–∏–∫—Å–∞ –Ω–∞ $N$. –ê–∫–æ –µ `true`, –º–æ–∂–µ–º –¥–∞ —Å–ª–∞–≥–∞–º–µ –≤—Å—è–∫–∞–∫–≤–∏ —Ü–∏—Ñ—Ä–∏ (0-9). –ê–∫–æ –µ `false`, —Å–º–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏ –¥–æ $N[index]$.
- `isStarted`: –ó–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ –≤–æ–¥–µ—â–∏—Ç–µ –Ω—É–ª–∏.

**–ë–∞–∑–æ–≤ —à–∞–±–ª–æ–Ω:**
```cpp
long long memo[20][200][2];
string S;

long long solve(int idx, int sum, bool isLess) {
    if (idx == S.size()) return sum; // –ë–∞–∑–æ–≤ —Å–ª—É—á–∞–π
    if (memo[idx][sum][isLess] != -1) return memo[idx][sum][isLess];

    long long ans = 0;
    int limit = isLess ? 9 : (S[idx] - '0');

    for (int digit = 0; digit <= limit; digit++) {
        bool nextIsLess = isLess || (digit < limit);
        ans += solve(idx + 1, sum + digit, nextIsLess);
    }
    return memo[idx][sum][isLess] = ans;
}
```

### –†–∞–∑—à–∏—Ä–µ–Ω –ø—Ä–∏–º–µ—Ä: –ë—Ä–æ–π —á–∏—Å–ª–∞ —Å—ä—Å —Å—É–º–∞—Ç–∞ –Ω–∞ —Ü–∏—Ñ—Ä–∏—Ç–µ, –¥–µ–ª–∏–º–∞ –Ω–∞ K

```cpp
#include <iostream>
#include <cstring>
using namespace std;

string num;
int K;
long long dp[20][180][2]; // [–ø–æ–∑–∏—Ü–∏—è][—Å—É–º–∞ % K][isLess]

long long digitDP(int pos, int sum, bool tight) {
    // –ë–∞–∑–æ–≤ —Å–ª—É—á–∞–π - —Å—Ç–∏–≥–Ω–∞–ª–∏ —Å–º–µ –∫—Ä–∞—è –Ω–∞ —á–∏—Å–ª–æ—Ç–æ
    if (pos == num.size()) {
        return sum == 0 ? 1 : 0;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –º–µ–º–æ–∏–∑–∞—Ü–∏—è
    if (dp[pos][sum][tight] != -1) {
        return dp[pos][sum][tight];
    }
    
    int limit = tight ? (num[pos] - '0') : 9;
    long long result = 0;
    
    for (int digit = 0; digit <= limit; digit++) {
        int newSum = (sum + digit) % K;
        bool newTight = tight && (digit == limit);
        result += digitDP(pos + 1, newSum, newTight);
    }
    
    return dp[pos][sum][tight] = result;
}

long long solve(string number) {
    num = number;
    memset(dp, -1, sizeof(dp));
    return digitDP(0, 0, true) - 1; // -1 –∑–∞ –¥–∞ –∏–∑–∫–ª—é—á–∏–º 0
}

int main() {
    K = 3;
    cout << "–ß–∏—Å–ª–∞ –¥–æ 100 —Å—ä—Å —Å—É–º–∞ –Ω–∞ —Ü–∏—Ñ—Ä–∏—Ç–µ, –¥–µ–ª–∏–º–∞ –Ω–∞ 3: " 
         << solve("100") << endl;
    return 0;
}
```

### –¢—Ä–∏–∫–æ–≤–µ –ø—Ä–∏ Digit DP:
1. **–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ –≤–æ–¥–µ—â–∏ –Ω—É–ª–∏**: –î–æ–±–∞–≤—è–º–µ —Ñ–ª–∞–≥ `isStarted`, –∫–æ–π—Ç–æ —Å—Ç–∞–≤–∞ `true` —Å–ª–µ–¥ –ø—ä—Ä–≤–∞—Ç–∞ –Ω–µ–Ω—É–ª–µ–≤–∞ —Ü–∏—Ñ—Ä–∞.
2. **–ò–Ω—Ç–µ—Ä–≤–∞–ª $[A, B]$**: –ü—Ä–µ—Å–º—è—Ç–∞–º–µ `solve(B) - solve(A-1)`.
3. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ –ø–∞–º–µ—Ç—Ç–∞**: –ê–∫–æ –∏–º–∞–º–µ –º–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏, –º–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ `map` –≤–º–µ—Å—Ç–æ –º–∞—Å–∏–≤ –∑–∞ –º–µ–º–æ–∏–∑–∞—Ü–∏—è.

---


## üå≥ –î–ü –≤ –¥—ä—Ä–≤–æ (Tree DP)

–ó–∞–¥–∞—á–∏ –≤—ä—Ä—Ö—É –¥—ä—Ä–≤–µ—Ç–∞ —á–µ—Å—Ç–æ —Å–µ —Ä–µ—à–∞–≤–∞—Ç —Å –î–ü, –∫—ä–¥–µ—Ç–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –∑–∞ –≤—ä–∑–µ–ª $u$ –∑–∞–≤–∏—Å–∏ –æ—Ç –¥–µ—Ü–∞—Ç–∞ –º—É.

**–ü—Ä–∏–º–µ—Ä: –ú–∞–∫—Å–∏–º–∞–ª–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –º–Ω–æ–∂–µ—Å—Ç–≤–æ (Maximum Independent Set)**
–í—ä—Ä–Ω–∏ –º–∞–∫—Å–∏–º–∞–ª–Ω–∏—è –±—Ä–æ–π –≤—ä—Ä—Ö–æ–≤–µ, –∫–æ–∏—Ç–æ –Ω–µ —Å–∞ —Å—ä—Å–µ–¥–∏.
- `dp[u][0]`: –ú–∞–∫—Å–∏–º—É–º –∑–∞ –ø–æ–¥–¥—ä—Ä–≤–æ—Ç–æ –Ω–∞ $u$, –∞–∫–æ $u$ **–Ω–µ –µ** –∏–∑–±—Ä–∞–Ω.
  - $\sum \max(dp[v][0], dp[v][1])$ –∑–∞ –≤—Å–∏—á–∫–∏ –¥–µ—Ü–∞ $v$.
- `dp[u][1]`: –ú–∞–∫—Å–∏–º—É–º –∑–∞ –ø–æ–¥–¥—ä—Ä–≤–æ—Ç–æ, –∞–∫–æ $u$ **–µ** –∏–∑–±—Ä–∞–Ω.
  - $1 + \sum dp[v][0]$ –∑–∞ –≤—Å–∏—á–∫–∏ –¥–µ—Ü–∞ $v$ (–¥–µ—Ü–∞—Ç–∞ –Ω–µ –º–æ–≥–∞—Ç –¥–∞ –±—ä–¥–∞—Ç –∏–∑–±—Ä–∞–Ω–∏).

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 100005;
vector<int> adj[MAXN];
int dp[MAXN][2]; // dp[u][0/1] = –Ω–µ –∏–∑–±—Ä–∞–Ω/–∏–∑–±—Ä–∞–Ω
bool visited[MAXN];

void dfs(int u, int parent) {
    visited[u] = true;
    dp[u][0] = 0; // –Ω–µ –∏–∑–±–∏—Ä–∞–º–µ –≤—ä–∑–µ–ª u
    dp[u][1] = 1; // –∏–∑–±–∏—Ä–∞–º–µ –≤—ä–∑–µ–ª u
    
    for (int v : adj[u]) {
        if (v == parent) continue;
        dfs(v, u);
        
        // –ê–∫–æ u –Ω–µ –µ –∏–∑–±—Ä–∞–Ω, –º–æ–∂–µ–º –¥–∞ –∏–∑–±–µ—Ä–µ–º –∏–ª–∏ –¥–∞ –Ω–µ –∏–∑–±–µ—Ä–µ–º v
        dp[u][0] += max(dp[v][0], dp[v][1]);
        
        // –ê–∫–æ u –µ –∏–∑–±—Ä–∞–Ω, –Ω–µ –º–æ–∂–µ–º –¥–∞ –∏–∑–±–µ—Ä–µ–º v
        dp[u][1] += dp[v][0];
    }
}

int main() {
    int n = 5;
    adj[1] = {2, 3};
    adj[2] = {1, 4, 5};
    adj[3] = {1};
    adj[4] = {2};
    adj[5] = {2};
    
    dfs(1, -1);
    cout << "–ú–∞–∫—Å–∏–º–∞–ª–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –º–Ω–æ–∂–µ—Å—Ç–≤–æ: " 
         << max(dp[1][0], dp[1][1]) << endl;
    return 0;
}
```

### –î—Ä—É–≥ –ø—Ä–∏–º–µ—Ä: –î–∏–∞–º–µ—Ç—ä—Ä –Ω–∞ –¥—ä—Ä–≤–æ —Å –î–ü

–î–∏–∞–º–µ—Ç—ä—Ä—ä—Ç –µ –Ω–∞–π-–¥—ä–ª–≥–∏—è—Ç –ø—ä—Ç –º–µ–∂–¥—É –¥–≤–∞ –≤—ä—Ä—Ö–∞. –ú–æ–∂–µ–º –¥–∞ –≥–æ –Ω–∞–º–µ—Ä–∏–º —Å –¥–≤–µ DFS –æ–±—Ö–æ–∂–¥–∞–Ω–∏—è –∏–ª–∏ —Å –î–ü:

```cpp
int diameter = 0;

int dfs(int u, int parent) {
    int max1 = 0, max2 = 0; // –î–≤–∞ –Ω–∞–π-–¥—ä–ª–≥–∏ –ø—ä—Ç—è –Ω–∞–¥–æ–ª—É
    
    for (int v : adj[u]) {
        if (v == parent) continue;
        int h = dfs(v, u);
        
        if (h > max1) {
            max2 = max1;
            max1 = h;
        } else if (h > max2) {
            max2 = h;
        }
    }
    
    diameter = max(diameter, max1 + max2);
    return max1 + 1;
}
```


---


## üìè –ê–ª–≥–æ—Ä–∏—Ç—ä–º –Ω–∞ –•–∏—Ä—à–±–µ—Ä–≥ (Hirschberg's Algorithm)

–ó–∞ –Ω–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ **—Å–∞–º–∏—è—Ç** LCS (–ù–∞–π-–¥—ä–ª—ä–≥ –æ–±—â –ø–æ–¥–Ω–∏–∑), –∞ –Ω–µ —Å–∞–º–æ –¥—ä–ª–∂–∏–Ω–∞—Ç–∞ –º—É, —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ—Ç–æ –î–ü –∏–∑–∏—Å–∫–≤–∞ $O(N \cdot M)$ –ø–∞–º–µ—Ç. –•–∏—Ä—à–±–µ—Ä–≥ –ø–æ–∑–≤–æ–ª—è–≤–∞ –≤—ä–∑—Å—Ç–∞–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ –ø—ä—Ç—è —Å $O(N \cdot M)$ –≤—Ä–µ–º–µ –∏ —Å–∞–º–æ **$O(\min(N, M))$ –ø–∞–º–µ—Ç**.
- –ò–∑–ø–æ–ª–∑–≤–∞ "–†–∞–∑–¥–µ–ª—è–π –∏ –≤–ª–∞–¥–µ–π", –∫–∞—Ç–æ –Ω–∞–º–∏—Ä–∞ —Å—Ä–µ–¥–Ω–∞—Ç–∞ —Ç–æ—á–∫–∞ –Ω–∞ –æ–ø—Ç–∏–º–∞–ª–Ω–∏—è –ø—ä—Ç –∏ —Ä–µ—à–∞–≤–∞ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∑–∞ –¥–≤–µ—Ç–µ –ø–æ–ª–æ–≤–∏–Ω–∏.

### –î–µ—Ç–∞–π–ª–Ω–æ –æ–±—è—Å–Ω–µ–Ω–∏–µ:

–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏—è—Ç LCS –∏–∑–ø–æ–ª–∑–≤–∞ —Ç–∞–±–ª–∏—Ü–∞ $dp[i][j]$, –∫–æ—è—Ç–æ –æ—Ç–Ω–µ–º–∞ $O(N \cdot M)$ –ø–∞–º–µ—Ç. –•–∏—Ä—à–±–µ—Ä–≥ –∑–∞–±–µ–ª—è–∑–≤–∞, —á–µ:
1. –ó–∞ –¥–∞ –Ω–∞–º–µ—Ä–∏–º –¥—ä–ª–∂–∏–Ω–∞—Ç–∞ –Ω–∞ LCS, –Ω–∏ —Ç—Ä—è–±–≤–∞—Ç —Å–∞–º–æ –¥–≤–∞ —Ä–µ–¥–∞ –Ω–∞–≤–µ–¥–Ω—ä–∂.
2. –ú–æ–∂–µ–º –¥–∞ —Ä–∞–∑–¥–µ–ª–∏–º –ø—Ä–æ–±–ª–µ–º–∞ –Ω–∞ –¥–≤–µ —á–∞—Å—Ç–∏ –ø–æ —Å—Ä–µ–¥–∞—Ç–∞ –Ω–∞ –ø—ä—Ä–≤–∏—è –Ω–∏–∑.
3. –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Ä–µ—à–∞–≤–∞–º–µ –¥–≤–µ—Ç–µ –ø–æ–¥–∑–∞–¥–∞—á–∏.

```cpp
// –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–∏—è —Ä–µ–¥ –æ—Ç –î–ü —Ç–∞–±–ª–∏—Ü–∞—Ç–∞
vector<int> computeLCS(string A, string B) {
    int m = A.size(), n = B.size();
    vector<int> prev(n + 1, 0), curr(n + 1, 0);
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (A[i-1] == B[j-1]) {
                curr[j] = prev[j-1] + 1;
            } else {
                curr[j] = max(prev[j], curr[j-1]);
            }
        }
        swap(prev, curr);
        fill(curr.begin(), curr.end(), 0);
    }
    return prev;
}

// –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è –Ω–∞ –•–∏—Ä—à–±–µ—Ä–≥
string hirschberg(string A, string B) {
    if (A.empty()) return "";
    if (A.size() == 1) {
        for (char c : B) {
            if (c == A[0]) return string(1, A[0]);
        }
        return "";
    }
    
    int mid = A.size() / 2;
    string A1 = A.substr(0, mid);
    string A2 = A.substr(mid);
    
    // –ù–∞–º–∏—Ä–∞–º–µ –æ–ø—Ç–∏–º–∞–ª–Ω–æ—Ç–æ —Ä–∞–∑–¥–µ–ª—è–Ω–µ –Ω–∞ B
    vector<int> L1 = computeLCS(A1, B);
    
    // –û–±—Ä—ä—â–∞–º–µ –Ω–∏–∑–æ–≤–µ—Ç–µ –∑–∞ –≤—Ç–æ—Ä–∞—Ç–∞ –ø–æ–ª–æ–≤–∏–Ω–∞
    reverse(A2.begin(), A2.end());
    reverse(B.begin(), B.end());
    vector<int> L2 = computeLCS(A2, B);
    reverse(B.begin(), B.end());
    
    // –ù–∞–º–∏—Ä–∞–º–µ –Ω–∞–π-–¥–æ–±—Ä–∞—Ç–∞ —Ç–æ—á–∫–∞ –∑–∞ —Ä–∞–∑–¥–µ–ª—è–Ω–µ
    int k = 0, maxVal = L1[0] + L2[B.size()];
    for (int j = 0; j <= B.size(); j++) {
        if (L1[j] + L2[B.size() - j] > maxVal) {
            maxVal = L1[j] + L2[B.size() - j];
            k = j;
        }
    }
    
    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Ä–µ—à–∞–≤–∞–º–µ –¥–≤–µ—Ç–µ —á–∞—Å—Ç–∏
    return hirschberg(A1, B.substr(0, k)) + 
           hirschberg(A.substr(mid), B.substr(k));
}
```

–°–ª–æ–∂–Ω–æ—Å—Ç: $O(N \cdot M)$ –≤—Ä–µ–º–µ, $O(\min(N, M))$ –ø–∞–º–µ—Ç.


---


## üéí –†–∞–Ω–∏—Ü–∞ (Knapsack) - –í–∞—Ä–∏–∞—Ü–∏–∏

1. **Unbounded Knapsack**: –í—Å–µ–∫–∏ –ø—Ä–µ–¥–º–µ—Ç –º–æ–∂–µ –¥–∞ —Å–µ –ø–æ–ª–∑–≤–∞ –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ.
   - $dp[w] = \max(dp[w], dp[w - weight[i]] + value[i])$ (—Ü–∏–∫—ä–ª—ä—Ç –µ –æ—Ç –¥–æ–ª—É –Ω–∞–≥–æ—Ä–µ).
2. **Limited Knapsack**: –í—Å–µ–∫–∏ –ø—Ä–µ–¥–º–µ—Ç –∏–º–∞ $C_i$ –±—Ä–æ–π–∫–∏.
   - –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –†–∞–∑–ª–∞–≥–∞–º–µ $C_i$ –Ω–∞ —Å—Ç–µ–ø–µ–Ω–∏ –Ω–∞ –¥–≤–æ–π–∫–∞—Ç–∞ $(1, 2, 4, \dots)$ –∏ —Å–≤–µ–∂–¥–∞–º–µ –∑–∞–¥–∞—á–∞—Ç–∞ –¥–æ 0/1 Knapsack ($O(N \cdot W \cdot \log C)$).

### –î–µ—Ç–∞–π–ª–Ω–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞ Unbounded Knapsack:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int unboundedKnapsack(int W, vector<int>& weight, vector<int>& value) {
    int n = weight.size();
    vector<int> dp(W + 1, 0);
    
    // –ó–∞ –≤—Å—è–∫–æ —Ç–µ–≥–ª–æ –æ—Ç 1 –¥–æ W
    for (int w = 1; w <= W; w++) {
        // –ü—Ä–æ–±–≤–∞–º–µ –≤—Å–µ–∫–∏ –ø—Ä–µ–¥–º–µ—Ç
        for (int i = 0; i < n; i++) {
            if (weight[i] <= w) {
                dp[w] = max(dp[w], dp[w - weight[i]] + value[i]);
            }
        }
    }
    
    return dp[W];
}

int main() {
    int W = 8;
    vector<int> weight = {1, 3, 4, 5};
    vector<int> value = {10, 40, 50, 70};
    
    cout << "–ú–∞–∫—Å–∏–º–∞–ª–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç: " 
         << unboundedKnapsack(W, weight, value) << endl;
    return 0;
}
```

### Limited Knapsack —Å Binary Decomposition:

```cpp
int limitedKnapsack(int W, vector<int>& weight, 
                    vector<int>& value, vector<int>& count) {
    int n = weight.size();
    vector<pair<int,int>> items; // {—Ç–µ–≥–ª–æ, —Å—Ç–æ–π–Ω–æ—Å—Ç}
    
    // –†–∞–∑–ª–∞–≥–∞–º–µ –≤—Å–µ–∫–∏ –ø—Ä–µ–¥–º–µ—Ç –Ω–∞ —Å—Ç–µ–ø–µ–Ω–∏ –Ω–∞ 2
    for (int i = 0; i < n; i++) {
        int c = count[i];
        int k = 1;
        while (k <= c) {
            items.push_back({weight[i] * k, value[i] * k});
            c -= k;
            k *= 2;
        }
        if (c > 0) {
            items.push_back({weight[i] * c, value[i] * c});
        }
    }
    
    // –°—Ç–∞–Ω–¥–∞—Ä—Ç–µ–Ω 0/1 Knapsack
    vector<int> dp(W + 1, 0);
    for (auto [w, v] : items) {
        for (int i = W; i >= w; i--) {
            dp[i] = max(dp[i], dp[i - w] + v);
        }
    }
    
    return dp[W];
}
```

### Knapsack —Å —Ç–æ—á–Ω–∞ —Å—É–º–∞:

–ü–æ–Ω—è–∫–æ–≥–∞ —Å–µ –∏—Å–∫–∞ –¥–∞ –Ω–∞–º–µ—Ä–∏–º –Ω–∞—á–∏–Ω–∏ –¥–∞ –∑–∞–ø—ä–ª–Ω–∏–º —Ä–∞–Ω–∏—Ü–∞—Ç–∞ —Å —Ç–æ—á–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ —Ç–µ–≥–ª–æ:

```cpp
int exactKnapsack(int target, vector<int>& coins) {
    vector<int> dp(target + 1, 0);
    dp[0] = 1; // –ï–¥–∏–Ω –Ω–∞—á–∏–Ω –¥–∞ –Ω–∞–ø—Ä–∞–≤–∏–º 0
    
    for (int coin : coins) {
        for (int i = coin; i <= target; i++) {
            dp[i] += dp[i - coin];
        }
    }
    
    return dp[target];
}
```


---


## üï∏Ô∏è –î–ü –≤—ä—Ä—Ö—É –ø—Ä–æ—Ñ–∏–ª (Broken Profile DP) - –î–µ—Ç–∞–π–ª–∏

–ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∑–∞ –∑–∞–ø—ä–ª–≤–∞–Ω–µ –Ω–∞ –º—Ä–µ–∂–∏ $N \times M$ (–∫—ä–¥–µ—Ç–æ $N$ –µ –º–∞–ª–∫–æ).
–°—Ç—Ä–æ–∏–º –º—Ä–µ–∂–∞—Ç–∞ –∫–ª–µ—Ç–∫–∞ –ø–æ –∫–ª–µ—Ç–∫–∞. –ü—Ä–æ—Ñ–∏–ª—ä—Ç –µ –≥—Ä–∞–Ω–∏—Ü–∞—Ç–∞ –º–µ–∂–¥—É –æ–±—Ä–∞–±–æ—Ç–µ–Ω–∏—Ç–µ –∏ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–µ–Ω–∏—Ç–µ –∫–ª–µ—Ç–∫–∏.
- –ê–∫–æ –º–µ—Å—Ç–∏–º —Ä–µ–¥ –ø–æ —Ä–µ–¥, –ø—Ä–æ—Ñ–∏–ª—ä—Ç –µ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –Ω–∞ —Ç–µ–∫—É—â–∏—è —Ä–µ–¥ (–±–∏—Ç–æ–≤–∞ –º–∞—Å–∫–∞).
- –ê–∫–æ –º–µ—Å—Ç–∏–º –∫–ª–µ—Ç–∫–∞ –ø–æ –∫–ª–µ—Ç–∫–∞, –ø—Ä–æ—Ñ–∏–ª—ä—Ç –≤–∫–ª—é—á–≤–∞ $N$ –±–∏—Ç–∞ (—á–∞—Å—Ç–∏ –æ—Ç —Ç–µ–∫—É—â–∏—è –∏ —Å–ª–µ–¥–≤–∞—â–∏—è —Ä–µ–¥).

### –ö–ª–∞—Å–∏—á–µ—Å–∫–∏ –ø—Ä–∏–º–µ—Ä: –ü–æ–∫—Ä–∏–≤–∞–Ω–µ —Å –¥–æ–º–∏–Ω–∞

–ó–∞–¥–∞—á–∞: –ü–æ –∫–æ–ª–∫–æ –Ω–∞—á–∏–Ω–∞ –º–æ–∂–µ–º –¥–∞ –ø–æ–∫—Ä–∏–µ–º –º—Ä–µ–∂–∞ $N \times M$ —Å –¥–æ–º–∏–Ω–∞ $1 \times 2$?

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 11;
const int MAXM = 1001;
long long dp[MAXM][1 << MAXN];
int n, m;

// –ì–µ–Ω–µ—Ä–∏—Ä–∞ –≤—Å–∏—á–∫–∏ –≤–∞–ª–∏–¥–Ω–∏ –ø—Ä–µ—Ö–æ–¥–∏ –æ—Ç –º–∞—Å–∫–∞ –∫—ä–º —Å–ª–µ–¥–≤–∞—â–∞ –º–∞—Å–∫–∞
void gen(int pos, int cur_mask, int next_mask, int col, long long val) {
    if (pos == n) {
        dp[col + 1][next_mask] += val;
        return;
    }
    
    if (cur_mask & (1 << pos)) {
        // –í–µ—á–µ –∑–∞–ø—ä–ª–Ω–µ–Ω–∞ - –ø—Ä–æ–¥—ä–ª–∂–∞–≤–∞–º–µ
        gen(pos + 1, cur_mask, next_mask, col, val);
    } else {
        // –û–ø—Ü–∏—è 1: –í–µ—Ä—Ç–∏–∫–∞–ª–Ω–æ –¥–æ–º–∏–Ω–æ
        gen(pos + 1, cur_mask | (1 << pos), next_mask | (1 << pos), col, val);
        
        // –û–ø—Ü–∏—è 2: –•–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ –¥–æ–º–∏–Ω–æ (–∞–∫–æ –∏–º–∞ –º—è—Å—Ç–æ)
        if (pos + 1 < n && !(cur_mask & (1 << (pos + 1)))) {
            gen(pos + 2, cur_mask | (1 << pos) | (1 << (pos + 1)), 
                next_mask, col, val);
        }
    }
}

long long countTilings(int N, int M) {
    n = N; m = M;
    memset(dp, 0, sizeof(dp));
    dp[0][0] = 1;
    
    for (int col = 0; col < m; col++) {
        for (int mask = 0; mask < (1 << n); mask++) {
            if (dp[col][mask] > 0) {
                gen(0, mask, 0, col, dp[col][mask]);
            }
        }
    }
    
    return dp[m][0];
}

int main() {
    cout << "–ù–∞—á–∏–Ω–∏ –∑–∞ –ø–æ–∫—Ä–∏–≤–∞–Ω–µ 3x4: " 
         << countTilings(3, 4) << endl;
    return 0;
}
```

–°–ª–æ–∂–Ω–æ—Å—Ç: $O(M \cdot 2^N \cdot N)$ –∫—ä–¥–µ—Ç–æ $N \leq 10$.

---

## üéØ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –∑–∞–¥–∞—á–∏

1. **CSES: Dice Combinations** - –ë–∞–∑–æ–≤–æ –î–ü
2. **CSES: Counting Towers** - Profile DP
3. **Codeforces 1073E** - Digit DP —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∑–∞ —Ä–∞–∑–ª–∏—á–Ω–∏ —Ü–∏—Ñ—Ä–∏
4. **CSES: Tree Distances II** - Tree DP –∑–∞ —Å—É–º–∞ –Ω–∞ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è
5. **AtCoder DP Contest** - –ö–æ–ª–µ–∫—Ü–∏—è –æ—Ç 26 –î–ü –∑–∞–¥–∞—á–∏

---

## üí° –°—ä–≤–µ—Ç–∏ –∏ –¥–æ–±—Ä–∏ –ø—Ä–∞–∫—Ç–∏–∫–∏

1. **–î–µ—Ñ–∏–Ω–∏—Ä–∞–π—Ç–µ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ —è—Å–Ω–æ**: –ó–∞–ø–∏—à–µ—Ç–µ —Å–∏ –∫–∞–∫–≤–æ –æ–∑–Ω–∞—á–∞–≤–∞ –≤—Å–µ–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—ä—Ä.
2. **–ü—Ä–æ–≤–µ—Ä–µ—Ç–µ –≥—Ä–∞–Ω–∏—Ü–∏—Ç–µ**: –ö–∞–∫–≤–∏ —Å–∞ –±–∞–∑–æ–≤–∏—Ç–µ —Å–ª—É—á–∞–∏?
3. **–ú–µ–º–æ–∏–∑–∞—Ü–∏—è —Å—Ä–µ—â—É —Ç–∞–±—É–ª–∞—Ü–∏—è**: –ú–µ–º–æ–∏–∑–∞—Ü–∏—è—Ç–∞ (top-down) –µ –ø–æ-–∏–Ω—Ç—É–∏—Ç–∏–≤–Ω–∞, –Ω–æ —Ç–∞–±—É–ª–∞—Ü–∏—è—Ç–∞ (bottom-up) —á–µ—Å—Ç–æ –µ –ø–æ-–±—ä—Ä–∑–∞.
4. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ –ø–∞–º–µ—Ç—Ç–∞**: –ê–∫–æ `dp[i]` –∑–∞–≤–∏—Å–∏ —Å–∞–º–æ –æ—Ç `dp[i-1]`, –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –¥–≤–∞ –º–∞—Å–∏–≤–∞ –≤–º–µ—Å—Ç–æ —Ü—è–ª–∞ –º–∞—Ç—Ä–∏—Ü–∞.
5. **–°–ª–µ–¥–µ—Ç–µ –∑–∞ –ø—Ä–µ–ø—ä–ª–≤–∞–Ω–µ**: –ü—Ä–∏ –≥–æ–ª–µ–º–∏ —á–∏—Å–ª–∞ –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ `long long` –∏–ª–∏ –º–æ–¥—É–ª–Ω–∞ –∞—Ä–∏—Ç–º–µ—Ç–∏–∫–∞.

---

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–î–∏–Ω–∞–º–∏—á–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –µ –∏–∑–∫—É—Å—Ç–≤–æ. –ù–∞–π-–≤–∞–∂–Ω–∞—Ç–∞ —Å—Ç—ä–ø–∫–∞ –µ –¥–∞ –¥–µ—Ñ–∏–Ω–∏—Ä–∞—Ç–µ —Å—ä—Å—Ç–æ—è–Ω–∏–µ, –∫–æ–µ—Ç–æ —Å—ä–¥—ä—Ä–∂–∞ **–¥–æ—Å—Ç–∞—Ç—ä—á–Ω–æ** –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –±—ä–¥–µ—â–∏—Ç–µ —Ä–µ—à–µ–Ω–∏—è, –Ω–æ –µ **–º–∏–Ω–∏–º–∞–ª–Ω–æ** –∫–∞—Ç–æ —Ä–∞–∑–º–µ—Ä. –í–∏–Ω–∞–≥–∏ –ø—Ä–æ–≤–µ—Ä—è–≤–∞–π—Ç–µ –∑–∞ –ø—Ä–∏–ø–æ–∫—Ä–∏–≤–∞—â–∏ —Å–µ –ø–æ–¥–∑–∞–¥–∞—á–∏! –ü—Ä–∞–∫—Ç–∏–∫—É–≤–∞–π—Ç–µ —Ä–µ–¥–æ–≤–Ω–æ —Å —Ä–∞–∑–ª–∏—á–Ω–∏ —Ç–∏–ø–æ–≤–µ –∑–∞–¥–∞—á–∏, –∑–∞ –¥–∞ —Ä–∞–∑–≤–∏–µ—Ç–µ –∏–Ω—Ç—É–∏—Ü–∏—è –∫–æ–≥–∞ –∏ –∫–∞–∫ –¥–∞ –ø—Ä–∏–ª–∞–≥–∞—Ç–µ –î–ü.
