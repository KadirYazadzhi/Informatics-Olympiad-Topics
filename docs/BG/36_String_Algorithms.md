# üßµ –ê–ª–≥–æ—Ä–∏—Ç–º–∏ –≤—ä—Ä—Ö—É –ù–∏–∑–æ–≤–µ (String Algorithms)

–ï—Ñ–µ–∫—Ç–∏–≤–Ω–∞—Ç–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ —Ç–µ–∫—Å—Ç –µ –∫–ª—é—á–æ–≤–∞ –æ–±–ª–∞—Å—Ç. –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ—Ç–æ —Ç—ä—Ä—Å–µ–Ω–µ (`std::string::find`) –µ $O(N \cdot M)$ –≤ –Ω–∞–π-–ª–æ—à–∏—è —Å–ª—É—á–∞–π, –∫–æ–µ—Ç–æ –µ –±–∞–≤–Ω–æ. –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–∏—Ç–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∏ –ø–æ—Å—Ç–∏–≥–∞—Ç $O(N + M)$. 

## 1. –ü–æ–ª–∏–Ω–æ–º–Ω–æ –•–µ—à–∏—Ä–∞–Ω–µ (Rolling Hash)

–ù–∞–π-–≥—ä–≤–∫–∞–≤–∏—è—Ç –º–µ—Ç–æ–¥. –ü—Ä–µ–≤—Ä—ä—â–∞–º–µ –Ω–∏–∑–æ–≤–µ—Ç–µ –≤ —á–∏—Å–ª–∞, —Ç–∞–∫–∞ —á–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ—Ç–æ –¥–∞ —Å—Ç–∞–≤–∞ –∑–∞ $O(1)$.
–§–æ—Ä–º—É–ª–∞ –∑–∞ —Ö–µ—à –Ω–∞ –Ω–∏–∑ $S$:
$H(S) = (S[0] \cdot P^0 + S[1] \cdot P^1 + \dots + S[n-1] \cdot P^{n-1}) \pmod M$

*   $P$: –û—Å–Ω–æ–≤–∞ (–Ω–∞–ø—Ä. 31, 53, –∏–ª–∏ —Å–ª—É—á–∞–π–Ω–æ —á–∏—Å–ª–æ > —Ä–∞–∑–º–µ—Ä–∞ –Ω–∞ –∞–∑–±—É–∫–∞—Ç–∞).
*   $M$: –ì–æ–ª—è–º–æ –ø—Ä–æ—Å—Ç–æ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä. $10^9 + 7$). 

### Rolling Hash —Å–≤–æ–π—Å—Ç–≤–æ
–ú–æ–∂–µ–º –¥–∞ –∏–∑—á–∏—Å–ª–∏–º —Ö–µ—à–∞ –Ω–∞ –≤—Å–µ–∫–∏ –ø–æ–¥–Ω–∏–∑ $S[i \dots j]$ –∑–∞ $O(1)$, –∞–∫–æ —Å–º–µ –ø—Ä–µ–∫–∞–ª–∫—É–ª–∏—Ä–∞–ª–∏ –ø—Ä–µ—Ñ–∏–∫—Å–∏—Ç–µ:
$Hash(i, j) = (H[j] - H[i-1]) \cdot P^{-i} \pmod M$
–í–º–µ—Å—Ç–æ –¥–µ–ª–µ–Ω–∏–µ —Å $P^i$, –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ —É–º–Ω–æ–∂–∞–≤–∞–º–µ –¥—è—Å–Ω–∞—Ç–∞ —Å—Ç—Ä–∞–Ω–∞ –Ω–∞ —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ—Ç–æ, –∑–∞ –¥–∞ –∏–∑–±–µ–≥–Ω–µ–º –º–æ–¥—É–ª—è—Ä–Ω–æ –æ–±—Ä–∞—Ç–Ω–æ.

**–î–≤–æ–µ–Ω –•–µ—à**: –ó–∞ –¥–∞ –∏–∑–±–µ–≥–Ω–µ–º –∫–æ–ª–∏–∑–∏–∏ (—Ä–∞–∑–ª–∏—á–Ω–∏ –Ω–∏–∑–æ–≤–µ —Å –µ–¥–Ω–∞–∫—ä–≤ —Ö–µ—à), –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –¥–≤–µ –¥–≤–æ–π–∫–∏ $(P_1, M_1)$ –∏ $(P_2, M_2)$. –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—Ç–∞ –∑–∞ –∫–æ–ª–∏–∑–∏—è —Å—Ç–∞–≤–∞ –Ω–∏—â–æ–∂–Ω–∞.

### –ü—ä–ª–Ω–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è:

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class StringHash {
    const long long P = 31;
    const long long M = 1e9 + 7;
    vector<long long> hash_val, pow_p;
    int n;
    
public:
    StringHash(const string& s) {
        n = s.size();
        hash_val.resize(n + 1, 0);
        pow_p.resize(n + 1, 1);
        
        for (int i = 0; i < n; i++) {
            hash_val[i + 1] = (hash_val[i] + (s[i] - 'a' + 1) * pow_p[i]) % M;
            pow_p[i + 1] = (pow_p[i] * P) % M;
        }
    }
    
    // –•–µ—à –Ω–∞ –ø–æ–¥–Ω–∏–∑ [l, r]
    long long getHash(int l, int r) {
        long long result = (hash_val[r + 1] - hash_val[l] + M) % M;
        return result;
    }
    
    // –°—Ä–∞–≤–Ω—è–≤–∞–Ω–µ –Ω–∞ –¥–≤–∞ –ø–æ–¥–Ω–∏–∑–æ–≤–µ
    bool equals(int l1, int r1, int l2, int r2) {
        int len1 = r1 - l1 + 1;
        int len2 = r2 - l2 + 1;
        if (len1 != len2) return false;
        
        long long h1 = getHash(l1, r1);
        long long h2 = getHash(l2, r2);
        
        // –ù–æ—Ä–º–∞–ª–∏–∑–∏—Ä–∞–Ω–µ –∑–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
        if (l1 < l2) {
            h1 = (h1 * pow_p[l2 - l1]) % M;
        } else {
            h2 = (h2 * pow_p[l1 - l2]) % M;
        }
        
        return h1 == h2;
    }
};

int main() {
    string s = "abracadabra";
    StringHash sh(s);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ "abra" —Å–µ —Å—Ä–µ—â–∞ –Ω–∞ –ø–æ–∑–∏—Ü–∏—è 0 –∏ 7
    cout << "–ü–æ–¥–Ω–∏–∑ [0,3] == [7,10]: " 
         << sh.equals(0, 3, 7, 10) << endl;
    return 0;
}
```

### –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–∞ —Ö–µ—à–∏—Ä–∞–Ω–µ:

1. **–¢—ä—Ä—Å–µ–Ω–µ –Ω–∞ –ø–æ–¥–Ω–∏–∑** –∑–∞ $O(N)$
2. **–ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–∞–π-–¥—ä–ª—ä–≥ –æ–±—â –ø–æ–¥–Ω–∏–∑** –Ω–∞ –¥–≤–∞ –Ω–∏–∑–∞
3. **–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º** –Ω–∞ –≤—Å–µ–∫–∏ –ø–æ–¥–Ω–∏–∑
4. **Rabin-Karp –∞–ª–≥–æ—Ä–∏—Ç—ä–º** –∑–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —à–∞–±–ª–æ–Ω–∏

## 2. –ê–ª–≥–æ—Ä–∏—Ç—ä–º –Ω–∞ –ö–Ω—É—Ç-–ú–æ—Ä–∏—Å-–ü—Ä–∞—Ç (KMP)

–ò–∑–ø–æ–ª–∑–≤–∞ **–ü—Ä–µ—Ñ–∏–∫—Å–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è** ($\pi$).
$\pi[i]$ –µ –¥—ä–ª–∂–∏–Ω–∞—Ç–∞ –Ω–∞ –Ω–∞–π-–¥—ä–ª–≥–∏—è —Å–æ–±—Å—Ç–≤–µ–Ω –ø—Ä–µ—Ñ–∏–∫—Å –Ω–∞ –ø–æ–¥–Ω–∏–∑–∞ $S[0 \dots i]$, –∫–æ–π—Ç–æ –µ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∏ –Ω–µ–≥–æ–≤ —Å—É—Ñ–∏–∫—Å.

–ü—Ä–∏–º–µ—Ä: $S = \text{"ababa"}$
*   $\pi[0]$ ("a") = 0
*   $\pi[1]$ ("ab") = 0
*   $\pi[2]$ ("aba") = 1 ("a")
*   $\pi[3]$ ("abab") = 2 ("ab")
*   $\pi[4]$ ("ababa") = 3 ("aba")

### –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–∞ $\pi$:
1.  **–¢—ä—Ä—Å–µ–Ω–µ –Ω–∞ –ø–æ–¥–Ω–∏–∑**: –¢—ä—Ä—Å–∏–º $P$ –≤ $T$. –ü—Ä–∞–≤–∏–º –Ω–∏–∑ $S = P + \# + T$. –í—Å–∏—á–∫–∏ –ø–æ–∑–∏—Ü–∏–∏, –∫—ä–¥–µ—Ç–æ $\pi[i] == |P|$, —Å–∞ —Å—Ä–µ—â–∞–Ω–∏—è.
2.  **–ú–∏–Ω–∏–º–∞–ª–µ–Ω –ø–µ—Ä–∏–æ–¥**: –î—ä–ª–∂–∏–Ω–∞—Ç–∞ –Ω–∞ –Ω–∞–π-–º–∞–ª–∫–∏—è –ø–µ—Ä–∏–æ–¥ –Ω–∞ –Ω–∏–∑ —Å –¥—ä–ª–∂–∏–Ω–∞ $N$ –µ $N - \pi[N-1]$ (–∞–∫–æ $N$ —Å–µ –¥–µ–ª–∏ –Ω–∞ —Ç–æ–≤–∞ —á–∏—Å–ª–æ).

```cpp
vector<int> prefix_function(string s) {
    int n = s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i-1];
        while (j > 0 && s[i] != s[j])
            j = pi[j-1];
        if (s[i] == s[j])
            j++;
        pi[i] = j;
    }
    return pi;
}
```

### –¢—ä—Ä—Å–µ–Ω–µ –Ω–∞ —à–∞–±–ª–æ–Ω —Å KMP:

```cpp
vector<int> kmp_search(string text, string pattern) {
    string combined = pattern + "#" + text;
    vector<int> pi = prefix_function(combined);
    vector<int> occurrences;
    
    int m = pattern.size();
    for (int i = m + 1; i < combined.size(); i++) {
        if (pi[i] == m) {
            // –ù–∞–º–µ—Ä–µ–Ω–æ —Å—ä–≤–ø–∞–¥–µ–Ω–∏–µ –Ω–∞ –ø–æ–∑–∏—Ü–∏—è i - 2*m
            occurrences.push_back(i - 2 * m);
        }
    }
    
    return occurrences;
}
```

### –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –ø–µ—Ä–∏–æ–¥:

```cpp
int minimalPeriod(string s) {
    int n = s.size();
    vector<int> pi = prefix_function(s);
    int period_len = n - pi[n - 1];
    
    if (n % period_len == 0) {
        return period_len;
    }
    return n; // –¶–µ–ª–∏—è—Ç –Ω–∏–∑ –µ –ø–µ—Ä–∏–æ–¥
}
```

## 3. Z-–ê–ª–≥–æ—Ä–∏—Ç—ä–º

–ò–∑—á–∏—Å–ª—è–≤–∞ **Z-—Ñ—É–Ω–∫—Ü–∏—è**.
$Z[i]$ –µ –¥—ä–ª–∂–∏–Ω–∞—Ç–∞ –Ω–∞ –Ω–∞–π-–¥—ä–ª–≥–∏—è –æ–±—â –ø—Ä–µ—Ñ–∏–∫—Å –º–µ–∂–¥—É –Ω–∏–∑–∞ $S$ –∏ —Å—É—Ñ–∏–∫—Å–∞ –Ω–∞ $S$, –∑–∞–ø–æ—á–≤–∞—â –æ—Ç $i$.
*   $Z[0]$ –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ –Ω–µ —Å–µ –¥–µ—Ñ–∏–Ω–∏—Ä–∞ (–∏–ª–∏ –µ $N$).
*   –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ –Ω–∞ KMP, –ø–æ–∑–≤–æ–ª—è–≤–∞ —Ç—ä—Ä—Å–µ–Ω–µ –Ω–∞ —à–∞–±–ª–æ–Ω –∑–∞ –ª–∏–Ω–µ–π–Ω–æ –≤—Ä–µ–º–µ.

### –ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞ Z-–∞–ª–≥–æ—Ä–∏—Ç—ä–º:

```cpp
vector<int> z_function(string s) {
    int n = s.size();
    vector<int> z(n);
    z[0] = n;
    
    int l = 0, r = 0;
    for (int i = 1; i < n; i++) {
        if (i <= r) {
            z[i] = min(r - i + 1, z[i - l]);
        }
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
            z[i]++;
        }
        if (i + z[i] - 1 > r) {
            l = i;
            r = i + z[i] - 1;
        }
    }
    
    return z;
}
```

### –¢—ä—Ä—Å–µ–Ω–µ –Ω–∞ —à–∞–±–ª–æ–Ω —Å—ä—Å Z-–∞–ª–≥–æ—Ä–∏—Ç—ä–º:

```cpp
vector<int> z_search(string text, string pattern) {
    string combined = pattern + "$" + text;
    vector<int> z = z_function(combined);
    vector<int> occurrences;
    
    int m = pattern.size();
    for (int i = m + 1; i < combined.size(); i++) {
        if (z[i] == m) {
            occurrences.push_back(i - m - 1);
        }
    }
    
    return occurrences;
}
```

–°–ª–æ–∂–Ω–æ—Å—Ç: $O(N)$ –∑–∞ –ø–æ—Å—Ç—Ä–æ—è–≤–∞–Ω–µ –Ω–∞ Z-–º–∞—Å–∏–≤–∞.

## 4. –ê–ª–≥–æ—Ä–∏—Ç—ä–º –Ω–∞ –ú–∞–Ω–∞–∫—ä—Ä (Manacher)

–ù–∞–º–∏—Ä–∞ –Ω–∞–π-–¥—ä–ª–≥–∏—è –ø–∞–ª–∏–Ω–¥—Ä–æ–º –≤—ä–≤ –≤—Å—è–∫–∞ –ø–æ–∑–∏—Ü–∏—è –Ω–∞ –Ω–∏–∑–∞ –∑–∞ $O(N)$.
*   –†–∞–∑–≥–ª–µ–∂–¥–∞ –æ—Ç–¥–µ–ª–Ω–æ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∏ —Å –Ω–µ—á–µ—Ç–Ω–∞ –¥—ä–ª–∂–∏–Ω–∞ (—Ü–µ–Ω—Ç—ä—Ä –≤ —Å–∏–º–≤–æ–ª) –∏ —á–µ—Ç–Ω–∞ –¥—ä–ª–∂–∏–Ω–∞ (—Ü–µ–Ω—Ç—ä—Ä –º–µ–∂–¥—É —Å–∏–º–≤–æ–ª–∏).

### –ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è:

```cpp
string preprocess(string s) {
    // –î–æ–±–∞–≤—è–º–µ '#' –º–µ–∂–¥—É —Å–∏–º–≤–æ–ª–∏—Ç–µ –∑–∞ –µ–¥–∏–Ω–µ–Ω –ø–æ–¥—Ö–æ–¥
    string result = "#";
    for (char c : s) {
        result += c;
        result += '#';
    }
    return result;
}

vector<int> manacher(string s) {
    string t = preprocess(s);
    int n = t.size();
    vector<int> p(n, 0); // p[i] = —Ä–∞–¥–∏—É—Å –Ω–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞ —Ü–µ–Ω—Ç—Ä–∏—Ä–∞–Ω –≤ i
    
    int center = 0, right = 0;
    for (int i = 0; i < n; i++) {
        int mirror = 2 * center - i;
        
        if (i < right) {
            p[i] = min(right - i, p[mirror]);
        }
        
        // –û–ø–∏—Ç –∑–∞ —Ä–∞–∑—à–∏—Ä—è–≤–∞–Ω–µ
        while (i + p[i] + 1 < n && i - p[i] - 1 >= 0 &&
               t[i + p[i] + 1] == t[i - p[i] - 1]) {
            p[i]++;
        }
        
        // –û–±–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ —Ü–µ–Ω—Ç—ä—Ä–∞
        if (i + p[i] > right) {
            center = i;
            right = i + p[i];
        }
    }
    
    return p;
}

string longestPalindrome(string s) {
    vector<int> p = manacher(s);
    int maxLen = 0, centerIndex = 0;
    
    for (int i = 0; i < p.size(); i++) {
        if (p[i] > maxLen) {
            maxLen = p[i];
            centerIndex = i;
        }
    }
    
    // –ü—Ä–µ–≤—Ä—ä—â–∞–º–µ –æ–±—Ä–∞—Ç–Ω–æ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª–µ–Ω –∏–Ω–¥–µ–∫—Å
    int start = (centerIndex - maxLen) / 2;
    return s.substr(start, maxLen);
}
```

### –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ: –ë—Ä–æ–µ–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∏

```cpp
long long countAllPalindromes(string s) {
    vector<int> p = manacher(s);
    long long count = 0;
    
    for (int radius : p) {
        // –í—Å–µ–∫–∏ —Ä–∞–¥–∏—É—Å –¥–∞–≤–∞ (radius + 1) / 2 –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞
        count += (radius + 1) / 2;
    }
    
    return count;
}
```

–°–ª–æ–∂–Ω–æ—Å—Ç: $O(N)$ –≤—Ä–µ–º–µ –∏ $O(N)$ –ø–∞–º–µ—Ç.

## 5. –°—Ä–∞–≤–Ω–µ–Ω–∏–µ

| –ê–ª–≥–æ—Ä–∏—Ç—ä–º | –°–ª–æ–∂–Ω–æ—Å—Ç | –ü—Ä–µ–¥–∏–º—Å—Ç–≤–∞ | –ù–µ–¥–æ—Å—Ç–∞—Ç—ä—Ü–∏ |
| :--- | :--- | :--- | :--- |
| **Hashing** | $O(N)$ | –õ–µ—Å–µ–Ω –∫–æ–¥, –≥—ä–≤–∫–∞–≤ (–ø–∞–ª–∏–Ω–¥—Ä–æ–º–∏, —Å—Ä–∞–≤–Ω–µ–Ω–∏—è) | –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç –∑–∞ –∫–æ–ª–∏–∑–∏—è (–º–∞–∫–∞—Ä –∏ –º–∞–ª–∫–∞) |
| **KMP** | $O(N)$ | –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Å—Ç–∏—á–µ–Ω, –ø–æ–ª–µ–∑–µ–Ω –∑–∞ –ø–µ—Ä–∏–æ–¥–∏—á–Ω–æ—Å—Ç | –ú–∞–ª–∫–æ –ø–æ-—Å–ª–æ–∂–Ω–∞ –ª–æ–≥–∏–∫–∞ |
| **Z-Algo** | $O(N)$ | –ü–æ-–∏–Ω—Ç—É–∏—Ç–∏–≤–µ–Ω –∑–∞ –Ω—è–∫–æ–∏ –∑–∞–¥–∞—á–∏ –æ—Ç KMP | –ü–æ-—Ä—è–¥–∫–æ –∏–∑–ø–æ–ª–∑–≤–∞–Ω |
| **Manacher** | $O(N)$ | –ù–∞–π-–±—ä—Ä–∑ –∑–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∏ | –°–ø–µ—Ü–∏—Ñ–∏—á–µ–Ω –∑–∞ –µ–¥–Ω–∞ –∑–∞–¥–∞—á–∞ |
| **Aho-Corasick**| $O(N)$ | –¢—ä—Ä—Å–µ–Ω–µ –Ω–∞ **–º–Ω–æ–∂–µ—Å—Ç–≤–æ** —à–∞–±–ª–æ–Ω–∏ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ | –ë–∞–∑–∏—Ä–∞–Ω –Ω–∞ Trie (–¢–µ–º–∞ 26) |

## 6. Aho-Corasick - –ú–Ω–æ–≥–æ—à–∞–±–ª–æ–Ω–Ω–æ —Ç—ä—Ä—Å–µ–Ω–µ

–ê–ª–≥–æ—Ä–∏—Ç—ä–º—ä—Ç –Ω–∞ Aho-Corasick —Ä–∞–∑—à–∏—Ä—è–≤–∞ KMP –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —à–∞–±–ª–æ–Ω–∏ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ. –ò–∑–ø–æ–ª–∑–≤–∞ Trie —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å failure links.

```cpp
struct AhoCorasick {
    static const int K = 26; // –†–∞–∑–º–µ—Ä –Ω–∞ –∞–∑–±—É–∫–∞—Ç–∞
    
    struct Vertex {
        int next[K];
        bool leaf = false;
        int p = -1; // —Ä–æ–¥–∏—Ç–µ–ª
        char pch; // —Å–∏–º–≤–æ–ª –∫—ä–º —Ä–æ–¥–∏—Ç–µ–ª—è
        int link = -1; // failure link
        int go[K]; // precomputed transitions
        
        Vertex(int p = -1, char ch = '$') : p(p), pch(ch) {
            fill(begin(next), end(next), -1);
            fill(begin(go), end(go), -1);
        }
    };
    
    vector<Vertex> trie;
    
    AhoCorasick() {
        trie.emplace_back();
    }
    
    void add_string(string const& s) {
        int v = 0;
        for (char ch : s) {
            int c = ch - 'a';
            if (trie[v].next[c] == -1) {
                trie[v].next[c] = trie.size();
                trie.emplace_back(v, ch);
            }
            v = trie[v].next[c];
        }
        trie[v].leaf = true;
    }
    
    int get_link(int v) {
        if (trie[v].link == -1) {
            if (v == 0 || trie[v].p == 0)
                trie[v].link = 0;
            else
                trie[v].link = go(get_link(trie[v].p), trie[v].pch);
        }
        return trie[v].link;
    }
    
    int go(int v, char ch) {
        int c = ch - 'a';
        if (trie[v].go[c] == -1) {
            if (trie[v].next[c] != -1)
                trie[v].go[c] = trie[v].next[c];
            else
                trie[v].go[c] = v == 0 ? 0 : go(get_link(v), ch);
        }
        return trie[v].go[c];
    }
    
    int search(string text) {
        int v = 0;
        int count = 0;
        for (char ch : text) {
            v = go(v, ch);
            int temp = v;
            while (temp != 0) {
                if (trie[temp].leaf) count++;
                temp = get_link(temp);
            }
        }
        return count;
    }
};
```

## 7. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –∑–∞–¥–∞—á–∏

1.  **CSES String Matching**: –ë–∞–∑–æ–≤–∞ –∑–∞–¥–∞—á–∞ –∑–∞ KMP/Z-–∞–ª–≥–æ—Ä–∏—Ç—ä–º.
2.  **Codeforces 1200E**: Compress Words (Hashing/KMP).
3.  **SPOJ NHAY**: –¢—ä—Ä—Å–µ–Ω–µ –Ω–∞ –∏–≥–ª–∞ –≤ –∫—É–ø–∞ —Å–µ–Ω–æ.
4.  **CSES Finding Patterns**: Aho-Corasick –∏–ª–∏ —Å—É—Ñ–∏–∫—Å–Ω–∏ –º–∞—Å–∏–≤–∏.
5.  **CSES Palindrome Queries**: –ú–∞–Ω–∞–∫—ä—Ä —Å –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏.
6.  **Codeforces 126B**: Password (KMP –∑–∞ –ø—Ä–µ—Ñ–∏–∫—Å-—Å—É—Ñ–∏–∫—Å).

## 8. –î–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ —Ç–µ—Ö–Ω–∏–∫–∏

### –°—É—Ñ–∏–∫—Å–µ–Ω –º–∞—Å–∏–≤ (Suffix Array)
–°–æ—Ä—Ç–∏—Ä–∞–Ω –º–∞—Å–∏–≤ –æ—Ç –≤—Å–∏—á–∫–∏ —Å—É—Ñ–∏–∫—Å–∏ –Ω–∞ –Ω–∏–∑–∞. –ü–æ—Å—Ç—Ä–æ—è–≤–∞ —Å–µ –∑–∞ $O(N \log N)$ —Å radix sort –∏–ª–∏ $O(N \log^2 N)$ —Å binary lifting.

### –°—É—Ñ–∏–∫—Å–Ω–æ –¥—ä—Ä–≤–æ (Suffix Tree)
Compressed trie –æ—Ç –≤—Å–∏—á–∫–∏ —Å—É—Ñ–∏–∫—Å–∏. –ú–æ–∂–µ –¥–∞ —Å–µ –ø–æ—Å—Ç—Ä–æ–∏ –∑–∞ –ª–∏–Ω–µ–π–Ω–æ –≤—Ä–µ–º–µ —Å Ukkonen's algorithm, –Ω–æ –µ —Å–ª–æ–∂–µ–Ω –∑–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è.

### Longest Common Prefix (LCP)
LCP –º–∞—Å–∏–≤—ä—Ç —Å—ä–¥—ä—Ä–∂–∞ –¥—ä–ª–∂–∏–Ω–∏—Ç–µ –Ω–∞ –Ω–∞–π-–¥—ä–ª–≥–∏—Ç–µ –æ–±—â–∏ –ø—Ä–µ—Ñ–∏–∫—Å–∏ –º–µ–∂–¥—É —Å—ä—Å–µ–¥–Ω–∏ —Å—É—Ñ–∏–∫—Å–∏ –≤ —Å—É—Ñ–∏–∫—Å–Ω–∏—è –º–∞—Å–∏–≤. –ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∑–∞ –º–Ω–æ–≥–æ –∑–∞–¥–∞—á–∏ –≤—ä—Ä—Ö—É –ø–æ–¥–Ω–∏–∑–æ–≤–µ.

---

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ê–ª–≥–æ—Ä–∏—Ç–º–∏—Ç–µ –≤—ä—Ä—Ö—É –Ω–∏–∑–æ–≤–µ —Å–∞ –æ—Å–Ω–æ–≤–µ–Ω –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –≤ —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ. –ó–∞–ø–æ—á–Ω–µ—Ç–µ —Å —Ö–µ—à–∏—Ä–∞–Ω–µ –∑–∞ –±—ä—Ä–∑–∏ –ø—Ä–æ—Ç–æ—Ç–∏–ø–∏, –Ω–∞—É—á–µ—Ç–µ KMP –∑–∞ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Å—Ç–∏—á–Ω–∏ —Ä–µ—à–µ–Ω–∏—è, –∏ –æ–≤–ª–∞–¥–µ–π—Ç–µ Aho-Corasick –∑–∞ –º–Ω–æ–≥–æ—à–∞–±–ª–æ–Ω–Ω–æ —Ç—ä—Ä—Å–µ–Ω–µ. –í—Å–µ–∫–∏ –æ—Ç —Ç–µ–∑–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∏ –∏–º–∞ —Å–≤–æ–µ—Ç–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏ —Å–∏–ª–Ω–∏ —Å—Ç—Ä–∞–Ω–∏.