# üå≥ –°—Ç—Ä—É–∫—Ç—É—Ä–∏ –æ—Ç —Ç–∏–ø –î—ä—Ä–≤–æ (Tree Structures)

–î—ä—Ä–≤–æ—Ç–æ –µ —Å–≤—ä—Ä–∑–∞–Ω –∞—Ü–∏–∫–ª–µ–Ω –≥—Ä–∞—Ñ (–≥—Ä–∞—Ñ –±–µ–∑ —Ü–∏–∫–ª–∏). –¢–æ –µ –µ–¥–Ω–∞ –æ—Ç –Ω–∞–π-–≤–∞–∂–Ω–∏—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –≤ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞—Ç–∞ –∑–∞—Ä–∞–¥–∏ —Å–≤–æ—è—Ç–∞ –π–µ—Ä–∞—Ä—Ö–∏—á–Ω–∞ –ø—Ä–∏—Ä–æ–¥–∞ –∏ —Å–ø–µ—Ü–∏–∞–ª–Ω–∏—Ç–µ —Å–∏ —Å–≤–æ–π—Å—Ç–≤–∞. –î—ä—Ä–≤–µ—Ç–∞ —Å–µ –ø–æ—è–≤—è–≤–∞—Ç –Ω–∞–≤—Å—è–∫—ä–¥–µ - –æ—Ç —Ñ–∞–π–ª–æ–≤–∏ —Å–∏—Å—Ç–µ–º–∏ –∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–æ–Ω–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –¥–æ —Å–ª–æ–∂–Ω–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∏—á–Ω–∏ –∑–∞–¥–∞—á–∏.

**–û—Å–Ω–æ–≤–Ω–∏ —Å–≤–æ–π—Å—Ç–≤–∞ –Ω–∞ –¥—ä—Ä–≤–æ—Ç–æ:**
- –î—ä—Ä–≤–æ —Å $n$ –≤—ä—Ä—Ö–∞ –∏–º–∞ —Ç–æ—á–Ω–æ $n-1$ —Ä–µ–±—Ä–∞
- –ú–µ–∂–¥—É –≤—Å–µ–∫–∏ –¥–≤–∞ –≤—ä—Ä—Ö–∞ –∏–º–∞ —Ç–æ—á–Ω–æ –µ–¥–∏–Ω –ø—Ä–æ—Å—Ç –ø—ä—Ç
- –ü—Ä–µ–º–∞—Ö–≤–∞–Ω–µ—Ç–æ –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–ª–Ω–æ —Ä–µ–±—Ä–æ —Ä–∞–∑–¥–µ–ª—è –¥—ä—Ä–≤–æ—Ç–æ –Ω–∞ –¥–≤–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏
- –î–æ–±–∞–≤—è–Ω–µ—Ç–æ –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–ª–Ω–æ —Ä–µ–±—Ä–æ —Å—ä–∑–¥–∞–≤–∞ —Ç–æ—á–Ω–æ –µ–¥–∏–Ω —Ü–∏–∫—ä–ª

---

## 1. –û—Å–Ω–æ–≤–Ω–∏ –ø–æ–Ω—è—Ç–∏—è

*   **–ö–æ—Ä–µ–Ω (Root)**: –°–ø–µ—Ü–∏–∞–ª–µ–Ω –≤—Ä—ä—Ö, –æ—Ç –∫–æ–π—Ç–æ –∑–∞–ø–æ—á–≤–∞ –π–µ—Ä–∞—Ä—Ö–∏—è—Ç–∞. –ü—Ä–∏ –Ω–µ–∫–æ—Ä–µ–Ω–∏—Ä–∞–Ω–∏ –¥—ä—Ä–≤–µ—Ç–∞ –º–æ–∂–µ–º –¥–∞ –∏–∑–±–µ—Ä–µ–º –ø—Ä–æ–∏–∑–≤–æ–ª–µ–Ω –≤—Ä—ä—Ö –∑–∞ –∫–æ—Ä–µ–Ω.
*   **–†–æ–¥–∏—Ç–µ–ª (Parent)**: –î–∏—Ä–µ–∫—Ç–Ω–∏—è—Ç –ø—Ä–µ–¥—à–µ—Å—Ç–≤–µ–Ω–∏–∫ –Ω–∞ –¥–∞–¥–µ–Ω –≤—Ä—ä—Ö –≤ –π–µ—Ä–∞—Ä—Ö–∏—è—Ç–∞.
*   **–î–µ—Ç–µ (Child)**: –î–∏—Ä–µ–∫—Ç–µ–Ω –Ω–∞—Å–ª–µ–¥–Ω–∏–∫ –Ω–∞ –¥–∞–¥–µ–Ω –≤—Ä—ä—Ö.
*   **–õ–∏—Å—Ç–æ (Leaf)**: –í—Ä—ä—Ö –±–µ–∑ –¥–µ—Ü–∞. –í –Ω–µ–∫–æ—Ä–µ–Ω–∏—Ä–∞–Ω–æ –¥—ä—Ä–≤–æ —Ç–æ–≤–∞ –µ –≤—Ä—ä—Ö —Å—ä—Å —Å—Ç–µ–ø–µ–Ω 1.
*   **–ü–æ–¥–¥—ä—Ä–≤–æ (Subtree)**: –î—ä—Ä–≤–æ, –æ–±—Ä–∞–∑—É–≤–∞–Ω–æ –æ—Ç –¥–∞–¥–µ–Ω –≤—Ä—ä—Ö –∏ –≤—Å–∏—á–∫–∏—Ç–µ –º—É –Ω–∞—Å–ª–µ–¥–Ω–∏—Ü–∏.
*   **–î—ä–ª–±–æ—á–∏–Ω–∞ (Depth)**: –†–∞–∑—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –æ—Ç –∫–æ—Ä–µ–Ω–∞ –¥–æ –¥–∞–¥–µ–Ω –≤—Ä—ä—Ö.
*   **–í–∏—Å–æ—á–∏–Ω–∞ (Height)**: –ú–∞–∫—Å–∏–º–∞–ª–Ω–æ—Ç–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –∫–æ—Ä–µ–Ω–∞ –¥–æ –ª–∏—Å—Ç–æ. Alternatively, –≤–∏—Å–æ—á–∏–Ω–∞—Ç–∞ –Ω–∞ –≤—Ä—ä—Ö –µ –º–∞–∫—Å–∏–º–∞–ª–Ω–æ—Ç–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –¥–æ –ª–∏—Å—Ç–æ –≤ –Ω–µ–≥–æ–≤–æ—Ç–æ –ø–æ–¥–¥—ä—Ä–≤–æ.
*   **–ù–∏–≤–æ (Level)**: –ú–Ω–æ–∂–µ—Å—Ç–≤–æ—Ç–æ –æ—Ç –≤—Å–∏—á–∫–∏ –≤—ä—Ä—Ö–æ–≤–µ —Å –µ–¥–Ω–∞–∫–≤–∞ –¥—ä–ª–±–æ—á–∏–Ω–∞.
*   **–î–≤–æ–∏—á–Ω–æ –¥—ä—Ä–≤–æ (Binary Tree)**: –í—Å–µ–∫–∏ –≤—Ä—ä—Ö –∏–º–∞ –Ω–∞–π-–º–Ω–æ–≥–æ 2 –¥–µ—Ü–∞ (–ª—è–≤–æ –∏ –¥—è—Å–Ω–æ).
*   **–ü—ä–ª–Ω–æ –¥–≤–æ–∏—á–Ω–æ –¥—ä—Ä–≤–æ**: –í—Å–∏—á–∫–∏ –Ω–∏–≤–∞ —Å–∞ –Ω–∞–ø—ä–ª–Ω–æ –∑–∞–ø—ä–ª–Ω–µ–Ω–∏, –æ—Å–≤–µ–Ω –µ–≤–µ–Ω—Ç—É–∞–ª–Ω–æ –ø–æ—Å–ª–µ–¥–Ω–æ—Ç–æ.

### 1.1. –ë–∞–∑–æ–≤–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –≤ –ø–∞–º–µ—Ç—Ç–∞

```cpp
// –ü—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ —á—Ä–µ–∑ —Å–ø–∏—Å—ä—Ü–∏ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ
vector<int> adj[MAXN];

// –ü—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ —Å —Ä–æ–¥–∏—Ç–µ–ª –∏ –¥–µ—Ü–∞ (–∫–æ—Ä–µ–Ω–∏—Ä–∞–Ω–æ –¥—ä—Ä–≤–æ)
int parent[MAXN];
vector<int> children[MAXN];

// –î–≤–æ–∏—á–Ω–æ –¥—ä—Ä–≤–æ —Å —É–∫–∞–∑–∞—Ç–µ–ª–∏
struct Node {
    int value;
    Node *left, *right;
    Node(int val) : value(val), left(nullptr), right(nullptr) {}
};
```

## 2. –û–±—Ö–æ–∂–¥–∞–Ω–µ –Ω–∞ –¥—ä—Ä–≤–µ—Ç–∞

–û–±—Ö–æ–∂–¥–∞–Ω–µ—Ç–æ –Ω–∞ –¥—ä—Ä–≤–µ—Ç–∞ –µ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è. –ò–º–∞ –Ω—è–∫–æ–ª–∫–æ –∫–ª–∞—Å–∏—á–µ—Å–∫–∏ –Ω–∞—á–∏–Ω–∞:

### 2.1. –û–±—Ö–æ–∂–¥–∞–Ω–µ –≤ –¥—ä–ª–±–æ—á–∏–Ω–∞ (DFS-based)

1.  **Pre-order** (–ö–æ—Ä–µ–Ω ‚Üí –õ—è–≤–æ ‚Üí –î—è—Å–Ω–æ): –ü–æ—Å–µ—â–∞–≤–∞–º–µ –∫–æ—Ä–µ–Ω–∞ –ø—Ä–µ–¥–∏ –¥–µ—Ü–∞—Ç–∞ –º—É.
    - –ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∑–∞: –∫–æ–ø–∏—Ä–∞–Ω–µ –Ω–∞ –¥—ä—Ä–≤–æ—Ç–æ, —Å—ä–∑–¥–∞–≤–∞–Ω–µ –Ω–∞ –ø—Ä–µ—Ñ–∏–∫—Å–Ω–∞ –Ω–æ—Ç–∞—Ü–∏—è
    
```cpp
void preorder(Node* node) {
    if (!node) return;
    process(node->value);      // –û–±—Ä–∞–±–æ—Ç–≤–∞–º–µ –∫–æ—Ä–µ–Ω–∞
    preorder(node->left);      // –û–±—Ö–æ–∂–¥–∞–º–µ –ª—è–≤–æ—Ç–æ –ø–æ–¥–¥—ä—Ä–≤–æ
    preorder(node->right);     // –û–±—Ö–æ–∂–¥–∞–º–µ –¥—è—Å–Ω–æ—Ç–æ –ø–æ–¥–¥—ä—Ä–≤–æ
}
```

2.  **In-order** (–õ—è–≤–æ ‚Üí –ö–æ—Ä–µ–Ω ‚Üí –î—è—Å–Ω–æ): –ü–æ—Å–µ—â–∞–≤–∞–º–µ –∫–æ—Ä–µ–Ω–∞ –º–µ–∂–¥—É –¥–≤–µ—Ç–µ –ø–æ–¥–¥—ä—Ä–≤–µ—Ç–∞.
    - –ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∑–∞: BST –æ–±—Ö–æ–∂–¥–∞–Ω–µ –¥–∞–≤–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–∞ —Ä–µ–¥–∏—Ü–∞
    
```cpp
void inorder(Node* node) {
    if (!node) return;
    inorder(node->left);       // –û–±—Ö–æ–∂–¥–∞–º–µ –ª—è–≤–æ—Ç–æ –ø–æ–¥–¥—ä—Ä–≤–æ
    process(node->value);      // –û–±—Ä–∞–±–æ—Ç–≤–∞–º–µ –∫–æ—Ä–µ–Ω–∞
    inorder(node->right);      // –û–±—Ö–æ–∂–¥–∞–º–µ –¥—è—Å–Ω–æ—Ç–æ –ø–æ–¥–¥—ä—Ä–≤–æ
}
```

3.  **Post-order** (–õ—è–≤–æ ‚Üí –î—è—Å–Ω–æ ‚Üí –ö–æ—Ä–µ–Ω): –ü–æ—Å–µ—â–∞–≤–∞–º–µ –∫–æ—Ä–µ–Ω–∞ —Å–ª–µ–¥ –¥–µ—Ü–∞—Ç–∞ –º—É.
    - –ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∑–∞: –∏–∑—Ç—Ä–∏–≤–∞–Ω–µ –Ω–∞ –¥—ä—Ä–≤–æ—Ç–æ, –∏–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ –ø–æ—Å—Ç—Ñ–∏–∫—Å–Ω–∏ –∏–∑—Ä–∞–∑–∏, DP –Ω–∞ –¥—ä—Ä–≤–µ—Ç–∞
    
```cpp
void postorder(Node* node) {
    if (!node) return;
    postorder(node->left);     // –û–±—Ö–æ–∂–¥–∞–º–µ –ª—è–≤–æ—Ç–æ –ø–æ–¥–¥—ä—Ä–≤–æ
    postorder(node->right);    // –û–±—Ö–æ–∂–¥–∞–º–µ –¥—è—Å–Ω–æ—Ç–æ –ø–æ–¥–¥—ä—Ä–≤–æ
    process(node->value);      // –û–±—Ä–∞–±–æ—Ç–≤–∞–º–µ –∫–æ—Ä–µ–Ω–∞
}
```

### 2.2. –û–±—Ö–æ–∂–¥–∞–Ω–µ –≤ —à–∏—Ä–∏–Ω–∞ (BFS - Level Order)

–û–±—Ö–æ–∂–¥–∞–º–µ –¥—ä—Ä–≤–æ—Ç–æ –Ω–∏–≤–æ –ø–æ –Ω–∏–≤–æ, –æ—Ç–ª—è–≤–æ –Ω–∞–¥—è—Å–Ω–æ:

```cpp
void levelOrder(Node* root) {
    if (!root) return;
    queue<Node*> q;
    q.push(root);
    
    while (!q.empty()) {
        Node* current = q.front();
        q.pop();
        process(current->value);
        
        if (current->left) q.push(current->left);
        if (current->right) q.push(current->right);
    }
}
```

### 2.3. –û–±—Ö–æ–∂–¥–∞–Ω–µ –Ω–∞ –æ–±—â–æ –¥—ä—Ä–≤–æ (–Ω–µ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –¥–≤–æ–∏—á–Ω–æ)

```cpp
void dfs(int u, int parent = -1) {
    // Pre-order –æ–±—Ä–∞–±–æ—Ç–∫–∞
    process(u);
    
    for (int v : adj[u]) {
        if (v != parent) {
            dfs(v, u);
        }
    }
    
    // Post-order –æ–±—Ä–∞–±–æ—Ç–∫–∞
    postprocess(u);
}
```

## 3. –ù–∞–π-–±–ª–∏–∑—ä–∫ –æ–±—â –ø—Ä–∞—Ä–æ–¥–∏—Ç–µ–ª (LCA)

LCA (Lowest Common Ancestor) –Ω–∞ –≤—ä—Ä—Ö–æ–≤–µ—Ç–µ $u$ –∏ $v$ –µ –Ω–∞–π-–¥—ä–ª–±–æ–∫–∏—è—Ç –≤—Ä—ä—Ö, –∫–æ–π—Ç–æ –µ –ø—Ä–∞—Ä–æ–¥–∏—Ç–µ–ª –∏ –Ω–∞ –¥–≤–∞—Ç–∞. –¢–æ–≤–∞ –µ –µ–¥–Ω–∞ –æ—Ç –Ω–∞–π-–≤–∞–∂–Ω–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤—ä—Ä—Ö—É –¥—ä—Ä–≤–µ—Ç–∞.

**–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–∞ LCA:**
- –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –¥–≤–∞ –≤—ä—Ä—Ö–∞: $dist(u, v) = depth[u] + depth[v] - 2 \times depth[LCA(u, v)]$
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –µ–¥–∏–Ω –≤—Ä—ä—Ö –µ –≤ –ø—ä—Ç—è –º–µ–∂–¥—É –¥—Ä—É–≥–∏ –¥–≤–∞
- Range queries –≤—ä—Ä—Ö—É –ø—ä—Ç–∏—â–∞ –≤ –¥—ä—Ä–≤–æ—Ç–æ

### 3.1. –ù–∞–∏–≤–µ–Ω –ø–æ–¥—Ö–æ–¥

–í–¥–∏–≥–∞–º–µ –¥–≤–∞—Ç–∞ –≤—ä—Ä—Ö–∞ –Ω–∞–≥–æ—Ä–µ –¥–æ–∫–∞—Ç–æ –Ω–µ —Å–µ —Å—Ä–µ—â–Ω–∞—Ç. –°–ª–æ–∂–Ω–æ—Å—Ç: $O(h)$ –∫—ä–¥–µ—Ç–æ $h$ –µ –≤–∏—Å–æ—á–∏–Ω–∞—Ç–∞.

```cpp
int lca_naive(int u, int v) {
    // –ü—ä—Ä–≤–æ –≥–∏ –ø—Ä–∞–≤–∏–º –Ω–∞ –µ–¥–Ω–∞–∫–≤–∞ –¥—ä–ª–±–æ—á–∏–Ω–∞
    while (depth[u] > depth[v]) u = parent[u];
    while (depth[v] > depth[u]) v = parent[v];
    
    // –ü–æ—Å–ª–µ –≥–∏ –≤–¥–∏–≥–∞–º–µ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
    while (u != v) {
        u = parent[u];
        v = parent[v];
    }
    return u;
}
```

### 3.2. –î–≤–æ–∏—á–Ω–æ –ø–æ–≤–¥–∏–≥–∞–Ω–µ (Binary Lifting)

–ü–æ–∑–≤–æ–ª—è–≤–∞ –Ω–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ LCA –∑–∞ $O(\log N)$ —Å–ª–µ–¥ $O(N \log N)$ –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å–∏–Ω–≥. –¢–æ–≤–∞ –µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏—è—Ç –∏ –Ω–∞–π-–ø–æ–ø—É–ª—è—Ä–µ–Ω –º–µ—Ç–æ–¥.

**–ò–¥–µ—è:** –ü–∞–∑–∏–º –∑–∞ –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö –Ω–µ–≥–æ–≤–∏—è $2^i$-—Ç–∏ –ø—Ä–∞—Ä–æ–¥–∏—Ç–µ–ª –∑–∞ $i = 0, 1, 2, \ldots, \log N$.

```cpp
const int MAXN = 100005;
const int LOGN = 20;  // log2(100000) ‚âà 17

int up[MAXN][LOGN];    // up[u][i] = 2^i-—Ç–∏—è—Ç –ø—Ä–∞—Ä–æ–¥–∏—Ç–µ–ª –Ω–∞ u
int depth[MAXN];
vector<int> adj[MAXN];

void dfs(int u, int p = 0) {
    up[u][0] = p;  // –î–∏—Ä–µ–∫—Ç–Ω–∏—è—Ç —Ä–æ–¥–∏—Ç–µ–ª
    
    // –ò–∑—á–∏—Å–ª—è–≤–∞–º–µ 2^i-—Ç–∏—Ç–µ –ø—Ä–∞—Ä–æ–¥–∏—Ç–µ–ª–∏
    for (int i = 1; i < LOGN; i++) {
        up[u][i] = up[up[u][i-1]][i-1];
    }
    
    for (int v : adj[u]) {
        if (v != p) {
            depth[v] = depth[u] + 1;
            dfs(v, u);
        }
    }
}

// –í—Ä—ä—â–∞ k-—Ç–∏—è –ø—Ä–∞—Ä–æ–¥–∏—Ç–µ–ª –Ω–∞ u
int kth_ancestor(int u, int k) {
    for (int i = 0; i < LOGN; i++) {
        if (k & (1 << i)) {
            u = up[u][i];
        }
    }
    return u;
}

bool is_ancestor(int u, int v) {
    // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ u –µ –ø—Ä–∞—Ä–æ–¥–∏—Ç–µ–ª –Ω–∞ v
    return kth_ancestor(v, depth[v] - depth[u]) == u;
}

int lca(int u, int v) {
    // –£–≤–µ—Ä—è–≤–∞–º–µ —Å–µ —á–µ u –µ –ø–æ-–¥—ä–ª–±–æ–∫–∏—è—Ç
    if (depth[u] < depth[v]) swap(u, v);
    
    // –í–¥–∏–≥–∞–º–µ u –¥–æ –Ω–∏–≤–æ—Ç–æ –Ω–∞ v
    u = kth_ancestor(u, depth[u] - depth[v]);
    
    if (u == v) return u;
    
    // –î–≤–æ–∏—á–Ω–æ —Ç—ä—Ä—Å–µ–Ω–µ –Ω–∞ LCA
    for (int i = LOGN - 1; i >= 0; i--) {
        if (up[u][i] != up[v][i]) {
            u = up[u][i];
            v = up[v][i];
        }
    }
    
    return up[u][0];  // –†–æ–¥–∏—Ç–µ–ª—è—Ç –Ω–∞ —Ç–µ–∫—É—â–∞—Ç–∞ –ø–æ–∑–∏—Ü–∏—è
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
void init(int root, int n) {
    depth[root] = 0;
    dfs(root);
}
```

### 3.3. –î—Ä—É–≥–∏ –ø–æ–¥—Ö–æ–¥–∏ –∑–∞ LCA

**Eulerian Tour + RMQ:** –°–ª–æ–∂–Ω–æ—Å—Ç $O(N)$ preprocessing, $O(1)$ per query —Å Sparse Table.

**Tarjan's Offline LCA:** –ü–æ–ª–µ–∑–µ–Ω –∫–æ–≥–∞—Ç–æ –≤—Å–∏—á–∫–∏ –∑–∞—è–≤–∫–∏ —Å–∞ –∏–∑–≤–µ—Å—Ç–Ω–∏ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–æ.

## 4. –î–∏–∞–º–µ—Ç—ä—Ä –Ω–∞ –¥—ä—Ä–≤–æ

–î–∏–∞–º–µ—Ç—ä—Ä—ä—Ç –µ –Ω–∞–π-–¥—ä–ª–≥–∏—è—Ç –ø—ä—Ç –º–µ–∂–¥—É –¥–≤–∞ –≤—ä—Ä—Ö–∞ –≤ –¥—ä—Ä–≤–æ—Ç–æ. –¢–æ–≤–∞ –µ –≤–∞–∂–Ω–∞ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞ –Ω–∞ –¥—ä—Ä–≤–æ—Ç–æ —Å –º–Ω–æ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.

### 4.1. –ê–ª–≥–æ—Ä–∏—Ç—ä–º —Å –¥–≤–µ DFS

–ù–∞–π-–µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏—è—Ç –Ω–∞—á–∏–Ω –∑–∞ –Ω–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –¥–∏–∞–º–µ—Ç—ä—Ä:

```cpp
int farthest_node;
int max_dist;

void dfs(int u, int parent, int dist) {
    if (dist > max_dist) {
        max_dist = dist;
        farthest_node = u;
    }
    
    for (int v : adj[u]) {
        if (v != parent) {
            dfs(v, u, dist + 1);
        }
    }
}

int findDiameter(int n) {
    // –°—Ç—ä–ø–∫–∞ 1: –ù–∞–º–∏—Ä–∞–º–µ –Ω–∞–π-–¥–∞–ª–µ—á–µ–Ω –≤—Ä—ä—Ö –æ—Ç –ø—Ä–æ–∏–∑–≤–æ–ª–µ–Ω –≤—Ä—ä—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä 1)
    max_dist = 0;
    dfs(1, -1, 0);
    
    int endpoint1 = farthest_node;
    
    // –°—Ç—ä–ø–∫–∞ 2: –ù–∞–º–∏—Ä–∞–º–µ –Ω–∞–π-–¥–∞–ª–µ—á–µ–Ω –≤—Ä—ä—Ö –æ—Ç endpoint1
    max_dist = 0;
    dfs(endpoint1, -1, 0);
    
    // max_dist —Å–µ–≥–∞ —Å—ä–¥—ä—Ä–∂–∞ –¥–∏–∞–º–µ—Ç—ä—Ä–∞
    return max_dist;
}
```

**–û–±—è—Å–Ω–µ–Ω–∏–µ –∑–∞—â–æ —Ä–∞–±–æ—Ç–∏:**
- –°–ª–µ–¥ –ø—ä—Ä–≤–∏—è DFS –Ω–∞–º–∏—Ä–∞–º–µ –µ–¥–∏–Ω –æ—Ç –∫—Ä–∞–∏—â–∞—Ç–∞ –Ω–∞ –¥–∏–∞–º–µ—Ç—ä—Ä–∞
- –í—Ç–æ—Ä–∏ DFS –æ—Ç —Ç–æ–≤–∞ –∫—Ä–∞–π–Ω–∏—á–µ –Ω–∏ –¥–∞–≤–∞ –¥—Ä—É–≥–æ—Ç–æ –∫—Ä–∞–π–Ω–∏—á–µ –∏ –¥—ä–ª–∂–∏–Ω–∞—Ç–∞

### 4.2. –î–∏–∞–º–µ—Ç—ä—Ä —Å DP (–µ–¥–∏–Ω DFS)

–ê–ª—Ç–µ—Ä–Ω–∞—Ç–∏–≤–µ–Ω –ø–æ–¥—Ö–æ–¥ –∏–∑–ø–æ–ª–∑–≤–∞–π–∫–∏ dynamic programming:

```cpp
int diameter = 0;

int dfs_diameter(int u, int parent) {
    int max1 = 0, max2 = 0;  // –î–≤–µ –Ω–∞–π-–¥—ä–ª–≥–∏ –ø—ä—Ç—è –Ω–∞–¥–æ–ª—É
    
    for (int v : adj[u]) {
        if (v != parent) {
            int h = dfs_diameter(v, u);
            
            if (h > max1) {
                max2 = max1;
                max1 = h;
            } else if (h > max2) {
                max2 = h;
            }
        }
    }
    
    // –î–∏–∞–º–µ—Ç—ä—Ä—ä—Ç –ø—Ä–µ–∑ u –µ max1 + max2
    diameter = max(diameter, max1 + max2);
    
    // –í—Ä—ä—â–∞–º–µ –Ω–∞–π-–¥—ä–ª–≥–∏—è –ø—ä—Ç –Ω–∞–¥–æ–ª—É –æ—Ç u
    return max1 + 1;
}
```

### 4.3. –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ —Ü–µ–Ω—Ç—ä—Ä–∞ –Ω–∞ –¥—ä—Ä–≤–æ—Ç–æ

–¶–µ–Ω—Ç—ä—Ä—ä—Ç –µ –≤—ä—Ä—Ö—ä—Ç/–≤—ä—Ä—Ö–æ–≤–µ—Ç–µ, –∫–æ–∏—Ç–æ –º–∏–Ω–∏–º–∏–∑–∏—Ä–∞—Ç –º–∞–∫—Å–∏–º–∞–ª–Ω–æ—Ç–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –¥–æ –≤—Å–∏—á–∫–∏ –¥—Ä—É–≥–∏ –≤—ä—Ä—Ö–æ–≤–µ. –¶–µ–Ω—Ç—ä—Ä—ä—Ç –≤–∏–Ω–∞–≥–∏ –ª–µ–∂–∏ –Ω–∞ –¥–∏–∞–º–µ—Ç—ä—Ä–∞.

```cpp
vector<int> findCenter(int n) {
    // –ù–∞–º–∏—Ä–∞–º–µ –¥–∏–∞–º–µ—Ç—ä—Ä–∞ –∏ –¥–≤–∞—Ç–∞ –º—É –∫—Ä–∞—è
    // ... (–∫–æ–¥ –æ—Ç –ø–æ-–≥–æ—Ä–µ)
    
    int mid = max_dist / 2;
    // –í—ä—Ä–≤–∏–º mid —Å—Ç—ä–ø–∫–∏ –æ—Ç –µ–¥–Ω–æ—Ç–æ –∫—Ä–∞–π–Ω–∏—á–µ
    // –¢–æ–≤–∞ –µ/—Å–∞ —Ü–µ–Ω—Ç—ä—Ä—ä—Ç/—Ü–µ–Ω—Ç—Ä–æ–≤–µ—Ç–µ
}
```

## 5. –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–∏ –¥—ä—Ä–≤–µ—Ç–∞ –∏ —Ç–µ—Ö–Ω–∏–∫–∏

### 5.1. –î–≤–æ–∏—á–Ω–æ –¥—ä—Ä–≤–æ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ (BST)

BST –ø–æ–¥–¥—ä—Ä–∂–∞ –µ–ª–µ–º–µ–Ω—Ç–∏—Ç–µ –≤ —Å–æ—Ä—Ç–∏—Ä–∞–Ω —Ä–µ–¥. –ó–∞ –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö:
- –í—Å–∏—á–∫–∏ –µ–ª–µ–º–µ–Ω—Ç–∏ –≤ –ª—è–≤–æ—Ç–æ –ø–æ–¥–¥—ä—Ä–≤–æ —Å–∞ –ø–æ-–º–∞–ª–∫–∏
- –í—Å–∏—á–∫–∏ –µ–ª–µ–º–µ–Ω—Ç–∏ –≤ –¥—è—Å–Ω–æ—Ç–æ –ø–æ–¥–¥—ä—Ä–≤–æ —Å–∞ –ø–æ-–≥–æ–ª–µ–º–∏

```cpp
struct BST {
    int value;
    BST *left, *right;
    
    BST(int val) : value(val), left(nullptr), right(nullptr) {}
};

BST* insert(BST* root, int val) {
    if (!root) return new BST(val);
    
    if (val < root->value) {
        root->left = insert(root->left, val);
    } else {
        root->right = insert(root->right, val);
    }
    return root;
}

bool search(BST* root, int val) {
    if (!root) return false;
    if (root->value == val) return true;
    
    if (val < root->value) return search(root->left, val);
    return search(root->right, val);
}
```

**–ó–∞–±–µ–ª–µ–∂–∫–∞:** –û–±–∏–∫–Ω–æ–≤–µ–Ω–æ BST –º–æ–∂–µ –¥–∞ —Å–µ –¥–µ–±–∞–ª–∞–Ω—Å–∏—Ä–∞. –ó–∞ –±–∞–ª–∞–Ω—Å–∏—Ä–∞–Ω–∏ BST –≤–∏–∂—Ç–µ AVL –¥—ä—Ä–≤–µ—Ç–∞, Red-Black –¥—ä—Ä–≤–µ—Ç–∞ –∏–ª–∏ –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ `set` –≤ C++.

### 5.2. Trie (Prefix Tree)

–ï—Ñ–µ–∫—Ç–∏–≤–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–∞ —Ä–∞–±–æ—Ç–∞ —Å –Ω–∏–∑–æ–≤–µ:

```cpp
struct TrieNode {
    map<char, TrieNode*> children;
    bool isEnd = false;
};

class Trie {
    TrieNode* root;
public:
    Trie() { root = new TrieNode(); }
    
    void insert(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            if (!curr->children[c]) {
                curr->children[c] = new TrieNode();
            }
            curr = curr->children[c];
        }
        curr->isEnd = true;
    }
    
    bool search(string word) {
        TrieNode* curr = root;
        for (char c : word) {
            if (!curr->children[c]) return false;
            curr = curr->children[c];
        }
        return curr->isEnd;
    }
};
```

### 5.3. Segment Tree –∏ Fenwick Tree

–¢–µ–∑–∏ –¥—ä—Ä–≤–µ—Ç–∞ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –∑–∞ range queries –∏ updates. –î–µ—Ç–∞–π–ª–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –≤ Topic 34.

### 5.4. Heavy-Light Decomposition

–†–∞–∑–¥–µ–ª—è –¥—ä—Ä–≤–æ—Ç–æ –Ω–∞ "—Ç–µ–∂–∫–∏" –∏ "–ª–µ–∫–∏" –ø—ä—Ç–∏—â–∞, –ø–æ–∑–≤–æ–ª—è–≤–∞–π–∫–∏ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏ –∑–∞—è–≤–∫–∏ –≤—ä—Ä—Ö—É –ø—ä—Ç–∏—â–∞. –°–ª–æ–∂–Ω–æ—Å—Ç: $O(\log^2 N)$ per query.

### 5.5. Centroid Decomposition

–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Ä–∞–∑–¥–µ–ª—è–Ω–µ –Ω–∞ –¥—ä—Ä–≤–æ—Ç–æ —á—Ä–µ–∑ —Ü–µ–Ω—Ç—Ä–æ–∏–¥ (–≤—Ä—ä—Ö, —á–∏–µ—Ç–æ –ø—Ä–µ–º–∞—Ö–≤–∞–Ω–µ –ø—Ä–∞–≤–∏ –≤—Å–∏—á–∫–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ —Å —Ä–∞–∑–º–µ—Ä ‚â§ n/2). –ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∑–∞ —Å–ª–æ–∂–Ω–∏ –∑–∞–¥–∞—á–∏ —Å –ø—ä—Ç–∏—â–∞ –≤ –¥—ä—Ä–≤–æ—Ç–æ.

## 6. Dynamic Programming –Ω–∞ –¥—ä—Ä–≤–µ—Ç–∞

DP –Ω–∞ –¥—ä—Ä–≤–µ—Ç–∞ –µ –º–æ—â–Ω–∞ —Ç–µ—Ö–Ω–∏–∫–∞. –û–±–∏–∫–Ω–æ–≤–µ–Ω–æ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ post-order –æ–±—Ö–æ–∂–¥–∞–Ω–µ:

### 6.1. –ü—Ä–∏–º–µ—Ä: –ú–∞–∫—Å–∏–º–∞–ª–Ω–∞ –Ω–µ–∑–∞–≤–∏—Å–∏–º–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ

–ù–∞–º–∏—Ä–∞–º–µ –º–∞–∫—Å–∏–º–∞–ª–µ–Ω –±—Ä–æ–π –≤—ä—Ä—Ö–æ–≤–µ —Ç–∞–∫–∏–≤–∞, —á–µ –Ω–∏–∫–æ–∏ –¥–≤–∞ –Ω–µ —Å–∞ —Å–≤—ä—Ä–∑–∞–Ω–∏ —Å —Ä–µ–±—Ä–æ.

```cpp
int dp[MAXN][2];  // dp[u][0] = –Ω–µ –≤–∫–ª—é—á–≤–∞–º–µ u, dp[u][1] = –≤–∫–ª—é—á–≤–∞–º–µ u

void tree_dp(int u, int parent) {
    dp[u][0] = 0;
    dp[u][1] = 1;  // –°—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ u
    
    for (int v : adj[u]) {
        if (v != parent) {
            tree_dp(v, u);
            
            // –ê–∫–æ –Ω–µ –≤–∑–µ–º–∞–º–µ u, –º–æ–∂–µ–º –¥–∞ –≤–∑–µ–º–µ–º –∏–ª–∏ –Ω–µ v
            dp[u][0] += max(dp[v][0], dp[v][1]);
            
            // –ê–∫–æ –≤–∑–µ–º–∞–º–µ u, –ù–ï –º–æ–∂–µ–º –¥–∞ –≤–∑–µ–º–µ–º v
            dp[u][1] += dp[v][0];
        }
    }
}
```

### 6.2. Rerooting technique

–ü–æ–Ω—è–∫–æ–≥–∞ –∏—Å–∫–∞–º–µ DP —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –∑–∞ –≤—Å–µ–∫–∏ –≤—ä–∑–º–æ–∂–µ–Ω –∫–æ—Ä–µ–Ω. –ò–∑–ø–æ–ª–∑–≤–∞–º–µ rerooting:

```cpp
int down[MAXN];  // DP –Ω–∞–¥–æ–ª—É (–∫—ä–º –ª–∏—Å—Ç–∞—Ç–∞)
int up[MAXN];    // DP –Ω–∞–≥–æ—Ä–µ (–∫—ä–º –∫–æ—Ä–µ–Ω–∞)

// –ü—ä—Ä–≤–æ –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ down[] —Å –æ–±–∏–∫–Ω–æ–≤–µ–Ω DFS
void dfs_down(int u, int parent) {
    down[u] = 0;
    for (int v : adj[u]) {
        if (v != parent) {
            dfs_down(v, u);
            down[u] += down[v] + 1;  // –ü—Ä–∏–º–µ—Ä
        }
    }
}

// –ü–æ—Å–ª–µ –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ up[] —Å rerooting
void dfs_up(int u, int parent) {
    for (int v : adj[u]) {
        if (v != parent) {
            // up[v] —Å–µ –∏–∑—á–∏—Å–ª—è–≤–∞ –æ—Ç up[u] –∏ down –Ω–∞ –¥—Ä—É–≥–∏—Ç–µ –¥–µ—Ü–∞
            up[v] = up[u] + down[u] - down[v] - 1;
            dfs_up(v, u);
        }
    }
}
```

## 7. Euler Tour –∏ –¥—Ä—É–≥–∏ —Ç–µ—Ö–Ω–∏–∫–∏

### 7.1. Euler Tour –Ω–∞ –¥—ä—Ä–≤–æ—Ç–æ

–ü—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞–º–µ –¥—ä—Ä–≤–æ—Ç–æ –≤ –º–∞—Å–∏–≤, –ø–æ–∑–≤–æ–ª—è–≤–∞–π–∫–∏ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ –Ω–∞ range structures:

```cpp
int timer = 0;
int tin[MAXN], tout[MAXN];
int euler[2 * MAXN];  // Euler tour

void euler_tour(int u, int parent) {
    tin[u] = timer;
    euler[timer++] = u;
    
    for (int v : adj[u]) {
        if (v != parent) {
            euler_tour(v, u);
        }
    }
    
    tout[u] = timer;
    euler[timer++] = u;
}
```

–°–µ–≥–∞ –ø–æ–¥–¥—ä—Ä–≤–æ—Ç–æ –Ω–∞ $u$ —Å—ä–æ—Ç–≤–µ—Ç—Å—Ç–≤–∞ –Ω–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª $[tin[u], tout[u]]$.

### 7.2. Flattening –Ω–∞ –¥—ä—Ä–≤–æ—Ç–æ

–ü–æ–¥–æ–±–Ω–æ –Ω–∞ Euler tour, –Ω–æ –ø–æ-–ø—Ä–æ—Å—Ç–æ - –≤—Å—è–∫–æ –ø–æ–¥–¥—ä—Ä–≤–æ –µ –Ω–µ–ø—Ä–µ–∫—ä—Å–Ω–∞—Ç –∏–Ω—Ç–µ—Ä–≤–∞–ª:

```cpp
int timer = 0;
int tin[MAXN], tout[MAXN];

void flatten(int u, int parent) {
    tin[u] = timer++;
    for (int v : adj[u]) {
        if (v != parent) flatten(v, u);
    }
    tout[u] = timer - 1;
}
```

## 8. –ó–∞–¥–∞—á–∏ –∑–∞ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ

### –û—Å–Ω–æ–≤–Ω–∏ –∑–∞–¥–∞—á–∏
1.  **CSES Tree Diameter**: –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –¥–∏–∞–º–µ—Ç—ä—Ä–∞ - –æ—Ç–ª–∏—á–Ω–∞ –∑–∞ –Ω–∞—á–∞–ª–æ.
2.  **CSES Subordinates**: –ü—Ä–µ–±—Ä–æ—è–≤–∞–Ω–µ –Ω–∞ –ø–æ–¥–¥—ä—Ä–≤–µ—Ç–∞ - –±–∞–∑–æ–≤ tree DP.
3.  **CSES Tree Distances I**: –†–∞–∑—Å—Ç–æ—è–Ω–∏—è –≤ –¥—ä—Ä–≤–æ - –∫–æ–º–±–∏–Ω–∞—Ü–∏—è –æ—Ç —Ç–µ—Ö–Ω–∏–∫–∏.

### –°—Ä–µ–¥–Ω–∏ –∑–∞–¥–∞—á–∏
4.  **CSES Company Queries II**: –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ LCA —Å binary lifting.
5.  **Codeforces 191C**: Fools and Roads - LCA + —Ä–∞–∑–ª–∏–∫–∏ –≤—ä—Ä—Ö—É –¥—ä—Ä–≤–æ.
6.  **CSES Path Queries**: –ó–∞—è–≤–∫–∏ –≤—ä—Ä—Ö—É –ø—ä—Ç–∏—â–∞ - Euler tour + range —Å—Ç—Ä—É–∫—Ç—É—Ä–∏.
7.  **CSES Tree Distances II**: Rerooting technique.

### –ù–∞–ø—Ä–µ–¥–Ω–∞–ª–∏ –∑–∞–¥–∞—á–∏
8.  **Codeforces 609E**: Minimum Spanning Tree –¥–ª—è Each Edge.
9.  **CSES Distinct Colors**: Heavy-Light Decomposition –∏–ª–∏ –¥—Ä—É–≥–∞ –Ω–∞–ø—Ä–µ–¥–Ω–∞–ª–∞ —Ç–µ—Ö–Ω–∏–∫–∞.
10. **IOI 2011 Race**: Centroid decomposition –∫–ª–∞—Å–∏—á–µ—Å–∫–∞ –∑–∞–¥–∞—á–∞.

## 9. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ —Å—ä–≤–µ—Ç–∏

### 9.1. –ß–µ—Å—Ç–æ —Å—Ä–µ—â–∞–Ω–∏ –≥—Ä–µ—à–∫–∏

1. **–ó–∞–±—Ä–∞–≤—è–Ω–µ –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ —Ä–æ–¥–∏—Ç–µ–ª** –ø—Ä–∏ DFS –≤ –Ω–µ–∫–æ—Ä–µ–Ω–∏—Ä–∞–Ω–æ –¥—ä—Ä–≤–æ
2. **–ì—Ä–µ—à–Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è** –Ω–∞ binary lifting –º–∞—Å–∏–≤–∞
3. **Off-by-one –≥—Ä–µ—à–∫–∏** –ø—Ä–∏ –∏–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ –¥—ä–ª–±–æ—á–∏–Ω–∞/–≤–∏—Å–æ—á–∏–Ω–∞
4. **Stack overflow** –ø—Ä–∏ –º–Ω–æ–≥–æ –¥—ä–ª–±–æ–∫–∏ –¥—ä—Ä–≤–µ—Ç–∞ - –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –∏—Ç–µ—Ä–∞—Ç–∏–≤–µ–Ω DFS –∏–ª–∏ —É–≤–µ–ª–∏—á–µ—Ç–µ stack size

### 9.2. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

- –ü—Ä–∏ binary lifting, –Ω–µ –∑–∞–±—Ä–∞–≤—è–π—Ç–µ —á–µ `up[0][i] = 0` (–∏–ª–∏ sentinel value)
- –ó–∞ Euler tour, —Ä–∞–∑–º–µ—Ä—ä—Ç –Ω–∞ –º–∞—Å–∏–≤–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ –µ `2*n`
- –ü—Ä–∏ rerooting, –≤–Ω–∏–º–∞–≤–∞–π—Ç–µ —Å –æ–±–Ω–æ–≤—è–≤–∞–Ω–µ—Ç–æ –Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏
- –ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ `vector<int>` –≤–º–µ—Å—Ç–æ `vector<vector<int>>` –∑–∞ –ø–æ-–¥–æ–±—Ä–∞ cache locality

### 9.3. Debugging —Å—ä–≤–µ—Ç–∏

- –í–∏–∑—É–∞–ª–∏–∑–∏—Ä–∞–π—Ç–µ –º–∞–ª–∫–∏ –¥—ä—Ä–≤–µ—Ç–∞ (5-7 –≤—ä—Ä—Ö–∞)
- –ü—Ä–æ–≤–µ—Ä–µ—Ç–µ –¥–∞–ª–∏ –∫–æ—Ä–µ–Ω—ä—Ç –µ –ø—Ä–∞–≤–∏–ª–Ω–æ –æ–±—Ä–∞–±–æ—Ç–µ–Ω
- –ü—Ä–∏–Ω—Ç–∏—Ä–∞–π—Ç–µ –º–µ–∂–¥–∏–Ω–Ω–∏—Ç–µ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ –Ω–∞ DP
- –¢–µ—Å—Ç–≤–∞–π—Ç–µ —Å –ª–∏–Ω–µ–π–Ω–æ –¥—ä—Ä–≤–æ (–Ω–∞–π-–ª–æ—à —Å–ª—É—á–∞–π) –∏ –∑–≤–µ–∑–¥–∞ (—Å–ø–µ—Ü–∏–∞–ª–µ–Ω —Å–ª—É—á–∞–π)

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–î—ä—Ä–≤–µ—Ç–∞—Ç–∞ —Å–∞ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –≤ —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –∏ –∫–æ–º–ø—é—Ç—ä—Ä–Ω–∏—Ç–µ –Ω–∞—É–∫–∏. –û—Å–Ω–æ–≤–Ω–∏—Ç–µ —Ç–µ—Ö–Ω–∏–∫–∏, –∫–æ–∏—Ç–æ —Ç—Ä—è–±–≤–∞ –¥–∞ –æ–≤–ª–∞–¥–µ–µ—Ç–µ —Å–∞:

**Must-know —Ç–µ—Ö–Ω–∏–∫–∏:**
- **–û–±—Ö–æ–∂–¥–∞–Ω–∏—è:** DFS (pre/in/post-order) –∏ BFS
- **LCA:** Binary lifting –µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ä—Ç
- **–î–∏–∞–º–µ—Ç—ä—Ä:** –î–≤–æ–π–Ω–æ DFS –∏–ª–∏ DP
- **Tree DP:** Post-order –æ–±—Ö–æ–∂–¥–∞–Ω–µ –∑–∞ –∏–∑—á–∏—Å–ª–µ–Ω–∏–µ –Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏

**Advanced —Ç–µ—Ö–Ω–∏–∫–∏:**
- **Rerooting:** –ó–∞ DP —Å –≤—Å–∏—á–∫–∏ –≤—ä–∑–º–æ–∂–Ω–∏ –∫–æ—Ä–µ–Ω–∏  
- **Euler Tour:** –ü—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞ –¥—ä—Ä–≤–æ –≤ –º–∞—Å–∏–≤ –∑–∞ range queries
- **Heavy-Light Decomposition:** –ó–∞ —Å–ª–æ–∂–Ω–∏ –∑–∞—è–≤–∫–∏ –≤—ä—Ä—Ö—É –ø—ä—Ç–∏—â–∞
- **Centroid Decomposition:** –ó–∞ –∑–∞–¥–∞—á–∏ —Å —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è –≤ –¥—ä—Ä–≤–æ—Ç–æ

–î—ä—Ä–≤–µ—Ç–∞—Ç–∞ –ø–æ–∑–≤–æ–ª—è–≤–∞—Ç –º–Ω–æ–≥–æ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–∞ –±—ä–¥–∞—Ç –∏–∑–ø—ä–ª–Ω–µ–Ω–∏ –∑–∞ –ª–æ–≥–∞—Ä–∏—Ç–º–∏—á–Ω–æ –≤—Ä–µ–º–µ. –†–∞–∑–±–∏—Ä–∞–Ω–µ—Ç–æ –Ω–∞ LCA –∏ –¥–∏–Ω–∞–º–∏—á–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –≤—ä—Ä—Ö—É –¥—ä—Ä–≤–µ—Ç–∞ –µ –∫—Ä–∏—Ç–∏—á–Ω–æ –∑–∞ –Ω–∞–ø—Ä–µ–¥–Ω–∞–ª–∏ —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–∏. –ü—Ä–∞–∫—Ç–∏–∫—É–≤–∞–π—Ç–µ —Ä–µ–¥–æ–≤–Ω–æ —Å —Ä–∞–∑–ª–∏—á–Ω–∏ —Ç–∏–ø–æ–≤–µ –∑–∞–¥–∞—á–∏ –∑–∞ –¥–∞ —Ä–∞–∑–≤–∏–µ—Ç–µ –∏–Ω—Ç—É–∏—Ü–∏—è –∑–∞ –ø—Ä–∞–≤–∏–ª–Ω–∏—è –ø–æ–¥—Ö–æ–¥!
