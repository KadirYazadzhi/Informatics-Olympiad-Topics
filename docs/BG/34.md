# üå≥ –ù–∞–ø—Ä–µ–¥–Ω–∞–ª–∏ –°—Ç—Ä—É–∫—Ç—É—Ä–∏ –æ—Ç –î–∞–Ω–Ω–∏

–ó–∞—è–≤–∫–∏—Ç–µ –≤—ä—Ä—Ö—É –º–∞—Å–∏–≤–∏ (—Å—É–º–∞, –º–∏–Ω–∏–º—É–º, –º–∞–∫—Å–∏–º—É–º –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª) —Å–∞ —á–µ—Å—Ç–æ —Å—Ä–µ—â–∞–Ω–∏.
–ù–∞–∏–≤–Ω–∏—è—Ç –ø–æ–¥—Ö–æ–¥ –µ $O(N)$ –∑–∞ –∑–∞—è–≤–∫–∞. –ò—Å–∫–∞–º–µ $O(\log N)$ –∏–ª–∏ $O(1)$.

## 1. –î—ä—Ä–≤–æ –Ω–∞ –§–µ–Ω—É–∏–∫ (Binary Indexed Tree - BIT)

–ù–∞–π-–ª–µ—Å–Ω–∞—Ç–∞ –∑–∞ –ø–∏—Å–∞–Ω–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–∞ –ø—Ä–µ—Ñ–∏–∫—Å–Ω–∏ —Å—É–º–∏ —Å –æ–±–Ω–æ–≤—è–≤–∞–Ω–µ.
*   **Update**: $O(\log N)$.
*   **Query**: $O(\log N)$.
*   –ë–∞–∑–∏—Ä–∞–Ω–æ –Ω–∞ –¥–≤–æ–∏—á–Ω–æ—Ç–æ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ –Ω–∞ –∏–Ω–¥–µ–∫—Å–∞.

```cpp
int bit[MAXN];
void update(int idx, int val) {
    for (; idx < n; idx = idx | (idx + 1))
        bit[idx] += val;
}
int query(int idx) {
    int sum = 0;
    for (; idx >= 0; idx = (idx & (idx + 1)) - 1)
        sum += bit[idx];
    return sum;
}
```

## 2. –°–µ–≥–º–µ–Ω—Ç–Ω–æ –î—ä—Ä–≤–æ (Segment Tree)

–ü–æ-–º–æ—â–Ω–æ –æ—Ç BIT. –ü–æ–¥–¥—ä—Ä–∂–∞ –≤—Å—è–∫–∞–∫–≤–∏ –∞—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ (min, max, gcd).
*   –°—Ç—Ä–æ–∏ —Å–µ –∑–∞ $O(N)$.
*   –í—Å—è–∫–∞ –∑–∞—è–≤–∫–∞ –µ $O(\log N)$.
*   –ó–∞–µ–º–∞ $4N$ –ø–∞–º–µ—Ç.

### Lazy Propagation
–ü–æ–∑–≤–æ–ª—è–≤–∞ –æ–±–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ —Ü—è–ª –∏–Ω—Ç–µ—Ä–≤–∞–ª (Range Update) –∑–∞ $O(\log N)$.
–ò–¥–µ—è: –ú–∞—Ä–∫–∏—Ä–∞–º–µ –≤—ä–∑–µ–ª–∞ –∫–∞—Ç–æ "–º—ä—Ä–∑–µ–ª–∏–≤" –∏ –æ–±–Ω–æ–≤—è–≤–∞–º–µ –¥–µ—Ü–∞—Ç–∞ –º—É —Å–∞–º–æ –∫–æ–≥–∞—Ç–æ –µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ.

## 3. –†–∞–∑—Ä–µ–¥–µ–Ω–∞ –¢–∞–±–ª–∏—Ü–∞ (Sparse Table)

–ó–∞ **—Å—Ç–∞—Ç–∏—á–Ω–∏** (–Ω–µ–ø—Ä–æ–º–µ–Ω—è–µ–º–∏) –º–∞—Å–∏–≤–∏.
*   **Build**: $O(N \log N)$.
*   **Query**: $O(1)$ –∑–∞ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ (min, max, gcd).
*   –ò–¥–µ—è: –ü–∞–∑–∏–º –æ—Ç–≥–æ–≤–æ—Ä–∏—Ç–µ –∑–∞ –≤—Å–∏—á–∫–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∏ —Å –¥—ä–ª–∂–∏–Ω–∞ $2^k$. –í—Å—è–∫–∞ –∑–∞—è–≤–∫–∞ —Å–µ –ø–æ–∫—Ä–∏–≤–∞ –æ—Ç –¥–≤–∞ –∑–∞—Å—Ç—ä–ø–≤–∞—â–∏ —Å–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞.

## 4. Sqrt Decomposition (Mo's Algorithm)

–†–∞–∑–¥–µ–ª—è –º–∞—Å–∏–≤–∞ –Ω–∞ –±–ª–æ–∫–æ–≤–µ —Å —Ä–∞–∑–º–µ—Ä $\sqrt{N}$.
*   **Mo's Algorithm**: –ü–æ–∑–≤–æ–ª—è–≤–∞ —Ä–µ—à–∞–≤–∞–Ω–µ –Ω–∞ offline –∑–∞—è–≤–∫–∏ (–≤—Å–∏—á–∫–∏ —Å–∞ –∏–∑–≤–µ—Å—Ç–Ω–∏ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–æ) —á—Ä–µ–∑ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ. –°–ª–æ–∂–Ω–æ—Å—Ç $O((N+Q)\sqrt{N})$.
*   –ü–æ–ª–µ–∑–Ω–æ –∑–∞ —Å–ª–æ–∂–Ω–∏ –∑–∞—è–≤–∫–∏ (–Ω–∞–ø—Ä. "–±—Ä–æ–π —Ä–∞–∑–ª–∏—á–Ω–∏ —á–∏—Å–ª–∞ –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞").

## 5. Treap (Implicit)

–ú–æ–∂–µ –¥–∞ —Å–µ –ø–æ–ª–∑–≤–∞ –∫–∞—Ç–æ –º–∞—Å–∏–≤, –∫–æ–π—Ç–æ –ø–æ–¥–¥—ä—Ä–∂–∞ `split` –∏ `merge`, –ø–æ–∑–≤–æ–ª—è–≤–∞–π–∫–∏ –≤–º—ä–∫–≤–∞–Ω–µ/–∏–∑—Ç—Ä–∏–≤–∞–Ω–µ –∏ –æ–±—Ä—ä—â–∞–Ω–µ –Ω–∞ –ø–æ–¥–º–∞—Å–∏–≤–∏.

## 6. –ó–∞–¥–∞—á–∏
1.  **CSES Range Queries**: –¶—è–ª —Ä–∞–∑–¥–µ–ª.
2.  **SPOJ GSS1/GSS3**: Maximum Sum Subsegment (SegTree).
3.  **Codeforces 86D**: Powerful array (Mo's Algorithm).

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ
–ó–∞–ø–æ—á–Ω–µ—Ç–µ —Å BIT –∑–∞ —Å—É–º–∏. –ê–∫–æ –≤–∏ —Ç—Ä—è–±–≤–∞ Min/Max, –Ω–∞—É—á–µ—Ç–µ Sparse Table (—Å—Ç–∞—Ç–∏—á–Ω–æ) –∏–ª–∏ Segment Tree (–¥–∏–Ω–∞–º–∏—á–Ω–æ).
