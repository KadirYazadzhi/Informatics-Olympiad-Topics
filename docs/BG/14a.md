# üîô Backtracking (–¢—ä—Ä—Å–µ–Ω–µ —Å –≤—Ä—ä—â–∞–Ω–µ)

## üìö –í—ä–≤–µ–¥–µ–Ω–∏–µ

Backtracking –µ –∞–ª–≥–æ—Ä–∏—Ç–º–∏—á–Ω–∞ —Ç–µ—Ö–Ω–∏–∫–∞ –∑–∞ —Ä–µ—à–∞–≤–∞–Ω–µ –Ω–∞ –∑–∞–¥–∞—á–∏ —á—Ä–µ–∑ –ø—ä–ª–Ω–æ –∏–∑—á–µ—Ä–ø–≤–∞–Ω–µ (brute-force), –∫–æ—è—Ç–æ –∏–∑–≥—Ä–∞–∂–¥–∞ —Ä–µ—à–µ–Ω–∏–µ—Ç–æ —Å—Ç—ä–ø–∫–∞ –ø–æ —Å—Ç—ä–ø–∫–∞ –∏ —Å–µ "–≤—Ä—ä—â–∞ –Ω–∞–∑–∞–¥" (backtracks), –≤–µ–¥–Ω–∞–≥–∞ —â–æ–º —É—Å—Ç–∞–Ω–æ–≤–∏, —á–µ —Ç–µ–∫—É—â–∏—è—Ç –ø—ä—Ç –Ω–µ –≤–æ–¥–∏ –¥–æ –≤–∞–ª–∏–¥–Ω–æ —Ä–µ—à–µ–Ω–∏–µ.

–î—É–º–∞—Ç–∞ "backtrack" –æ–∑–Ω–∞—á–∞–≤–∞ "–≤—Ä—ä—â–∞–Ω–µ –Ω–∞–∑–∞–¥ –ø–æ —Å–ª–µ–¥–∏—Ç–µ". –ü—Ä–µ–¥—Å—Ç–∞–≤–µ—Ç–µ —Å–∏, —á–µ —Å—Ç–µ –≤ –ª–∞–±–∏—Ä–∏–Ω—Ç - –≤—ä—Ä–≤–∏—Ç–µ –Ω–∞–ø—Ä–µ–¥, –¥–æ–∫–∞—Ç–æ –Ω–µ —Å—Ç–∏–≥–Ω–µ—Ç–µ –¥–æ –∑–∞–¥—ä–Ω–µ–Ω–∞ —É–ª–∏—Ü–∞, —Ç–æ–≥–∞–≤–∞ —Å–µ –≤—Ä—ä—â–∞—Ç–µ –Ω–∞–∑–∞–¥ –¥–æ –ø–æ—Å–ª–µ–¥–Ω–æ—Ç–æ —Ä–∞–∑–∫–ª–æ–Ω–µ–Ω–∏–µ –∏ –æ–ø–∏—Ç–≤–∞—Ç–µ –¥—Ä—É–≥ –ø—ä—Ç. –¢–æ–≤–∞ –µ —Å—ä—â–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ backtracking.

–¢–µ—Ö–Ω–∏–∫–∞—Ç–∞ –µ –æ—Å–æ–±–µ–Ω–æ –º–æ—â–Ω–∞ –∑–∞ –∑–∞–¥–∞—á–∏, –∫—ä–¥–µ—Ç–æ —Ç—Ä—è–±–≤–∞ –¥–∞ –Ω–∞–º–µ—Ä–∏–º –≤—Å–∏—á–∫–∏ –≤—ä–∑–º–æ–∂–Ω–∏ —Ä–µ—à–µ–Ω–∏—è –∏–ª–∏ –¥–∞ –ø—Ä–æ–≤–µ—Ä–∏–º –¥–∞–ª–∏ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞ —Ä–µ—à–µ–Ω–∏–µ, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–≤–∞—â–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è.

---

## 1. –û–±—â–∞ —Å—Ö–µ–º–∞

Backtracking –µ –ø–æ —Å—ä—â–µ—Å—Ç–≤–æ –î—ä–ª–±–æ–∫–æ –û–±—Ö–æ–∂–¥–∞–Ω–µ (DFS) –≤ –¥—ä—Ä–≤–æ—Ç–æ –Ω–∞ —Å—ä—Å—Ç–æ—è–Ω–∏—è—Ç–∞. –í—Å—è–∫–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–≤–∞ —á–∞—Å—Ç–∏—á–Ω–æ —Ä–µ—à–µ–Ω–∏–µ, –∞ –ø—Ä–µ—Ö–æ–¥–∏—Ç–µ –º–µ–∂–¥—É —Å—ä—Å—Ç–æ—è–Ω–∏—è—Ç–∞ —Å–∞ –≤–∞–ª–∏–¥–Ω–∏ —Ö–æ–¥–æ–≤–µ.

### 1.1. –ë–∞–∑–æ–≤ —à–∞–±–ª–æ–Ω

```cpp
void backtrack(State current) {
    if (isSolution(current)) {
        printSolution(current);
        return;
    }

    for (Option opt : getOptions(current)) {
        if (isValid(current, opt)) {
            makeMove(current, opt); // –ù–∞–ø—Ä–µ–¥
            backtrack(current);     // –†–µ–∫—É—Ä—Å–∏—è
            undoMove(current, opt); // –ù–∞–∑–∞–¥ (Backtrack)
        }
    }
}
```

### 1.2. –ö–ª—é—á–æ–≤–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏

**–°—ä—Å—Ç–æ—è–Ω–∏–µ (State):** –ü—Ä–µ–¥—Å—Ç–∞–≤—è —Ç–µ–∫—É—â–∞—Ç–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –Ω–∞ –ø—Ä–æ–±–ª–µ–º–∞. –ú–æ–∂–µ –¥–∞ –≤–∫–ª—é—á–≤–∞:
- –ß–∞—Å—Ç–∏—á–Ω–æ —Ä–µ—à–µ–Ω–∏–µ
- –ò–∑–ø–æ–ª–∑–≤–∞–Ω–∏ —Ä–µ—Å—É—Ä—Å–∏
- –¢–µ–∫—É—â–∞ –ø–æ–∑–∏—Ü–∏—è –≤ –¥—ä—Ä–æ—Ç–æ –Ω–∞ —Ä–µ—à–µ–Ω–∏—è—Ç–∞

**–í–∞–ª–∏–¥–∏—Ä–∞–Ω–µ (isValid):** –ü—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ –¥–∞–¥–µ–Ω —Ö–æ–¥ –µ –¥–æ–ø—É—Å—Ç–∏–º –ø—Ä–∏ —Ç–µ–∫—É—â–æ—Ç–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ. –¢–æ–≤–∞ –µ –∫—Ä–∏—Ç–∏—á–Ω–æ –∑–∞ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—Ç–∞ - –∫–æ–ª–∫–æ—Ç–æ –ø–æ-—Ä–∞–Ω–æ –æ—Ç–∫–∞–∂–µ–º –Ω–µ–≤–∞–ª–∏–¥–Ω–∏ –ø—ä—Ç–∏—â–∞, —Ç–æ–ª–∫–æ–≤–∞ –ø–æ-–±—ä—Ä–∑–æ —â–µ —Ä–∞–±–æ—Ç–∏ –∞–ª–≥–æ—Ä–∏—Ç—ä–º—ä—Ç.

**–†–µ—à–µ–Ω–∏–µ (isSolution):** –û–ø—Ä–µ–¥–µ–ª—è –¥–∞–ª–∏ —Å–º–µ —Å—Ç–∏–≥–Ω–∞–ª–∏ –¥–æ –≤–∞–ª–∏–¥–Ω–æ —Ä–µ—à–µ–Ω–∏–µ –Ω–∞ –ø—Ä–æ–±–ª–µ–º–∞.

**–•–æ–¥–æ–≤–µ (makeMove/undoMove):** –ü—Ä–∏–ª–∞–≥–∞—Ç –∏ –æ—Ç–º–µ–Ω—è—Ç –ø—Ä–æ–º–µ–Ω–∏ –≤ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ. –í–∞–∂–Ω–æ –µ `undoMove` –¥–∞ –≤—ä–∑—Å—Ç–∞–Ω–æ–≤—è–≤–∞ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ —Ç–æ—á–Ω–æ –∫–∞–∫—Ç–æ –µ –±–∏–ª–æ –ø—Ä–µ–¥–∏ `makeMove`.

---

## 2. –ö–ª–∞—Å–∏—á–µ—Å–∫–∏ –ø—Ä–∏–º–µ—Ä–∏

### 2.1. –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –ø–µ—Ä–º—É—Ç–∞—Ü–∏–∏
–î–∞ —Å–µ –Ω–∞–º–µ—Ä—è—Ç –≤—Å–∏—á–∫–∏ –Ω–∞—Ä–µ–¥–±–∏ –Ω–∞ —á–∏—Å–ª–∞—Ç–∞ –æ—Ç 1 –¥–æ N.

```cpp
int n;
vector<int> p;
bool used[20];

void permutations() {
    if (p.size() == n) {
        for (int x : p) cout << x << " ";
        cout << endl;
        return;
    }
    for (int i = 1; i <= n; i++) {
        if (!used[i]) {
            used[i] = true;
            p.push_back(i);
            permutations();
            p.pop_back(); // Backtrack
            used[i] = false;
        }
    }
}
```

### 2.2. –ó–∞–¥–∞—á–∞—Ç–∞ –∑–∞ N-—Ç–µ —Ü–∞—Ä–∏—Ü–∏
–î–∞ —Å–µ —Ä–∞–∑–ø–æ–ª–æ–∂–∞—Ç $N$ —Ü–∞—Ä–∏—Ü–∏ –Ω–∞ –¥—ä—Å–∫–∞ $N \times N$, —Ç–∞–∫–∞ —á–µ –¥–∞ –Ω–µ —Å–µ –±–∏—è—Ç.
*   –ò–∑–ø–æ–ª–∑–≤–∞–º–µ –º–∞—Å–∏–≤–∏ `col`, `diag1`, `diag2`, –∑–∞ –¥–∞ —Å–ª–µ–¥–∏–º –∑–∞–µ—Ç–∏—Ç–µ –ª–∏–Ω–∏–∏ –∑–∞ $O(1)$.
*   `diag1`: $row + col = const$
*   `diag2`: $row - col + N = const$

```cpp
int n, ans = 0;
bool col[20], d1[40], d2[40];

void solve(int r) {
    if (r == n) {
        ans++;
        return;
    }
    for (int c = 0; c < n; c++) {
        if (!col[c] && !d1[r + c] && !d2[r - c + n]) {
            col[c] = d1[r + c] = d2[r - c + n] = true;
            solve(r + 1);
            col[c] = d1[r + c] = d2[r - c + n] = false; // Backtrack
        }
    }
}
```

### 2.3. –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞
–ó–∞ –≤—Å—è–∫–∞ –µ–ª–µ–º–µ–Ω—Ç –∏–º–∞–º–µ –¥–≤–∞ –∏–∑–±–æ—Ä–∞: –¥–∞ –≥–æ –≤–∑–µ–º–µ–º –∏–ª–∏ –¥–∞ –Ω–µ –≥–æ –≤–∑–µ–º–µ–º.
–°–ª–æ–∂–Ω–æ—Å—Ç: $O(2^N)$.

```cpp
int n;
vector<int> arr;
vector<int> current;

void generateSubsets(int idx) {
    if (idx == n) {
        // –ü—Ä–∏–Ω—Ç–∏—Ä–∞–º–µ —Ç–µ–∫—É—â–æ—Ç–æ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ
        for (int x : current) {
            cout << x << " ";
        }
        cout << endl;
        return;
    }
    
    // –í–∫–ª—é—á–≤–∞–º–µ arr[idx]
    current.push_back(arr[idx]);
    generateSubsets(idx + 1);
    current.pop_back();  // Backtrack
    
    // –ù–µ –≤–∫–ª—é—á–≤–∞–º–µ arr[idx]
    generateSubsets(idx + 1);
}
```

### 2.4. Sudoku —Ä–µ—à–∞—Ç–µ–ª

–ó–∞–ø—ä–ª–≤–∞–Ω–µ –Ω–∞ 9√ó9 –¥—ä—Å–∫–∞ —Å—ä—Å —Ü–∏—Ñ—Ä–∏ –æ—Ç 1 –¥–æ 9, —Ç–∞–∫–∞ —á–µ –≤ –≤—Å–µ–∫–∏ —Ä–µ–¥, –∫–æ–ª–æ–Ω–∞ –∏ 3√ó3 –∫–≤–∞–¥—Ä–∞—Ç –¥–∞ –Ω—è–º–∞ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è.

```cpp
bool isValid(int board[9][9], int row, int col, int num) {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ä–µ–¥–∞
    for (int c = 0; c < 9; c++) {
        if (board[row][c] == num) return false;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–ª–æ–Ω–∞—Ç–∞
    for (int r = 0; r < 9; r++) {
        if (board[r][col] == num) return false;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ 3√ó3 –∫–≤–∞–¥—Ä–∞—Ç–∞
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int r = 0; r < 3; r++) {
        for (int c = 0; c < 3; c++) {
            if (board[startRow + r][startCol + c] == num) {
                return false;
            }
        }
    }
    
    return true;
}

bool solveSudoku(int board[9][9]) {
    // –ù–∞–º–∏—Ä–∞–º–µ —Å–ª–µ–¥–≤–∞—â–∞—Ç–∞ –ø—Ä–∞–∑–Ω–∞ –∫–ª–µ—Ç–∫–∞
    int row = -1, col = -1;
    for (int r = 0; r < 9 && row == -1; r++) {
        for (int c = 0; c < 9; c++) {
            if (board[r][c] == 0) {
                row = r;
                col = c;
                break;
            }
        }
    }
    
    // –ê–∫–æ –Ω—è–º–∞ –ø—Ä–∞–∑–Ω–∏ –∫–ª–µ—Ç–∫–∏, —Ä–µ—à–µ–Ω–∏–µ—Ç–æ –µ –≥–æ—Ç–æ–≤–æ
    if (row == -1) return true;
    
    // –û–ø–∏—Ç–≤–∞–º–µ —Ü–∏—Ñ—Ä–∏—Ç–µ –æ—Ç 1 –¥–æ 9
    for (int num = 1; num <= 9; num++) {
        if (isValid(board, row, col, num)) {
            board[row][col] = num;  // –ü–æ—Å—Ç–∞–≤—è–º–µ —á–∏—Å–ª–æ—Ç–æ
            
            if (solveSudoku(board)) {
                return true;  // –ù–∞–º–µ—Ä–µ–Ω–æ —Ä–µ—à–µ–Ω–∏–µ
            }
            
            board[row][col] = 0;  // Backtrack
        }
    }
    
    return false;  // –ù—è–º–∞ —Ä–µ—à–µ–Ω–∏–µ —Å —Ç–µ–∫—É—â–∞—Ç–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
}
```

### 2.5. –ì–µ–Ω–µ—Ä–∏—Ä–∞–Ω–µ –Ω–∞ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏

–ò–∑–±–∏—Ä–∞–Ω–µ –Ω–∞ $k$ –µ–ª–µ–º–µ–Ω—Ç–∞ –æ—Ç $n$ –µ–ª–µ–º–µ–Ω—Ç–∞.

```cpp
int n, k;
vector<int> combination;

void generateCombinations(int start) {
    if (combination.size() == k) {
        // –ü—Ä–∏–Ω—Ç–∏—Ä–∞–º–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏—è—Ç–∞
        for (int x : combination) {
            cout << x << " ";
        }
        cout << endl;
        return;
    }
    
    for (int i = start; i <= n; i++) {
        combination.push_back(i);
        generateCombinations(i + 1);  // –°–ª–µ–¥–≤–∞—â–∏—è—Ç –µ–ª–µ–º–µ–Ω—Ç –µ –ø–æ-–≥–æ–ª—è–º
        combination.pop_back();  // Backtrack
    }
}
```

---

## 3. –û–∫–∞—Å—Ç—Ä—è–Ω–µ (Pruning)

–ù–∞–π-–≤–∞–∂–Ω–∞—Ç–∞ —á–∞—Å—Ç –æ—Ç Backtracking –µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è—Ç–∞. –ê–∫–æ —Å–º–µ —Å–∏–≥—É—Ä–Ω–∏, —á–µ —Ç–µ–∫—É—â–∏—è—Ç –∫–ª–æ–Ω –Ω—è–º–∞ –¥–∞ –¥–∞–¥–µ —Ä–µ—à–µ–Ω–∏–µ (–∏–ª–∏ –ø–æ-–¥–æ–±—Ä–æ –æ—Ç –≤–µ—á–µ –Ω–∞–º–µ—Ä–µ–Ω–æ—Ç–æ), —Å–ø–∏—Ä–∞–º–µ –≤–µ–¥–Ω–∞–≥–∞.

### 3.1. –í–∏–¥–æ–≤–µ –æ–∫–∞—Å—Ç—Ä—è–Ω–µ

**Feasibility Pruning (–û–∫–∞—Å—Ç—Ä—è–Ω–µ –ø–æ –æ—Å—ä—â–µ—Å—Ç–≤–∏–º–æ—Å—Ç):** –°–ø–∏—Ä–∞–º–µ –∫–æ–≥–∞—Ç–æ —Ä–µ—à–µ–Ω–∏–µ—Ç–æ –µ –Ω–µ–≤—ä–∑–º–æ–∂–Ω–æ.
*   –ü—Ä–∏–º–µ—Ä: –í –∑–∞–¥–∞—á–∞—Ç–∞ –∑–∞ —Ä–∞–Ω–∏—Ü–∞—Ç–∞, –∞–∫–æ —Ç–µ–∫—É—â–æ—Ç–æ —Ç–µ–≥–ª–æ –Ω–∞–¥–≤–∏—à–∞–≤–∞ –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç–∞, –≤—Ä—ä—â–∞–º–µ —Å–µ.

**Optimality Pruning (–û–∫–∞—Å—Ç—Ä—è–Ω–µ –ø–æ –æ–ø—Ç–∏–º–∞–ª–Ω–æ—Å—Ç):** –°–ø–∏—Ä–∞–º–µ –∫–æ–≥–∞—Ç–æ –Ω–µ –º–æ–∂–µ–º –¥–∞ –ø–æ—Å—Ç–∏–≥–Ω–µ–º –ø–æ-–¥–æ–±—Ä–æ —Ä–µ—à–µ–Ω–∏–µ –æ—Ç –≤–µ—á–µ –Ω–∞–º–µ—Ä–µ–Ω–æ—Ç–æ.
*   –ü—Ä–∏–º–µ—Ä: –í TSP (–¢—ä—Ä–≥–æ–≤—Å–∫–∏—è –ø—ä—Ç–Ω–∏–∫), –∞–∫–æ —Ç–µ–∫—É—â–∏—è—Ç –ø—ä—Ç –≤–µ—á–µ –µ –ø–æ-–¥—ä–ª—ä–≥ –æ—Ç –Ω–∞–π-–¥–æ–±—Ä–∏—è –Ω–∞–º–µ—Ä–µ–Ω –¥–æ –º–æ–º–µ–Ω—Ç–∞, —Å–ø–∏—Ä–∞–º–µ.

**Bound Pruning (–û–∫–∞—Å—Ç—Ä—è–Ω–µ —Å –≥—Ä–∞–Ω–∏—Ü–∏):** –ò–∑–ø–æ–ª–∑–≤–∞–º–µ –¥–æ–ª–Ω–∞/–≥–æ—Ä–Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞ –∑–∞ –¥–∞ –ø—Ä–µ—Ü–µ–Ω–∏–º –¥–∞–ª–∏ –∏–º–∞ —Å–º–∏—Å—ä–ª –¥–∞ –ø—Ä–æ–¥—ä–ª–∂–∏–º.
*   –ü—Ä–∏–º–µ—Ä: –í –∑–∞–¥–∞—á–∞—Ç–∞ –∑–∞ —Ä–∞–Ω–∏—Ü–∞—Ç–∞, –∞–∫–æ –¥–æ—Ä–∏ –¥–∞ –≤–∑–µ–º–µ–º –≤—Å–∏—á–∫–∏ –æ—Å—Ç–∞–≤–∞—â–∏ –ø—Ä–µ–¥–º–µ—Ç–∏ (relaxation), –Ω–µ –º–æ–∂–µ–º –¥–∞ –ø–æ–¥–æ–±—Ä–∏–º —Ç–µ–∫—É—â–∏—è –º–∞–∫—Å–∏–º—É–º, —Å–ø–∏—Ä–∞–º–µ.

### 3.2. –ü—Ä–∏–º–µ—Ä: –ó–∞–¥–∞—á–∞ –∑–∞ —Ä–∞–Ω–∏—Ü–∞—Ç–∞ —Å backtracking

```cpp
int n, capacity;
int weight[100], value[100];
int bestValue = 0;

void knapsack(int idx, int currentWeight, int currentValue) {
    if (currentWeight > capacity) return;  // Feasibility pruning
    
    if (idx == n) {
        bestValue = max(bestValue, currentValue);
        return;
    }
    
    // Optimality pruning: –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å relaxation
    int remainingValue = 0;
    for (int i = idx; i < n; i++) {
        remainingValue += value[i];
    }
    if (currentValue + remainingValue <= bestValue) {
        return;  // –ù–µ –º–æ–∂–µ–º –¥–∞ –ø–æ—Å—Ç–∏–≥–Ω–µ–º –ø–æ-–¥–æ–±—Ä–æ —Ä–µ—à–µ–Ω–∏–µ
    }
    
    // –í–∑–∏–º–∞–º–µ –ø—Ä–µ–¥–º–µ—Ç–∞
    knapsack(idx + 1, currentWeight + weight[idx], currentValue + value[idx]);
    
    // –ù–µ –≤–∑–∏–º–∞–º–µ –ø—Ä–µ–¥–º–µ—Ç–∞
    knapsack(idx + 1, currentWeight, currentValue);
}
```

### 3.3. Heuristics (–ï–≤—Ä–∏—Å—Ç–∏–∫–∏)

–†–µ–¥—ä—Ç, –ø–æ –∫–æ–π—Ç–æ –∏–∑—Å–ª–µ–¥–≤–∞–º–µ —Ä–µ—à–µ–Ω–∏—è—Ç–∞, –º–æ–∂–µ –¥—Ä–∞–º–∞—Ç–∏—á–Ω–æ –¥–∞ –ø–æ–≤–ª–∏—è–µ –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª–Ω–æ—Å—Ç—Ç–∞. –î–æ–±—Ä–∏—Ç–µ –µ–≤—Ä–∏—Å—Ç–∏–∫–∏ –Ω–∞–º–∏—Ä–∞—Ç —Ä–µ—à–µ–Ω–∏–µ—Ç–æ –ø–æ-—Ä–∞–Ω–æ.

**–ü—Ä–∏–º–µ—Ä: –ò–∑–±–æ—Ä –Ω–∞ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∞ –≤ Sudoku**
–í–º–µ—Å—Ç–æ –¥–∞ –æ–±—Ö–æ–∂–¥–∞–º–µ –∫–ª–µ—Ç–∫–∏—Ç–µ –ø–æ —Ä–µ–¥, –∏–∑–±–∏—Ä–∞–º–µ –∫–ª–µ—Ç–∫–∞—Ç–∞ —Å –Ω–∞–π-–º–∞–ª–∫–æ –≤—ä–∑–º–æ–∂–Ω–∏ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ (Most Constrained Variable).

```cpp
pair<int, int> findBestCell(int board[9][9]) {
    int minOptions = 10;
    pair<int, int> bestCell = {-1, -1};
    
    for (int r = 0; r < 9; r++) {
        for (int c = 0; c < 9; c++) {
            if (board[r][c] != 0) continue;
            
            int options = 0;
            for (int num = 1; num <= 9; num++) {
                if (isValid(board, r, c, num)) options++;
            }
            
            if (options < minOptions) {
                minOptions = options;
                bestCell = {r, c};
            }
        }
    }
    
    return bestCell;
}
```

---

## 4. –°–ª–æ–∂–Ω–æ—Å—Ç

Backtracking –∞–ª–≥–æ—Ä–∏—Ç–º–∏—Ç–µ —á–µ—Å—Ç–æ –∏–º–∞—Ç –µ–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª–Ω–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç ($O(N!)$, $O(2^N)$, $O(K^N)$).
*   –ü–æ–¥—Ö–æ–¥—è—â–∏ —Å–∞ –∑–∞ $N \le 20$ (–∑–∞ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞) –∏–ª–∏ $N \le 10$ (–∑–∞ –ø–µ—Ä–º—É—Ç–∞—Ü–∏–∏).
*   –ê–∫–æ $N$ –µ –ø–æ-–≥–æ–ª—è–º–æ, —Ç—ä—Ä—Å–µ—Ç–µ –î–∏–Ω–∞–º–∏—á–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –∏–ª–∏ Greedy.

### 4.1. –ê–Ω–∞–ª–∏–∑ –Ω–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç—Ç–∞

**–ü–µ—Ä–º—É—Ç–∞—Ü–∏–∏:** 
- –ë—Ä–æ–π –≤—ä–∑–ª–∏: $1 + n + n(n-1) + n(n-1)(n-2) + \dots + n!$
- –ü—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª–Ω–æ $O(n \cdot n!)$

**–ü–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞:**
- –ë—Ä–æ–π –≤—ä–∑–ª–∏: $2^n$ (–≤—Å–µ–∫–∏ –µ–ª–µ–º–µ–Ω—Ç - –≤–∑–µ–º–∞–º–µ/–Ω–µ –≤–∑–µ–º–∞–º–µ)
- –û–±—â–æ –≤—Ä–µ–º–µ: $O(2^n \cdot T)$ –∫—ä–¥–µ—Ç–æ $T$ –µ –≤—Ä–µ–º–µ—Ç–æ –∑–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ –µ–¥–∏–Ω –≤—ä–∑–µ–ª

**N-—Ü–∞—Ä–∏—Ü–∏:**
- –ù–∞–π-–ª–æ—à —Å–ª—É—á–∞–π: $O(n^n)$
- –° pruning –Ω–∞ –ø—Ä–∞–∫—Ç–∏–∫–∞: –º–Ω–æ–≥–æ –ø–æ-–±—ä—Ä–∑–æ

### 4.2. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è

| –¢–∏–ø –∑–∞–¥–∞—á–∞ | –ú–∞–∫—Å–∏–º–∞–ª–µ–Ω N | –í—Ä–µ–º–µ (–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤—ä—á–Ω–æ) |
|------------|--------------|------------------------|
| –ü–µ—Ä–º—É—Ç–∞—Ü–∏–∏ | 10-11 | ~1 —Å–µ–∫—É–Ω–¥–∞ |
| –ü–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ | 20-25 | ~1 —Å–µ–∫—É–Ω–¥–∞ |
| N-—Ü–∞—Ä–∏—Ü–∏ | 15-20 | ~1 —Å–µ–∫—É–Ω–¥–∞ (—Å –¥–æ–±—Ä–æ pruning) |
| Sudoku 9√ó9 | –§–∏–∫—Å–∏—Ä–∞–Ω | –û–±–∏–∫–Ω–æ–≤–µ–Ω–æ –±—ä—Ä–∑–æ —Å –µ–≤—Ä–∏—Å—Ç–∏–∫–∏ |

---

## 5. Backtracking vs –î–∏–Ω–∞–º–∏—á–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ

### –ö–æ–≥–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ Backtracking?
- –¢—Ä—è–±–≤–∞ –¥–∞ –Ω–∞–º–µ—Ä–∏–º –í–°–ò–ß–ö–ò —Ä–µ—à–µ–Ω–∏—è
- –ü—Ä–æ–±–ª–µ–º—ä—Ç –Ω—è–º–∞ –æ–ø—Ç–∏–º–∞–ª–Ω–∞ –ø–æ–¥—Å—Ç—Ä—É–∫—Ç—É—Ä–∞
- –ú–∞–ª–∫–∏ constraints ($N \leq 20$)
- –ò–º–∞ –¥–æ–±—Ä–∏ –≤—ä–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∑–∞ pruning

### –ö–æ–≥–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –î–ü?
- –¢—ä—Ä—Å–∏–º –ï–î–ù–û –æ–ø—Ç–∏–º–∞–ª–Ω–æ —Ä–µ—à–µ–Ω–∏–µ (–∏–ª–∏ –±—Ä–æ–π —Ä–µ—à–µ–Ω–∏—è)
- –ò–º–∞ overlapping subproblems
- –ú–æ–∂–µ –¥–∞ –¥–µ—Ñ–∏–Ω–∏—Ä–∞–º–µ clear state
- –ü–æ-–≥–æ–ª–µ–º–∏ constraints

### –ü—Ä–∏–º–µ—Ä: Subset Sum
- **Backtracking:** –ì–µ–Ω–µ—Ä–∏—Ä–∞ –≤—Å–∏—á–∫–∏ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ –∏ –ø—Ä–æ–≤–µ—Ä—è–≤–∞ —Å—É–º–∏—Ç–µ ($O(2^n)$ –±–µ–∑ –ø–∞–º–µ—Ç)
- **–î–ü:** –ü–∞–∑–∏ –∫–æ–∏ —Å—É–º–∏ —Å–∞ –¥–æ—Å—Ç–∏–∂–∏–º–∏ ($O(n \cdot sum)$ —Å –ø–∞–º–µ—Ç)

---

## 5. –ó–∞–¥–∞—á–∏
1.  **UVa 750**: 8 Queens Chess Problem.
2.  **Sudoku Solver**: –ö–ª–∞—Å–∏—á–µ—Å–∫–∏ backtracking.
3.  **Codeforces 1285B**: Just Eat It! (–º–æ–∂–µ –¥–∞ —Å–µ —Ä–µ—à–∏ –∏ —Å Greedy, –Ω–æ –º–∞–ª–∫–∏—Ç–µ constraints –ø–æ–∑–≤–æ–ª—è–≤–∞—Ç BT).
4.  **Knight's Tour**: –û–±—Ö–æ–∂–¥–∞–Ω–µ –Ω–∞ –¥—ä—Å–∫–∞ —Å –∫–æ–Ω.
5.  **CSES - Chessboard and Queens**: N-—Ü–∞—Ä–∏—Ü–∏ –≤–∞—Ä–∏–∞—Ü–∏—è.
6.  **LeetCode 51**: N-Queens (–∫–ª–∞—Å–∏—á–µ—Å–∫–∞ –∑–∞–¥–∞—á–∞).
7.  **LeetCode 37**: Sudoku Solver.
8.  **Codeforces 580C**: Kefa and Park (DFS/Backtracking –≤ –¥—ä—Ä–≤–æ).

---

## 6. –°—ä–≤–µ—Ç–∏ –∏ —á–µ—Å—Ç–æ —Å—Ä–µ—â–∞–Ω–∏ –≥—Ä–µ—à–∫–∏

### 6.1. –ß–µ—Å—Ç–æ —Å—Ä–µ—â–∞–Ω–∏ –≥—Ä–µ—à–∫–∏

**1. –ó–∞–±—Ä–∞–≤—è–Ω–µ –Ω–∞ undoMove:**
```cpp
// –ì–†–ï–®–ù–û
void backtrack(State s) {
    makeMove(s);
    backtrack(s);
    // –ó–∞–±—Ä–∞–≤–µ–Ω–æ: undoMove(s);
}
```

**2. –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–∞–Ω–µ –Ω–∞ –≥–ª–æ–±–∞–ª–Ω–∏ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏ –±–µ–∑ –≤—ä–∑—Å—Ç–∞–Ω–æ–≤—è–≤–∞–Ω–µ:**
```cpp
vector<int> path;

void solve() {
    path.push_back(x);
    solve();
    // –ó–∞–±—Ä–∞–≤–µ–Ω–æ: path.pop_back();
}
```

**3. –ù–µ–ø—Ä–∞–≤–∏–ª–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –±–∞–∑–∞:**
```cpp
// –ì–†–ï–®–ù–û: –º–æ–∂–µ –¥–∞ –ø—Ä–æ–ø—É—Å–Ω–µ–º –≤–∞–ª–∏–¥–Ω–∏ —Ä–µ—à–µ–Ω–∏—è
if (idx > n) return;  // –¢—Ä—è–±–≤–∞ –¥–∞ –µ idx == n
```

### 6.2. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–æ–Ω–Ω–∏ —Ç–µ—Ö–Ω–∏–∫–∏

**1. –ë–∏—Ç–æ–≤–∏ –º–∞—Å–∫–∏ –≤–º–µ—Å—Ç–æ –±—É–ª–µ–≤–∏ –º–∞—Å–∏–≤–∏:**
```cpp
// –í–º–µ—Å—Ç–æ bool used[20];
int usedMask = 0;

// –ü—Ä–æ–≤–µ—Ä–∫–∞
if (usedMask & (1 << i)) { /* –∏–∑–ø–æ–ª–∑–≤–∞–Ω */ }

// –ü–æ—Å—Ç–∞–≤—è–Ω–µ
usedMask |= (1 << i);

// –ü—Ä–µ–º–∞—Ö–≤–∞–Ω–µ
usedMask &= ~(1 << i);
```

**2. –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–æ –ø—Ä–µ—Å–º—è—Ç–∞–Ω–µ:**
–ê–∫–æ –ø—Ä–æ–≤–µ—Ä–∫–∏—Ç–µ —Å–∞ —Å–∫—ä–ø–∏, –ø—Ä–µ–∫–∞–ª–∫—É–ª–∏—Ä–∞–π—Ç–µ –≥–∏ –µ–¥–Ω–æ–∫—Ä–∞—Ç–Ω–æ.

**3. –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –≤—Ö–æ–¥–∞:**
–ü–æ–Ω—è–∫–æ–≥–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ—Ç–æ –ø–æ–∑–≤–æ–ª—è–≤–∞ –ø–æ-—Ä–∞–Ω–Ω–æ pruning.

### 6.3. Debugging —Å—ä–≤–µ—Ç–∏

1. **–ü—Ä–∏–Ω—Ç–∏—Ä–∞–π—Ç–µ –ø—ä—Ç—è:** –ü–æ–∫–∞–∑–≤–∞–π—Ç–µ —Ä–µ—à–µ–Ω–∏–µ—Ç–æ –Ω–∞ –≤—Å—è–∫–∞ —Å—Ç—ä–ø–∫–∞
2. **–û–≥—Ä–∞–Ω–∏—á–µ—Ç–µ –¥—ä–ª–±–æ—á–∏–Ω–∞—Ç–∞:** –¢–µ—Å—Ç–≤–∞–π—Ç–µ —Å –º–∞–ª–∫–∏ –≤—Ö–æ–¥–æ–≤–µ –ø—ä—Ä–≤–æ
3. **–ü—Ä–µ–±—Ä–æ—è–≤–∞–π—Ç–µ –∏–∑–≤–∏–∫–≤–∞–Ω–∏—è:** –ö–æ–ª–∫–æ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∏ –∏–∑–≤–∏–∫–≤–∞–Ω–∏—è —Å–µ –ø—Ä–∞–≤—è—Ç?
4. **–í–∏–∑—É–∞–ª–∏–∑–∏—Ä–∞–π—Ç–µ –¥—ä—Ä–≤–æ—Ç–æ:** –ù–∞—á–µ—Ä—Ç–∞–π—Ç–µ –ø—ä—Ä–≤–∏—Ç–µ –Ω—è–∫–æ–ª–∫–æ –Ω–∏–≤–∞

---

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–í–∏–Ω–∞–≥–∏ –ø–æ–º–Ω–µ—Ç–µ –¥–∞ –≤—ä–∑—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ (`undoMove`) —Å–ª–µ–¥ –≤—Ä—ä—â–∞–Ω–µ –æ—Ç —Ä–µ–∫—É—Ä—Å–∏—è—Ç–∞. –¢–æ–≤–∞ –µ –Ω–∞–π-—á–µ—Å—Ç–∞—Ç–∞ –≥—Ä–µ—à–∫–∞.

Backtracking –µ –º–æ—â–Ω–∞ —Ç–µ—Ö–Ω–∏–∫–∞, –Ω–æ –∏–∑–∏—Å–∫–≤–∞ –≤–Ω–∏–º–∞–Ω–∏–µ –∫—ä–º –¥–µ—Ç–∞–π–ª–∏—Ç–µ. –ö–ª—é—á—ä—Ç –∫—ä–º —É—Å–ø–µ—Ö–∞ –µ:
1. **–ü—Ä–∞–≤–∏–ª–Ω–∞ –¥–µ—Ñ–∏–Ω–∏—Ü–∏—è –Ω–∞ —Å—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ** - –∫–∞–∫–≤–æ —Ç—Ä—è–±–≤–∞ –¥–∞ –∑–Ω–∞–µ–º –Ω–∞ –≤—Å—è–∫–∞ —Å—Ç—ä–ø–∫–∞?
2. **–ï—Ñ–µ–∫—Ç–∏–≤–Ω–∞ –≤–∞–ª–∏–¥–∞—Ü–∏—è** - –∫–æ–ª–∫–æ—Ç–æ –ø–æ-—Ä–∞–Ω–æ –æ—Ç–∫–∞–∂–µ–º –Ω–µ–≤–∞–ª–∏–¥–Ω–∏ –ø—ä—Ç–∏—â–∞, —Ç–æ–ª–∫–æ–≤–∞ –ø–æ-–±—ä—Ä–∑–æ
3. **–ö–æ—Ä–µ–∫—Ç–Ω–æ backtracking** - –≤—Å—è–∫–∞ –ø—Ä–æ–º—è–Ω–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–µ –æ—Ç–º–µ–Ω–∏
4. **–ò–Ω—Ç–µ–ª–∏–≥–µ–Ω—Ç–Ω–æ –æ–∫–∞—Å—Ç—Ä—è–Ω–µ** - –¥–æ–±—Ä–∏—Ç–µ –µ–≤—Ä–∏—Å—Ç–∏–∫–∏ –ø—Ä–∞–≤—è—Ç —Ä–∞–∑–ª–∏–∫–∞—Ç–∞ –º–µ–∂–¥—É –±—ä—Ä–∑–æ –∏ –±–∞–≤–Ω–æ —Ä–µ—à–µ–Ω–∏–µ

–ü—Ä–∞–∫—Ç–∏–∫—É–≤–∞–π—Ç–µ —Å –∫–ª–∞—Å–∏—á–µ—Å–∫–∏—Ç–µ –∑–∞–¥–∞—á–∏ (N-—Ü–∞—Ä–∏—Ü–∏, Sudoku, –ø–µ—Ä–º—É—Ç–∞—Ü–∏–∏) –ø—Ä–µ–¥–∏ –¥–∞ –ø—Ä–µ–º–∏–Ω–µ—Ç–µ –∫—ä–º –ø–æ-—Å–ª–æ–∂–Ω–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è. –†–∞–∑–±–∏—Ä–∞–Ω–µ—Ç–æ –Ω–∞ —Ç–µ–∑–∏ –æ—Å–Ω–æ–≤–∏ —â–µ –≤–∏ –ø–æ–º–æ–≥–Ω–µ –¥–∞ —Ä–µ—à–∞–≤–∞—Ç–µ –º–Ω–æ–≥–æ –ø–æ-—Ç—Ä—É–¥–Ω–∏ –∑–∞–¥–∞—á–∏ –≤ —Å—ä—Å—Ç–µ–∑–∞–Ω–∏—è—Ç–∞.