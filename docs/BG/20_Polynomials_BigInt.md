# üìà –ü–æ–ª–∏–Ω–æ–º–∏ –∏ –ü—ä–ª–Ω–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –î—ä–ª–≥–∏ —á–∏—Å–ª–∞ (BigInt)

## üßÆ –î—ä–ª–≥–∏ —á–∏—Å–ª–∞ (BigInt) - –î–µ—Ç–∞–π–ª–Ω–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏—Ç–µ —Ç–∏–ø–æ–≤–µ –¥–∞–Ω–Ω–∏ (`long long`) —Å–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏ –¥–æ $\approx 9 \cdot 10^{18}$. –í –∑–∞–¥–∞—á–∏ —Å –ø–æ-–≥–æ–ª–µ–º–∏ —á–∏—Å–ª–∞ (–Ω–∞–ø—Ä. 100-—Ü–∏—Ñ—Ä–µ–Ω–∏) —Ç—Ä—è–±–≤–∞ –¥–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–º–µ —Å–æ–±—Å—Ç–≤–µ–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞.

### –ò–∑–±–æ—Ä –Ω–∞ –±–∞–∑–∞
–í–º–µ—Å—Ç–æ –¥–∞ –ø–∞–∑–∏–º –ø–æ –µ–¥–Ω–∞ —Ü–∏—Ñ—Ä–∞ (–±–∞–∑–∞ 10), –µ –º–Ω–æ–≥–æ –ø–æ-–µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –¥–∞ –ø–∞–∑–∏–º –ø–æ 9 —Ü–∏—Ñ—Ä–∏ (–±–∞–∑–∞ $10^9$) –≤ –µ–¥–∏–Ω `int`. –¢–æ–≤–∞ –Ω–∞–º–∞–ª—è–≤–∞ –ø–∞–º–µ—Ç—Ç–∞ –∏ –±—Ä–æ—è –æ–ø–µ—Ä–∞—Ü–∏–∏ 9 –ø—ä—Ç–∏.
- –ë–∞–∑–∞ $10^9$ —Å–µ –ø–æ–±–∏—Ä–∞ –≤ `int`, –∞ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ—Ç–æ –Ω–∞ –¥–≤–µ "—Ü–∏—Ñ—Ä–∏" ($10^{18}$) —Å–µ –ø–æ–±–∏—Ä–∞ –≤ `long long`.

### –ü—ä–ª–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ BigInt

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <iomanip>

using namespace std;

const int BASE = 1e9;

struct BigInt {
    vector<int> digits;

    BigInt() {}
    BigInt(long long v) {
        if (v == 0) digits.push_back(0);
        while (v > 0) {
            digits.push_back(v % BASE);
            v /= BASE;
        }
    }
    BigInt(string s) {
        for (int i = (int)s.length(); i > 0; i -= 9) {
            if (i < 9)
                digits.push_back(stoi(s.substr(0, i)));
            else
                digits.push_back(stoi(s.substr(i - 9, 9)));
        }
        trim();
    }

    void trim() {
        while (digits.size() > 1 && digits.back() == 0) {
            digits.pop_back();
        }
    }

    // –û–ø–µ—Ä–∞—Ç–æ—Ä –∑–∞ –∏–∑–≤–µ–∂–¥–∞–Ω–µ
    friend ostream& operator<<(ostream& os, const BigInt& bi) {
        if (bi.digits.empty()) { os << 0; return os; }
        os << bi.digits.back();
        for (int i = (int)bi.digits.size() - 2; i >= 0; i--) {
            os << setfill('0') << setw(9) << bi.digits[i];
        }
        return os;
    }

    // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ
    bool operator<(const BigInt& other) const {
        if (digits.size() != other.digits.size())
            return digits.size() < other.digits.size();
        for (int i = (int)digits.size() - 1; i >= 0; i--)
            if (digits[i] != other.digits[i])
                return digits[i] < other.digits[i];
        return false;
    }

    // –°—ä–±–∏—Ä–∞–Ω–µ
    BigInt operator+(const BigInt& other) const {
        BigInt res;
        int carry = 0;
        for (size_t i = 0; i < max(digits.size(), other.digits.size()) || carry; ++i) {
            int current = carry + (i < digits.size() ? digits[i] : 0) + 
                          (i < other.digits.size() ? other.digits[i] : 0);
            res.digits.push_back(current % BASE);
            carry = current / BASE;
        }
        return res;
    }

    // –ò–∑–≤–∞–∂–¥–∞–Ω–µ (–ø—Ä–∏–µ–º–∞–º–µ, —á–µ *this >= other)
    BigInt operator-(const BigInt& other) const {
        BigInt res;
        int carry = 0;
        for (size_t i = 0; i < digits.size(); ++i) {
            int current = digits[i] - carry - (i < other.digits.size() ? other.digits[i] : 0);
            if (current < 0) {
                current += BASE;
                carry = 1;
            } else {
                carry = 0;
            }
            res.digits.push_back(current);
        }
        res.trim();
        return res;
    }

    // –£–º–Ω–æ–∂–µ–Ω–∏–µ —Å –∫—ä—Å–æ —á–∏—Å–ª–æ (long long)
    BigInt operator*(long long v) const {
        BigInt res;
        long long carry = 0;
        for (int d : digits) {
            long long cur = d * v + carry;
            res.digits.push_back(cur % BASE);
            carry = cur / BASE;
        }
        while (carry) {
            res.digits.push_back(carry % BASE);
            carry /= BASE;
        }
        res.trim();
        return res;
    }

    // –£–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –¥–≤–µ BigInt —á–∏—Å–ª–∞
    BigInt operator*(const BigInt& other) const {
        BigInt res;
        res.digits.resize(digits.size() + other.digits.size(), 0);
        for (size_t i = 0; i < digits.size(); ++i) {
            long long carry = 0;
            for (size_t j = 0; j < other.digits.size() || carry; ++j) {
                long long cur = res.digits[i + j] + digits[i] * 1LL * (j < other.digits.size() ? other.digits[j] : 0) + carry;
                res.digits[i + j] = cur % BASE;
                carry = cur / BASE;
            }
        }
        res.trim();
        return res;
    }
};
```

---

## üìà –ü–æ–ª–∏–Ω–æ–º–∏

–ü–æ–ª–∏–Ω–æ–º–∏—Ç–µ —Å–∞ –æ–±–æ–±—â–µ–Ω–∏–µ –Ω–∞ —á–∏—Å–ª–∞—Ç–∞. –ê–∫–æ —á–∏—Å–ª–æ –µ –ø–æ–ª–∏–Ω–æ–º, –æ—Ü–µ–Ω–µ–Ω –≤ —Ç–æ—á–∫–∞ $x=10$ (–∑–∞ –¥–µ—Å–µ—Ç–∏—á–Ω–∞ —Å–∏—Å—Ç–µ–º–∞), —Ç–æ –æ–ø–µ—Ä–∞—Ü–∏–∏—Ç–µ —Å–∞ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–∏.

### –°—Ö–µ–º–∞ –Ω–∞ –•–æ—Ä–Ω–µ—Ä - –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
–°—Ö–µ–º–∞—Ç–∞ –Ω–∞ –•–æ—Ä–Ω–µ—Ä –Ω–∞–º–∞–ª—è–≤–∞ –±—Ä–æ—è –Ω–∞ —É–º–Ω–æ–∂–µ–Ω–∏—è—Ç–∞ –ø—Ä–∏ –ø—Ä–µ—Å–º—è—Ç–∞–Ω–µ –Ω–∞ $P(x)$.
–í–º–µ—Å—Ç–æ $a_n x^n + \dots + a_0$, –∑–∞–ø–∏—Å–≤–∞–º–µ:
$$(\dots((a_n x + a_{n-1})x + a_{n-2})x + \dots)x + a_0$$
–¢–∞–∫–∞ —Å–∞ –Ω—É–∂–Ω–∏ —Å–∞–º–æ $N$ —É–º–Ω–æ–∂–µ–Ω–∏—è –∏ $N$ —Å—ä–±–∏—Ä–∞–Ω–∏—è.

### –£–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –ø–æ–ª–∏–Ω–æ–º–∏
1. **–ù–∞–∏–≤–µ–Ω –º–µ—Ç–æ–¥**: $O(N^2)$ - –∏–¥–µ–Ω—Ç–∏—á–µ–Ω —Å —É–º–Ω–æ–∂–µ–Ω–∏–µ—Ç–æ –Ω–∞ BigInt –ø–æ-–≥–æ—Ä–µ.
2. **–ë—ä—Ä–∑–æ —É–º–Ω–æ–∂–µ–Ω–∏–µ (FFT)**: $O(N \log N)$. –ü—Ä–µ–æ–±—Ä–∞–∑—É–≤–∞ –ø–æ–ª–∏–Ω–æ–º–∏—Ç–µ –≤ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ (Point-Value form), —É–º–Ω–æ–∂–∞–≤–∞ –≥–∏ –ª–∏–Ω–µ–π–Ω–æ –∏ –≥–∏ –≤—Ä—ä—â–∞ –æ–±—Ä–∞—Ç–Ω–æ. (–í–∏–∂ –¢–µ–º–∞ 44).

### –ò–Ω—Ç–µ—Ä–ø–æ–ª–∞—Ü–∏—è –Ω–∞ –õ–∞–≥—Ä–∞–Ω–∂
–ê–∫–æ –∏–º–∞–º–µ $N+1$ —Ç–æ—á–∫–∏ $(x_i, y_i)$, —Å—ä—â–µ—Å—Ç–≤—É–≤–∞ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω –ø–æ–ª–∏–Ω–æ–º –æ—Ç —Å—Ç–µ–ø–µ–Ω $\le N$, –∫–æ–π—Ç–æ –º–∏–Ω–∞–≤–∞ –ø—Ä–µ–∑ —Ç—è—Ö.
$$P(x) = \sum_{j=0}^{N} y_j L_j(x), \quad \text{–∫—ä–¥–µ—Ç–æ } L_j(x) = \prod_{i \neq j} \frac{x - x_i}{x_j - x_i}$$

–¢–æ–≤–∞ –µ –ø–æ–ª–µ–∑–Ω–æ –∑–∞ –≤—ä–∑—Å—Ç–∞–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è –ø–æ –Ω–µ–π–Ω–∏—Ç–µ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏, –æ—Å–æ–±–µ–Ω–æ –≤ –∑–∞–¥–∞—á–∏ –∑–∞ –Ω–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ "—Å–ª–µ–¥–≤–∞—â–∏—è —á–ª–µ–Ω –Ω–∞ —Ä–µ–¥–∏—Ü–∞—Ç–∞".

---

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è—Ç–∞ –Ω–∞ `BigInt` –µ —á–µ—Å—Ç–æ —Å—Ä–µ—â–∞–Ω–∞ –ø–æ–¥–∑–∞–¥–∞—á–∞. –î–æ–±—Ä–µ –µ –¥–∞ –∏–º–∞—Ç–µ –ø–æ–¥–≥–æ—Ç–≤–µ–Ω –∏ —Ç–µ—Å—Ç–≤–∞–Ω —à–∞–±–ª–æ–Ω ("—á–µ—Ä–Ω–∞ –∫—É—Ç–∏—è"), –∫–æ–π—Ç–æ –¥–∞ –∫–æ–ø–∏—Ä–∞—Ç–µ –ø–æ –≤—Ä–µ–º–µ –Ω–∞ —Å—ä—Å—Ç–µ–∑–∞–Ω–∏–µ. –í–Ω–∏–º–∞–≤–∞–π—Ç–µ —Å "trim" —Ñ—É–Ω–∫—Ü–∏—è—Ç–∞ –∑–∞ –ø—Ä–µ–º–∞—Ö–≤–∞–Ω–µ –Ω–∞ –≤–æ–¥–µ—â–∏—Ç–µ –Ω—É–ª–∏, —Ç—ä–π –∫–∞—Ç–æ —Ç–µ –º–æ–≥–∞—Ç –¥–∞ —Å—á—É–ø—è—Ç –ª–æ–≥–∏–∫–∞—Ç–∞ –Ω–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ—Ç–æ –∏–ª–∏ –∏–∑–≤–µ–∂–¥–∞–Ω–µ—Ç–æ.

---

## 11. –†–∞–±–æ—Ç–∞ —Å –ø–æ–ª–∏–Ω–æ–º–∏ - –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–º–µ—Ä–∏

### 11.1. –û—Ü–µ–Ω—è–≤–∞–Ω–µ –Ω–∞ –ø–æ–ª–∏–Ω–æ–º —Å –•–æ—Ä–Ω–µ—Ä
```cpp
// P(x) = a[0] + a[1]*x + a[2]*x^2 + ... + a[n]*x^n
double horner(vector<double>& a, double x) {
    double result = 0;
    for (int i = a.size() - 1; i >= 0; i--) {
        result = result * x + a[i];
    }
    return result;
}
```

### 11.2. –°—ä–±–∏—Ä–∞–Ω–µ –Ω–∞ –ø–æ–ª–∏–Ω–æ–º–∏
```cpp
vector<int> addPolynomials(vector<int>& p1, vector<int>& p2) {
    int maxDegree = max(p1.size(), p2.size());
    vector<int> result(maxDegree, 0);
    
    for (int i = 0; i < p1.size(); i++) result[i] += p1[i];
    for (int i = 0; i < p2.size(); i++) result[i] += p2[i];
    
    return result;
}
```

### 11.3. –£–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –ø–æ–ª–∏–Ω–æ–º–∏ (–Ω–∞–∏–≤–µ–Ω –º–µ—Ç–æ–¥)
```cpp
vector<int> multiplyPolynomials(vector<int>& p1, vector<int>& p2) {
    vector<int> result(p1.size() + p2.size() - 1, 0);
    
    for (int i = 0; i < p1.size(); i++) {
        for (int j = 0; j < p2.size(); j++) {
            result[i + j] += p1[i] * p2[j];
        }
    }
    
    return result;
}
```
–°–ª–æ–∂–Ω–æ—Å—Ç: $O(N \times M)$, –∫—ä–¥–µ—Ç–æ $N$ –∏ $M$ —Å–∞ —Å—Ç–µ–ø–µ–Ω–∏—Ç–µ –Ω–∞ –ø–æ–ª–∏–Ω–æ–º–∏—Ç–µ.

---

## 12. –ò–Ω—Ç–µ—Ä–ø–æ–ª–∞—Ü–∏—è - –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ

### –ó–∞–¥–∞—á–∞: –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ —Å–ª–µ–¥–≤–∞—â —á–ª–µ–Ω –≤ —Ä–µ–¥–∏—Ü–∞
–î–∞–¥–µ–Ω–∏ —Å–∞ –ø—ä—Ä–≤–∏—Ç–µ $N+1$ —á–ª–µ–Ω–æ–≤–µ –Ω–∞ —Ä–µ–¥–∏—Ü–∞. –ù–∞–º–µ—Ä–µ—Ç–µ $(N+2)$-—Ä–∏—è —á–ª–µ–Ω.

**–†–µ—à–µ–Ω–∏–µ**: –ê–∫–æ —Ä–µ–¥–∏—Ü–∞—Ç–∞ —Å–µ –æ–ø–∏—Å–≤–∞ –æ—Ç –ø–æ–ª–∏–Ω–æ–º –æ—Ç —Å—Ç–µ–ø–µ–Ω $\le N$, –º–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –∏–Ω—Ç–µ—Ä–ø–æ–ª–∞—Ü–∏—è –Ω–∞ –õ–∞–≥—Ä–∞–Ω–∂.

```cpp
// –î–∞–¥–µ–Ω–∏ —Ç–æ—á–∫–∏ (0, y0), (1, y1), ..., (n, yn)
// –ù–∞–º–∏—Ä–∞–º–µ —Å—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ –ø–æ–ª–∏–Ω–æ–º–∞ –≤ —Ç–æ—á–∫–∞ x
double lagrangeInterpolation(vector<double>& y, double x) {
    int n = y.size();
    double result = 0;
    
    for (int j = 0; j < n; j++) {
        double term = y[j];
        for (int i = 0; i < n; i++) {
            if (i != j) {
                term *= (x - i) / (j - i);
            }
        }
        result += term;
    }
    
    return result;
}
```

–ü—Ä–∏–º–µ—Ä: –ê–∫–æ –∏–º–∞–º–µ $y = [1, 4, 9, 16, 25]$ (–∫–≤–∞–¥—Ä–∞—Ç–∏—Ç–µ –Ω–∞ —á–∏—Å–ª–∞—Ç–∞), —Ç–æ–≤–∞ –µ –ø–æ–ª–∏–Ω–æ–º –æ—Ç —Å—Ç–µ–ø–µ–Ω 2. –ú–æ–∂–µ–º –¥–∞ –Ω–∞–º–µ—Ä–∏–º —Å–ª–µ–¥–≤–∞—â–∏—è —á–ª–µ–Ω –∑–∞ $x=5$: $P(5) = 36$.

---

## 13. –í—Ä—ä–∑–∫–∞ —Å –¥–∏–Ω–∞–º–∏—á–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ

–ü–æ–ª–∏–Ω–æ–º–∏—Ç–µ —á–µ—Å—Ç–æ —Å–µ –ø–æ—è–≤—è–≤–∞—Ç –≤ DP –∑–∞–¥–∞—á–∏, –æ—Å–æ–±–µ–Ω–æ –ø—Ä–∏:
*   **Generating functions** (–ø—Ä–æ–∏–∑–≤–æ–¥—è—â–∏ —Ñ—É–Ω–∫—Ü–∏–∏).
*   **–ö–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∏–∫–∞** (–±–∏–Ω–æ–º–∏–∞–ª–Ω–∏ –∫–æ–µ—Ñ–∏—Ü–∏–µ–Ω—Ç–∏, Catalan —á–∏—Å–ª–∞).

–ù–∞–ø—Ä–∏–º–µ—Ä, –±—Ä–æ—è—Ç –Ω–∞ –Ω–∞—á–∏–Ω–∏—Ç–µ –¥–∞ —Ä–∞–∑–º–µ–Ω–∏–º –º–æ–Ω–µ—Ç–∏ –º–æ–∂–µ –¥–∞ —Å–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏ –∫–∞—Ç–æ –∫–æ–µ—Ñ–∏—Ü–∏–µ–Ω—Ç–∏ –≤ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –Ω–∞ –ø–æ–ª–∏–Ω–æ–º–∏.

---

## 14. –ó–∞–¥–∞—á–∏ –∑–∞ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ

1. **Project Euler 101**: Optimum Polynomial (–∏–Ω—Ç–µ—Ä–ø–æ–ª–∞—Ü–∏—è).
2. **Codeforces 528D**: Fuzzy Search (–º–æ–∂–µ –¥–∞ —Å–µ —Ä–µ—à–∏ —Å FFT —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –ø–æ–ª–∏–Ω–æ–º–∏).
3. **SPOJ POLYMUL**: –î–∏—Ä–µ–∫—Ç–Ω–æ —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –ø–æ–ª–∏–Ω–æ–º–∏.
4. **UVa 10105**: Polynomial Coefficients (–∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∏–∫–∞ —Å –ø–æ–ª–∏–Ω–æ–º–∏).

---

## üèÅ –§–∏–Ω–∞–ª–Ω–∏ —Å—ä–≤–µ—Ç–∏

*   –ó–∞ BigInt –∑–∞–¥–∞—á–∏ –≤–∏–Ω–∞–≥–∏ —Ç–µ—Å—Ç–≤–∞–π—Ç–µ —Å –µ–∫—Å—Ç—Ä–µ–º–Ω–∏ —Å–ª—É—á–∞–∏ (0, –º–Ω–æ–≥–æ –≥–æ–ª–µ–º–∏ —á–∏—Å–ª–∞, –µ–¥–Ω–∞–∫–≤–∏ —á–∏—Å–ª–∞).
*   –ü—Ä–∏ –ø–æ–ª–∏–Ω–æ–º–∏ –≤–Ω–∏–º–∞–≤–∞–π—Ç–µ —Å overflow - –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ `long long` –∏–ª–∏ –º–æ–¥—É–ª–Ω–∞ –∞—Ä–∏—Ç–º–µ—Ç–∏–∫–∞.
*   –°—Ö–µ–º–∞—Ç–∞ –Ω–∞ –•–æ—Ä–Ω–µ—Ä –µ –µ–ª–µ–≥–∞–Ω—Ç–Ω–∞ –∏ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∞ - –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ —è –≤–∏–Ω–∞–≥–∏, –∫–æ–≥–∞—Ç–æ –æ—Ü–µ–Ω—è–≤–∞—Ç–µ –ø–æ–ª–∏–Ω–æ–º.
*   –ó–∞ –∫–æ–Ω–∫—É—Ä—Å–∏ —Å –ø–æ–∑–≤–æ–ª–µ–Ω–∏ –≤—ä–Ω—à–Ω–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ (GMP, NTL) –Ω–∞—É—á–µ—Ç–µ —Å–µ –¥–∞ –≥–∏ –∏–∑–ø–æ–ª–∑–≤–∞—Ç–µ - —Å–ø–µ—Å—Ç—è–≤–∞—Ç –≤—Ä–µ–º–µ.

–í–ª–∞–¥–µ–µ–Ω–µ—Ç–æ –Ω–∞ —Ä–∞–±–æ—Ç–∞—Ç–∞ —Å –ø—Ä–æ–∏–∑–≤–æ–ª–Ω–æ –≥–æ–ª–µ–º–∏ —á–∏—Å–ª–∞ –∏ –ø–æ–ª–∏–Ω–æ–º–∏ –æ—Ç–≤–∞—Ä—è –≤—Ä–∞—Ç–∞—Ç–∞ –∫—ä–º –º–Ω–æ–≥–æ –Ω–∞–ø—Ä–µ–¥–Ω–∞–ª–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∏ –∫–∞—Ç–æ FFT, NTT –∏ —Ä–∞–∑–ª–∏—á–Ω–∏ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ—Å–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è!