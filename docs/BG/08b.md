# üî¢ –ü—Ä–æ—Å—Ç–∏ –ß–∏—Å–ª–∞ –∏ –†–µ—à–µ—Ç–æ –Ω–∞ –ï—Ä–∞—Ç–æ—Å—Ç–µ–Ω

–ü—Ä–æ—Å—Ç–∏—Ç–µ —á–∏—Å–ª–∞ —Å–∞ "–∞—Ç–æ–º–∏—Ç–µ" –Ω–∞ –∞—Ä–∏—Ç–º–µ—Ç–∏–∫–∞—Ç–∞. –í—Å—è–∫–æ —á–∏—Å–ª–æ —Å–µ —Ä–∞–∑–ª–∞–≥–∞ —É–Ω–∏–∫–∞–ª–Ω–æ –Ω–∞ –ø—Ä–æ—Å—Ç–∏ –º–Ω–æ–∂–∏—Ç–µ–ª–∏.

## 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –ø—Ä–æ—Å—Ç–æ—Ç–∞ (Primality Test)

### 1.1. –ù–∞–∏–≤–µ–Ω –º–µ—Ç–æ–¥: $O(\sqrt{N})$
–ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–µ–ª–∏—Ç–µ–ª–∏—Ç–µ –æ—Ç 2 –¥–æ $\sqrt{N}$.
```cpp
bool isPrime(long long n) {
    if (n < 2) return false;
    for (long long i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
```

### 1.2. –ú–∏–ª—ä—Ä-–†–∞–±–∏–Ω (Miller-Rabin): $O(k \log^3 N)$
–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–Ω —Ç–µ—Å—Ç –∑–∞ –º–Ω–æ–≥–æ –≥–æ–ª–µ–º–∏ —á–∏—Å–ª–∞ ($10^{18}$). 

## 2. –†–µ—à–µ—Ç–æ –Ω–∞ –ï—Ä–∞—Ç–æ—Å—Ç–µ–Ω (Sieve of Eratosthenes)

–ù–∞–º–∏—Ä–∞ –≤—Å–∏—á–∫–∏ –ø—Ä–æ—Å—Ç–∏ —á–∏—Å–ª–∞ –¥–æ $N$.
–°–ª–æ–∂–Ω–æ—Å—Ç: $O(N \log \log N)$.
```cpp
const int MAXN = 1000005;
bool is_prime[MAXN];

void sieve() {
    fill(is_prime, is_prime + MAXN, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i < MAXN; i++) {
        if (is_prime[i]) {
            for (int j = i * i; j < MAXN; j += i)
                is_prime[j] = false;
        }
    }
}
```

## 3. –õ–∏–Ω–µ–π–Ω–æ –†–µ—à–µ—Ç–æ (Linear Sieve)

–ù–∞–º–∏—Ä–∞ –ø—Ä–æ—Å—Ç–∏—Ç–µ —á–∏—Å–ª–∞ –∏ –Ω–∞–π-–º–∞–ª–∫–∏—è –ø—Ä–æ—Å—Ç –¥–µ–ª–∏—Ç–µ–ª (`lp`) –∑–∞ –≤—Å—è–∫–æ —á–∏—Å–ª–æ –∑–∞ $O(N)$.
–ü–æ–∑–≤–æ–ª—è–≤–∞ –±—ä—Ä–∑–∞ —Ñ–∞–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏—è.

```cpp
int lp[MAXN];
vector<int> primes;

void linearSieve() {
    for (int i = 2; i < MAXN; ++i) {
        if (lp[i] == 0) {
            lp[i] = i;
            primes.push_back(i);
        }
        for (int p : primes) {
            if (p > lp[i] || i * p >= MAXN) break;
            lp[i * p] = p;
        }
    }
}
```

## 4. –†–∞–∑–ª–∞–≥–∞–Ω–µ –Ω–∞ –º–Ω–æ–∂–∏—Ç–µ–ª–∏ (Factorization)
–ê–∫–æ –∏–º–∞–º–µ `lp` –æ—Ç –ª–∏–Ω–µ–π–Ω–æ—Ç–æ —Ä–µ—à–µ—Ç–æ, –º–æ–∂–µ–º –¥–∞ —Ä–∞–∑–ª–æ–∂–∏–º $X$ –∑–∞ $O(\log X)$.
```cpp
vector<int> getFactors(int x) {
    vector<int> factors;
    while (x > 1) {
        factors.push_back(lp[x]);
        x /= lp[x];
    }
    return factors;
}
```

## 5. –ë—Ä–æ–π –∏ –°—É–º–∞ –Ω–∞ –î–µ–ª–∏—Ç–µ–ª–∏—Ç–µ
–ê–∫–æ $N = p_1^{a_1} p_2^{a_2} \dots$:
*   **–ë—Ä–æ–π –¥–µ–ª–∏—Ç–µ–ª–∏**: $\tau(N) = (a_1+1)(a_2+1)\dots$
*   **–°—É–º–∞ –Ω–∞ –¥–µ–ª–∏—Ç–µ–ª–∏**: $\sigma(N) = \frac{p_1^{a_1+1}-1}{p_1-1} \dots$

## 6. –ó–∞–¥–∞—á–∏
1.  **SPOJ TDPRIMES**: Printing some primes.
2.  **Codeforces 230B**: T-primes (Squares of primes).
3.  **Project Euler**: Problem 10 (Summation of primes).

```