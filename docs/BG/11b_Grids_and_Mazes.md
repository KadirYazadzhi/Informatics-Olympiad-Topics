# üåå –ú—Ä–µ–∂–∏, –õ–∞–±–∏—Ä–∏–Ω—Ç–∏ –∏ –û–±—Ö–æ–∂–¥–∞–Ω–µ (Grids)

–ú—Ä–µ–∂–∏—Ç–µ (Grids) —Å–∞ –Ω–∞–π-—á–µ—Å—Ç–æ—Ç–æ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ –Ω–∞ –∫–∞—Ä—Ç–∏ –≤ —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ (–ª–∞–±–∏—Ä–∏–Ω—Ç–∏, –∏–≥—Ä–∏, —Ç–µ—Ä–µ–Ω–∏). –¢–µ —Å–∞ –≤—Å—ä—â–Ω–æ—Å—Ç –≥—Ä–∞—Ñ–∏, –∫—ä–¥–µ—Ç–æ –≤—Å—è–∫–∞ –∫–ª–µ—Ç–∫–∞ –µ –≤—Ä—ä—Ö, –∞ —Å—ä—Å–µ–¥–Ω–∏—Ç–µ –∫–ª–µ—Ç–∫–∏ —Å–∞ —Å–≤—ä—Ä–∑–∞–Ω–∏ —Å —Ä–µ–±—Ä–∞.

## 1. –û—Å–Ω–æ–≤–Ω–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏

### 1.1. –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∏ –í–∞–ª–∏–¥–Ω–æ—Å—Ç
–û–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Ä–∞–±–æ—Ç–∏–º —Å –º–∞—Ç—Ä–∏—Ü–∞ `grid[R][C]`. –†–µ–¥—ä—Ç –µ $r$, –∫–æ–ª–æ–Ω–∞—Ç–∞ –µ $c$.
–í–∞–∂–Ω–æ –µ –≤–∏–Ω–∞–≥–∏ –¥–∞ –ø—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ —Å–º–µ –∏–∑–ª–µ–∑–ª–∏ –∏–∑–≤—ä–Ω –∫–∞—Ä—Ç–∞—Ç–∞.

```cpp
const int MAXN = 1000;
int R, C;
int grid[MAXN][MAXN];
bool visited[MAXN][MAXN];

bool isValid(int r, int c) {
    return r >= 0 && r < R && c >= 0 && c < C; // –í–Ω–∏–º–∞–≤–∞–π—Ç–µ —Å 0-based vs 1-based
}
```

### 1.2. –í–µ–∫—Ç–æ—Ä–∏ –Ω–∞ –¥–≤–∏–∂–µ–Ω–∏–µ (Direction Arrays)
–ó–∞ –¥–∞ –Ω–µ –ø–∏—à–µ–º 4 `if`-–∞ –∑–∞ –≤—Å—è–∫–∞ –ø–æ—Å–æ–∫–∞, –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –º–∞—Å–∏–≤–∏ –∑–∞ –ø—Ä–æ–º—è–Ω–∞ –Ω–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏—Ç–µ.

**4 –ü–æ—Å–æ–∫–∏ (–°–µ–≤–µ—Ä, –Æ–≥, –ó–∞–ø–∞–¥, –ò–∑—Ç–æ–∫):**
```cpp
int dr[] = {-1, 1, 0, 0};
int dc[] = {0, 0, -1, 1};
```

**8 –ü–æ—Å–æ–∫–∏ (–í–∫–ª—é—á–∏—Ç–µ–ª–Ω–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ - –∑–∞ King/Queen):**
```cpp
int dr[] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dc[] = {-1, 0, 1, -1, 1, -1, 0, 1};
```

**–•–æ–¥ –Ω–∞ –ö–æ–Ω—è (Knight Moves):**
```cpp
int dr[] = {-2, -2, -1, -1, 1, 1, 2, 2};
int dc[] = {-1, 1, -2, 2, -2, 2, -1, 1};
```

## 2. –û–±—Ö–æ–∂–¥–∞–Ω–µ –≤ –¥—ä–ª–±–æ—á–∏–Ω–∞ (DFS) - Flood Fill

DFS –µ –∏–¥–µ–∞–ª–µ–Ω –∑–∞ –∑–∞–¥–∞—á–∏ –æ—Ç —Ç–∏–ø–∞ "–Ω–∞–º–µ—Ä–µ—Ç–µ –±—Ä–æ—è –Ω–∞ —Å–≤—ä—Ä–∑–∞–Ω–∏—Ç–µ –æ–±–ª–∞—Å—Ç–∏" (–Ω–∞–ø—Ä. –æ—Å—Ç—Ä–æ–≤–∏ –≤ –º–æ—Ä–µ) –∏–ª–∏ "—Ä–∞–∑–º–µ—Ä –Ω–∞ —Ç–µ–∫—É—â–∞—Ç–∞ –æ–±–ª–∞—Å—Ç". –ê–ª–≥–æ—Ä–∏—Ç—ä–º—ä—Ç, –∏–∑–≤–µ—Å—Ç–µ–Ω –∫–∞—Ç–æ **Flood Fill**, "–∑–∞–ª–∏–≤–∞" —Ü—è–ª–∞—Ç–∞ –¥–æ—Å—Ç–∏–∂–∏–º–∞ –∑–æ–Ω–∞.

### –ó–∞–¥–∞—á–∞: –ë—Ä–æ–π –Ω–∞ –æ—Å—Ç—Ä–æ–≤–∏—Ç–µ
–î–∞–¥–µ–Ω–∞ –µ –∫–∞—Ä—Ç–∞, –∫—ä–¥–µ—Ç–æ `1` –µ –∑–µ–º—è, `0` –µ –≤–æ–¥–∞. –ö–æ–ª–∫–æ —Å–∞ –æ—Å—Ç—Ä–æ–≤–∏—Ç–µ?

```cpp
void dfs(int r, int c) {
    visited[r][c] = true;
    
    // –û–ø–∏—Ç–≤–∞–º–µ –∏ 4-—Ç–µ –ø–æ—Å–æ–∫–∏
    for (int i = 0; i < 4; i++) {
        int nr = r + dr[i];
        int nc = c + dc[i];
        
        // –ê–∫–æ –µ –≤ –∫–∞—Ä—Ç–∞—Ç–∞, –Ω–µ –µ –ø–æ—Å–µ—Ç–µ–Ω–æ –∏ –µ –∑–µ–º—è
        if (isValid(nr, nc) && !visited[nr][nc] && grid[nr][nc] == 1) {
            dfs(nr, nc);
        }
    }
}

int countIslands() {
    int islands = 0;
    // –ù—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ visited...
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            if (grid[i][j] == 1 && !visited[i][j]) {
                islands++; // –ù–∞–º–µ—Ä–∏—Ö–º–µ –Ω–æ–≤ –æ—Å—Ç—Ä–æ–≤
                dfs(i, j); // –ú–∞—Ä–∫–∏—Ä–∞–º–µ —Ü—è–ª–∞—Ç–∞ –º—É —Ç–µ—Ä–∏—Ç–æ—Ä–∏—è
            }
        }
    }
    return islands;
}
```
–°–ª–æ–∂–Ω–æ—Å—Ç: $O(R \cdot C)$, –∑–∞—â–æ—Ç–æ –≤—Å—è–∫–∞ –∫–ª–µ—Ç–∫–∞ —Å–µ –ø–æ—Å–µ—â–∞–≤–∞ –Ω–∞–π-–º–Ω–æ–≥–æ –≤–µ–¥–Ω—ä–∂.

## 3. –û–±—Ö–æ–∂–¥–∞–Ω–µ –≤ —à–∏—Ä–∏–Ω–∞ (BFS) - –ù–∞–π-–∫—Ä–∞—Ç—ä–∫ –ø—ä—Ç

BFS –µ **–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–∏—è—Ç** –ø—Ä–∞–≤–∏–ª–µ–Ω –Ω–∞—á–∏–Ω –∑–∞ –Ω–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–∞–π-–∫—Ä–∞—Ç—ä–∫ –ø—ä—Ç –≤ –Ω–µ–ø—Ä–µ—Ç–µ–≥–ª–µ–Ω –≥—Ä–∞—Ñ (–º—Ä–µ–∂–∞, –∫—ä–¥–µ—Ç–æ –≤—Å—è–∫–∞ —Å—Ç—ä–ø–∫–∞ –µ —Å —Ü–µ–Ω–∞ 1). DFS –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞ –Ω–∞–π-–∫—Ä–∞—Ç—ä–∫ –ø—ä—Ç!

### –ó–∞–¥–∞—á–∞: –ò–∑—Ö–æ–¥ –æ—Ç –ª–∞–±–∏—Ä–∏–Ω—Ç
–ú–∏–Ω–∏–º–∞–ª–µ–Ω –±—Ä–æ–π —Å—Ç—ä–ø–∫–∏ –æ—Ç Start (S) –¥–æ End (E). `#` —Å–∞ —Å—Ç–µ–Ω–∏.

```cpp
#include <queue>
#include <tuple>

using namespace std;

int dist[MAXN][MAXN]; // –ü–∞–∑–∏ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ—Ç–æ. -1 –∑–∞ –Ω–µ–ø–æ—Å–µ—Ç–µ–Ω–æ.

int bfs(int startR, int startC, int endR, int endC) {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    for(int i=0; i<R; i++) 
        for(int j=0; j<C; j++) 
            dist[i][j] = -1;

    queue<pair<int, int>> q;
    q.push({startR, startC});
    dist[startR][startC] = 0;

    while (!q.empty()) {
        auto [r, c] = q.front();
        q.pop();

        if (r == endR && c == endC) return dist[r][c];

        for (int i = 0; i < 4; i++) {
            int nr = r + dr[i];
            int nc = c + dc[i];

            // –ü—Ä–æ–≤–µ—Ä–∫–∞: –≤–∞–ª–∏–¥–Ω–æ—Å—Ç, –Ω–µ –µ —Å—Ç–µ–Ω–∞, –Ω–µ –µ –ø–æ—Å–µ—Ç–µ–Ω–æ
            if (isValid(nr, nc) && grid[nr][nc] != '#' && dist[nr][nc] == -1) {
                dist[nr][nc] = dist[r][c] + 1;
                q.push({nr, nc});
            }
        }
    }
    return -1; // –ù—è–º–∞ –ø—ä—Ç
}
```

## 4. Multi-Source BFS (BFS –æ—Ç –º–Ω–æ–≥–æ –∏–∑—Ç–æ—á–Ω–∏—Ü–∏)

–ê–∫–æ –∏–º–∞–º–µ "–ø–æ–∂–∞—Ä", –∫–æ–π—Ç–æ —Ç—Ä—ä–≥–≤–∞ –æ—Ç 5 —Ä–∞–∑–ª–∏—á–Ω–∏ –∫–ª–µ—Ç–∫–∏ –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ, –∏ –∏—Å–∫–∞–º–µ –¥–∞ –∑–Ω–∞–µ–º –∫–æ–≥–∞ —â–µ —Å—Ç–∏–≥–Ω–µ –¥–æ –Ω–∞—Å.
*   –ü—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤—è–º–µ **–≤—Å–∏—á–∫–∏** —Å—Ç–∞—Ä—Ç–æ–≤–∏ –∫–ª–µ—Ç–∫–∏ –≤ –æ–ø–∞—à–∫–∞—Ç–∞ –≤ –Ω–∞—á–∞–ª–æ—Ç–æ (—Å `dist = 0`).
*   –°—Ç–∞—Ä—Ç–∏—Ä–∞–º–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–µ–Ω BFS.

## 5. –ó–∞–¥–∞—á–∏ –∑–∞ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ
1.  **CSES Counting Rooms**: –ö–ª–∞—Å–∏—á–µ—Å–∫–∏ Connected Components.
2.  **CSES Labyrinth**: BFS + –≤—ä–∑—Å—Ç–∞–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ –ø—ä—Ç—è (—á—Ä–µ–∑ `parent` –º–∞—Å–∏–≤).
3.  **Codeforces 598D**: Igor In the Museum (Flood Fill —Å –ø—Ä–µ–∫–∞–ª–∫—É–ª–∞—Ü–∏—è).
4.  **UVa 439 - Knight Moves**: BFS —Å —Ö–æ–¥ –Ω–∞ –∫–æ–Ω—è.

## üèÅ –°—ä–≤–µ—Ç–∏
*   –í–∏–Ω–∞–≥–∏ –ø—Ä–æ–≤–µ—Ä—è–≤–∞–π—Ç–µ –≥—Ä–∞–Ω–∏—Ü–∏—Ç–µ (`isValid`) **–ø—ä—Ä–≤–æ** –≤ `if`-–∞, –∑–∞ –¥–∞ –∏–∑–±–µ–≥–Ω–µ—Ç–µ `Segmentation Fault` –ø—Ä–∏ –¥–æ—Å—Ç—ä–ø –¥–æ –º–∞—Å–∏–≤–∞.
*   `visisted` –º–∞—Å–∏–≤—ä—Ç –µ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–µ–Ω, –∑–∞ –¥–∞ –Ω–µ —Å–µ –≤—ä—Ä—Ç–∏—Ç–µ –≤ –∫—Ä—ä–≥.
*   –ü—Ä–∏ BFS –≤–∏–Ω–∞–≥–∏ –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ `queue`, –∞ –Ω–µ `stack` –∏–ª–∏ —Ä–µ–∫—É—Ä—Å–∏—è.

---

## 6. –í—ä–∑—Å—Ç–∞–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ –ø—ä—Ç—è (Path Reconstruction)

–ß–µ—Å—Ç–æ –∑–∞–¥–∞—á–∏—Ç–µ –∏–∑–∏—Å–∫–≤–∞—Ç –Ω–µ —Å–∞–º–æ –¥–∞ –Ω–∞–º–µ—Ä–∏—Ç–µ –¥–∞–ª–∏ –∏–º–∞ –ø—ä—Ç, –Ω–æ –∏ –¥–∞ –≥–æ –∏–∑–≤–µ–¥–µ—Ç–µ. –ó–∞ —Ç–æ–≤–∞ –ø–∞–∑–∏–º –º–∞—Å–∏–≤ `parent`, –∫–æ–π—Ç–æ –∑–∞–ø–∏—Å–≤–∞ –æ—Ç –∫—ä–¥–µ —Å–º–µ –¥–æ—à–ª–∏ –Ω–∞ –≤—Å—è–∫–∞ –∫–ª–µ—Ç–∫–∞.

```cpp
struct Cell {
    int r, c;
};

Cell parent[MAXN][MAXN];

int bfs_with_path(int sr, int sc, int er, int ec) {
    queue<pair<int,int>> q;
    q.push({sr, sc});
    dist[sr][sc] = 0;
    parent[sr][sc] = {-1, -1}; // –ù–∞—á–∞–ª–æ
    
    while (!q.empty()) {
        auto [r, c] = q.front();
        q.pop();
        
        if (r == er && c == ec) {
            // –í—ä–∑—Å—Ç–∞–Ω–æ–≤—è–≤–∞–º–µ –ø—ä—Ç—è
            vector<pair<int,int>> path;
            int cr = er, cc = ec;
            while (cr != -1) {
                path.push_back({cr, cc});
                auto p = parent[cr][cc];
                cr = p.r; cc = p.c;
            }
            reverse(path.begin(), path.end());
            
            // –û—Ç–ø–µ—á–∞—Ç–≤–∞–º–µ –ø—ä—Ç—è
            for (auto [x, y] : path) {
                cout << "(" << x << ", " << y << ") ";
            }
            cout << endl;
            
            return dist[er][ec];
        }
        
        for (int i = 0; i < 4; i++) {
            int nr = r + dr[i];
            int nc = c + dc[i];
            
            if (isValid(nr, nc) && grid[nr][nc] != '#' && dist[nr][nc] == -1) {
                dist[nr][nc] = dist[r][c] + 1;
                parent[nr][nc] = {r, c};
                q.push({nr, nc});
            }
        }
    }
    return -1;
}
```

---

## 7. 0-1 BFS (Deque BFS)

–ê–∫–æ —Ü–µ–Ω–∞—Ç–∞ –Ω–∞ —Ö–æ–¥–æ–≤–µ—Ç–µ –Ω–µ –µ –µ–¥–Ω–∞–∫–≤–∞, –Ω–æ –µ –∏–ª–∏ 0, –∏–ª–∏ 1, –º–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ **Deque BFS**:
*   –•–æ–¥–æ–≤–µ —Å —Ü–µ–Ω–∞ 0 —Å–µ –¥–æ–±–∞–≤—è—Ç –≤ **–Ω–∞—á–∞–ª–æ—Ç–æ** –Ω–∞ –æ–ø–∞—à–∫–∞—Ç–∞.
*   –•–æ–¥–æ–≤–µ —Å —Ü–µ–Ω–∞ 1 —Å–µ –¥–æ–±–∞–≤—è—Ç –≤ **–∫—Ä–∞—è** –Ω–∞ –æ–ø–∞—à–∫–∞—Ç–∞.

–¢–æ–≤–∞ –∑–∞–ø–∞–∑–≤–∞ –º–æ–Ω–æ—Ç–æ–Ω–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è—Ç–∞ –∏ —Ä–∞–±–æ—Ç–∏ –∑–∞ $O(V + E)$.

```cpp
deque<pair<int,int>> dq;
dq.push_back({sr, sc});
dist[sr][sc] = 0;

while (!dq.empty()) {
    auto [r, c] = dq.front();
    dq.pop_front();
    
    for (int i = 0; i < 4; i++) {
        int nr = r + dr[i];
        int nc = c + dc[i];
        int cost = (grid[nr][nc] == 'X') ? 1 : 0; // –ü—Ä–∏–º–µ—Ä: 'X' —Å—Ç—Ä—É–≤–∞ 1
        
        if (isValid(nr, nc) && dist[nr][nc] == -1) {
            dist[nr][nc] = dist[r][c] + cost;
            
            if (cost == 0) dq.push_front({nr, nc});
            else dq.push_back({nr, nc});
        }
    }
}
```

---

## 8. –ß–µ—Å—Ç–æ —Å—Ä–µ—â–∞–Ω–∏ –ø—Ä–æ–±–ª–µ–º–∏ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

### 8.1. –ü–∞–º–µ—Ç
–ó–∞ –≥–æ–ª–µ–º–∏ –º—Ä–µ–∂–∏ (–Ω–∞–ø—Ä. $5000 \times 5000$), –¥–≤—É–º–µ—Ä–Ω–∏—Ç–µ –º–∞—Å–∏–≤–∏ –º–æ–≥–∞—Ç –¥–∞ —Å–∞ —Ç–≤—ä—Ä–¥–µ –≥–æ–ª–µ–º–∏. –ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ:
*   `vector<vector<int>>` –∑–∞ –¥–∏–Ω–∞–º–∏—á–Ω–æ –∑–∞–¥–µ–ª—è–Ω–µ.
*   –ï–¥–Ω–æ–º–µ—Ä–µ–Ω –º–∞—Å–∏–≤ —Å –∏–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ –∏–Ω–¥–µ–∫—Å: `index = r * C + c`.

### 8.2. –°–∫–æ—Ä–æ—Å—Ç
*   –ü—Ä–∏ BFS –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ `queue`, –∞ –Ω–µ `priority_queue` (–∏–∑–ª–∏—à–Ω–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç).
*   –ü—Ä–∏ DFS –≤–Ω–∏–º–∞–≤–∞–π—Ç–µ –¥–∞ –Ω–µ –ø—Ä–µ–≤–∏—à–∏—Ç–µ —Å—Ç–µ–∫–æ–≤–∞—Ç–∞ –ø–∞–º–µ—Ç –ø—Ä–∏ –¥—ä–ª–±–æ–∫–∞ —Ä–µ–∫—É—Ä—Å–∏—è. –ê–∫–æ $R \times C > 10^6$, –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –∏—Ç–µ—Ä–∞—Ç–∏–≤–µ–Ω DFS —Å—ä—Å `stack`.

---

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ú—Ä–µ–∂–∏—Ç–µ —Å–∞ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª–Ω–∞ —Ç–µ–º–∞ –≤ —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ. –í–ª–∞–¥–µ–µ–Ω–µ—Ç–æ –Ω–∞ DFS (–∑–∞ connected components) –∏ BFS (–∑–∞ –Ω–∞–π-–∫—Ä–∞—Ç—ä–∫ –ø—ä—Ç) —â–µ –≤–∏ –æ—Ç–≤–æ—Ä–∏ –≤—Ä–∞—Ç–∏—Ç–µ –∫—ä–º –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∏ –∫–∞—Ç–æ Dijkstra, –î–∏–Ω–∞–º–∏—á–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –≤—ä—Ä—Ö—É –≥—Ä–∞—Ñ–∏ –∏ –¥—Ä—É–≥–∏.