# üìä –ê–Ω–∞–ª–∏–∑ –Ω–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∏. –ë—ä—Ä–∑–æ —Ç—ä—Ä—Å–µ–Ω–µ –∏ –±—ä—Ä–∑–æ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ

## ‚öñÔ∏è –î—ä–ª–±–æ–∫ –∞–Ω–∞–ª–∏–∑ –Ω–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∏

–í —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –Ω–µ –µ –¥–æ—Å—Ç–∞—Ç—ä—á–Ω–æ –ø—Ä–æ—Å—Ç–æ –¥–∞ –Ω–∞–ø–∏—à–µ–º —Ä–∞–±–æ—Ç–µ—â –∫–æ–¥. –¢–æ–π —Ç—Ä—è–±–≤–∞ –¥–∞ —Ä–∞–±–æ—Ç–∏ –≤ —Ä–∞–º–∫–∏—Ç–µ –Ω–∞ –≤—Ä–µ–º–µ–≤–æ—Ç–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ (–æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ 1 —Å–µ–∫—É–Ω–¥–∞). –°—ä–≤—Ä–µ–º–µ–Ω–Ω–∏—Ç–µ —Å—ä–¥–∏–∏ –∏–∑–ø—ä–ª–Ω—è–≤–∞—Ç –æ–∫–æ–ª–æ $10^8$ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ —Å–µ–∫—É–Ω–¥–∞.

### üïí –°–ª–æ–∂–Ω–æ—Å—Ç –ø–æ –≤—Ä–µ–º–µ –∏ –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è (Time Complexity)

–ü–æ–∑–Ω–∞–≤–∞–Ω–µ—Ç–æ –Ω–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è—Ç–∞ –Ω–∞ –≤—Ö–æ–¥–Ω–∏—Ç–µ –¥–∞–Ω–Ω–∏ ($N$) —á–µ—Å—Ç–æ –Ω–∏ –ø–æ–¥—Å–∫–∞–∑–≤–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞—Ç–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç –Ω–∞ —Ä–µ—à–µ–Ω–∏–µ—Ç–æ:

| –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∑–∞ $N$ | –î–æ–ø—É—Å—Ç–∏–º–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç | –¢–∏–ø–∏—á–Ω–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∏ |
| :--- | :--- | :--- |
| $N \le 10$ | $O(N!)$ | –ü—ä–ª–Ω–æ –∏–∑—á–µ—Ä–ø–≤–∞–Ω–µ (Backtracking), –ü–µ—Ä–º—É—Ç–∞—Ü–∏–∏ |
| $N \le 20$ | $O(2^N)$ | –î–ü —Å –±–∏—Ç–æ–≤–∏ –º–∞—Å–∫–∏, Recursion |
| $N \le 500$ | $O(N^3)$ | –§–ª–æ–π–¥-–£–æ—Ä—à–∞–ª, –£–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏, –î–ü |
| $N \le 2000$ | $O(N^2)$ | Bubble/Insertion Sort, –î–ü, BFS/DFS –æ—Ç –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö |
| $N \le 100,000$ | $O(N \log N)$ | Sorting, Heap, Segment Tree, Binary Search |
| $N \le 1,000,000$ | $O(N)$ –∏–ª–∏ $O(N \log N)$ | KMP, Hash, Two Pointers, Union-Find |
| $N \ge 10^{18}$ | $O(\log N)$ –∏–ª–∏ $O(1)$ | –ú–∞—Ç—Ä–∏—á–Ω–æ –ø–æ–≤–¥–∏–≥–∞–Ω–µ, –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ñ–æ—Ä–º—É–ª–∏ |

### üìú Master Theorem (–ó–∞ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∏)
–ó–∞ —Ä–µ–∫—É—Ä—Ä–µ–Ω—Ç–Ω–∞ –≤—Ä—ä–∑–∫–∞ –æ—Ç –≤–∏–¥–∞ $T(n) = a T(n/b) + f(n)$:
1. –ê–∫–æ $f(n) = O(n^c)$ –∏ $c < \log_b a$, —Ç–æ $T(n) = \Theta(n^{\log_b a})$.
2. –ê–∫–æ $f(n) = \Theta(n^c \log^k n)$ –∏ $c = \log_b a$, —Ç–æ $T(n) = \Theta(n^c \log^{k+1} n)$.
3. –ê–∫–æ $f(n) = \Omega(n^c)$ –∏ $c > \log_b a$, —Ç–æ $T(n) = \Theta(f(n))$.

---

## üîç –ë—ä—Ä–∑–æ —Ç—ä—Ä—Å–µ–Ω–µ (–î–≤–æ–∏—á–Ω–æ —Ç—ä—Ä—Å–µ–Ω–µ) - –†–∞–∑—à–∏—Ä–µ–Ω–æ

–î–≤–æ–∏—á–Ω–æ—Ç–æ —Ç—ä—Ä—Å–µ–Ω–µ –Ω–µ –µ —Å–∞–º–æ –∑–∞ –Ω–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ —á–∏—Å–ª–æ –≤ –º–∞—Å–∏–≤. –¢–æ –µ –º–æ—â–µ–Ω –º–µ—Ç–æ–¥ –∑–∞ –Ω–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –æ—Ç–≥–æ–≤–æ—Ä –Ω–∞ –∑–∞–¥–∞—á–∞, –∞–∫–æ –æ—Ç–≥–æ–≤–æ—Ä—ä—Ç –µ –º–æ–Ω–æ—Ç–æ–Ω–µ–Ω.

### 1. –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ –¥–≤–æ–∏—á–Ω–æ —Ç—ä—Ä—Å–µ–Ω–µ (`std::lower_bound`)
–ù–∞–º–∏—Ä–∞ –ø—ä—Ä–≤–∏—è –µ–ª–µ–º–µ–Ω—Ç, –∫–æ–π—Ç–æ –µ $\ge$ –Ω–∞ —Ç—ä—Ä—Å–µ–Ω–∏—è.
```cpp
int lowerBound(const std::vector<int>& arr, int target) {
    int left = 0, right = arr.size(); // –í–Ω–∏–º–∞–≤–∞–π—Ç–µ —Å –≥—Ä–∞–Ω–∏—Ü–∏—Ç–µ [0, N)
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] >= target) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left; // –í—Ä—ä—â–∞ –∏–Ω–¥–µ–∫—Å –∏–ª–∏ N, –∞–∫–æ –Ω—è–º–∞ —Ç–∞–∫—ä–≤
}
```

### 2. –î–≤–æ–∏—á–Ω–æ —Ç—ä—Ä—Å–µ–Ω–µ –ø–æ –æ—Ç–≥–æ–≤–æ—Ä (Binary Search on Answer)
–ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ, –∫–æ–≥–∞—Ç–æ —Ç—ä—Ä—Å–∏–º –º–∏–Ω–∏–º–∞–ª–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç $X$, –∑–∞ –∫–æ—è—Ç–æ —É—Å–ª–æ–≤–∏–µ $P(X)$ –µ –∏–∑–ø—ä–ª–Ω–µ–Ω–æ (–∏ –∑–∞ –≤—Å—è–∫–æ $Y > X$, $P(Y)$ —Å—ä—â–æ –µ –∏–∑–ø—ä–ª–Ω–µ–Ω–æ).

**–ü—Ä–∏–º–µ—Ä**: "–ö–∞–∫–≤–æ –µ –º–∏–Ω–∏–º–∞–ª–Ω–æ—Ç–æ –≤—Ä–µ–º–µ, –∑–∞ –∫–æ–µ—Ç–æ $K$ –º–∞—à–∏–Ω–∏ –º–æ–≥–∞—Ç –¥–∞ –ø—Ä–æ–∏–∑–≤–µ–¥–∞—Ç $M$ –ø—Ä–æ–¥—É–∫—Ç–∞?"
- –§—É–Ω–∫—Ü–∏—è—Ç–∞ `check(time)` –ø—Ä–æ–≤–µ—Ä—è–≤–∞ –¥–∞–ª–∏ –∑–∞ `time` —Å–µ–∫—É–Ω–¥–∏ –º–æ–≥–∞—Ç –¥–∞ —Å–µ –ø—Ä–æ–∏–∑–≤–µ–¥–∞—Ç $\ge M$ –ø—Ä–æ–¥—É–∫—Ç–∞. –¢—è –µ –º–æ–Ω–æ—Ç–æ–Ω–Ω–∞ (–ø–æ–≤–µ—á–µ –≤—Ä–µ–º–µ -> –ø–æ–≤–µ—á–µ –ø—Ä–æ–¥—É–∫—Ç–∏).

```cpp
bool check(long long time, int m, const std::vector<int>& machines) {
    long long products = 0;
    for (int speed : machines) {
        products += time / speed;
        if (products >= m) return true;
    }
    return products >= m;
}

long long solve(int m, std::vector<int>& machines) {
    long long left = 0, right = 1e18; // –î–æ—Å—Ç–∞—Ç—ä—á–Ω–æ –≥–æ–ª—è–º–∞ –≥–æ—Ä–Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞
    long long ans = right;

    while (left <= right) {
        long long mid = left + (right - left) / 2;
        if (check(mid, m, machines)) {
            ans = mid;
            right = mid - 1; // –ü—Ä–æ–±–≤–∞–º–µ –ø–æ-–º–∞–ª–∫–æ –≤—Ä–µ–º–µ
        } else {
            left = mid + 1; // –¢—Ä—è–±–≤–∞ –Ω–∏ –ø–æ–≤–µ—á–µ –≤—Ä–µ–º–µ
        }
    }
    return ans;
}
```

---

## ‚ö° –ê–ª–≥–æ—Ä–∏—Ç–º–∏ –∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ –≤ –¥–µ—Ç–∞–π–ª–∏

### 1. –ë—ä—Ä–∑–æ —Å–æ—Ä—Ç–∏—Ä–∞–Ω–µ (Quick Sort) - –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
–ö–ª–∞—Å–∏—á–µ—Å–∫–∏—è—Ç Quick Sort –º–æ–∂–µ –¥–∞ –¥–µ–≥–µ–Ω–µ—Ä–∏—Ä–∞ –¥–æ $O(N^2)$ –ø—Ä–∏ —Å–æ—Ä—Ç–∏—Ä–∞–Ω –º–∞—Å–∏–≤, –∞–∫–æ –≤–∏–Ω–∞–≥–∏ –∏–∑–±–∏—Ä–∞–º–µ –ø—ä—Ä–≤–∏—è/–ø–æ—Å–ª–µ–¥–Ω–∏—è –µ–ª–µ–º–µ–Ω—Ç –∑–∞ Pivot.

**–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è - Random Pivot**:
–ò–∑–±–∏—Ä–∞–Ω–µ—Ç–æ –Ω–∞ —Å–ª—É—á–∞–µ–Ω –∏–Ω–¥–µ–∫—Å –∑–∞ Pivot –ø—Ä–∞–≤–∏ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—Ç–∞ –∑–∞ –ª–æ—à —Å–ª—É—á–∞–π –∞—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–∏ –º–∞–ª–∫–∞.

```cpp
#include <cstdlib> // –∑–∞ rand()

void quickSort(std::vector<int>& arr, int low, int high) {
    if (low >= high) return;

    // –ò–∑–±–æ—Ä –Ω–∞ —Å–ª—É—á–∞–µ–Ω pivot
    int pivotIndex = low + rand() % (high - low + 1);
    int pivot = arr[pivotIndex];
    std::swap(arr[pivotIndex], arr[high]); // –ú–µ—Å—Ç–∏–º pivot –Ω–∞–π-–æ—Ç–∑–∞–¥

    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    
    quickSort(arr, low, i);
    quickSort(arr, i + 2, high);
}
```

### 2. –°–æ—Ä—Ç–∏—Ä–∞–Ω–µ —á—Ä–µ–∑ —Å–ª–∏–≤–∞–Ω–µ (Merge Sort)
–ó–∞ —Ä–∞–∑–ª–∏–∫–∞ –æ—Ç Quick Sort, Merge Sort **–≤–∏–Ω–∞–≥–∏** —Ä–∞–±–æ—Ç–∏ –∑–∞ $O(N \log N)$ –∏ –µ **—Å—Ç–∞–±–∏–ª–µ–Ω** (–∑–∞–ø–∞–∑–≤–∞ —Ä–µ–¥–∞ –Ω–∞ —Ä–∞–≤–Ω–∏—Ç–µ –µ–ª–µ–º–µ–Ω—Ç–∏). –ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ —á–µ—Å—Ç–æ –∑–∞ –±—Ä–æ–µ–Ω–µ –Ω–∞ –∏–Ω–≤–µ—Ä—Å–∏–∏.

```cpp
void merge(std::vector<int>& arr, int left, int mid, int right) {
    std::vector<int> temp;
    int i = left, j = mid + 1;

    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) temp.push_back(arr[i++]);
        else temp.push_back(arr[j++]);
    }
    while (i <= mid) temp.push_back(arr[i++]);
    while (j <= right) temp.push_back(arr[j++]);

    for (int k = 0; k < temp.size(); k++) arr[left + k] = temp[k];
}

void mergeSort(std::vector<int>& arr, int left, int right) {
    if (left >= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
```

### 3. C++ `std::sort`
–í–≥—Ä–∞–¥–µ–Ω–∞—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è `std::sort` (–≤ `<algorithm>`) –∏–∑–ø–æ–ª–∑–≤–∞ —Ö–∏–±—Ä–∏–¥–µ–Ω –∞–ª–≥–æ—Ä–∏—Ç—ä–º (**Introsort**):
1. –ó–∞–ø–æ—á–≤–∞ —Å Quick Sort.
2. –ê–∫–æ –¥—ä–ª–±–æ—á–∏–Ω–∞—Ç–∞ –Ω–∞ —Ä–µ–∫—É—Ä—Å–∏—è—Ç–∞ —Å—Ç–∞–Ω–µ –ø—Ä–µ–∫–∞–ª–µ–Ω–æ –≥–æ–ª—è–º–∞, –ø—Ä–µ–≤–∫–ª—é—á–≤–∞ –Ω–∞ Heap Sort (–∑–∞ –¥–∞ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞ $O(N \log N)$).
3. –ó–∞ –º–∞–ª–∫–∏ –ø–æ–¥–º–∞—Å–∏–≤–∏ –∏–∑–ø–æ–ª–∑–≤–∞ Insertion Sort (–∑–∞—â–æ—Ç–æ –µ –ø–æ-–±—ä—Ä–∑ –∑–∞ –º–∞–ª–∫–æ $N$).

---

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ –∏ –°—ä–≤–µ—Ç–∏

1. –í–∏–Ω–∞–≥–∏ –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ `std::sort`, –æ—Å–≤–µ–Ω –∞–∫–æ –Ω—è–º–∞—Ç–µ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞ –ø—Ä–∏—á–∏–Ω–∞ (–Ω–∞–ø—Ä. –±—Ä–æ–µ–Ω–µ –Ω–∞ –∏–Ω–≤–µ—Ä—Å–∏–∏ —Å Merge Sort).
2. –ó–∞ –∑–∞–¥–∞—á–∏ —Å —Ç—ä—Ä—Å–µ–Ω–µ –Ω–∞ "–º–∏–Ω–∏–º–∞–ª–Ω–æ—Ç–æ X, –∑–∞ –∫–æ–µ—Ç–æ –µ –∏–∑–ø—ä–ª–Ω–µ–Ω–æ...", –≤–∏–Ω–∞–≥–∏ –º–∏—Å–ª–µ—Ç–µ –∑–∞ **Binary Search on Answer**.
3. –í–Ω–∏–º–∞–≤–∞–π—Ç–µ —Å —Ç–∏–ø–æ–≤–µ—Ç–µ –¥–∞–Ω–Ω–∏ (`long long`) –ø—Ä–∏ –¥–≤–æ–∏—á–Ω–æ—Ç–æ —Ç—ä—Ä—Å–µ–Ω–µ, –∑–∞ –¥–∞ –∏–∑–±–µ–≥–Ω–µ—Ç–µ –ø—Ä–µ–ø—ä–ª–≤–∞–Ω–µ –ø—Ä–∏ `left + right`.