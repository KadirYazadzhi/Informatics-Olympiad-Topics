# üåä –ü–æ—Ç–æ—Ü–∏ –∏ –°—Ä—è–∑–æ–≤–µ: –û—Ç –ù–∞—á–∏–Ω–∞–µ—â–∏ –¥–æ –ï–∫—Å–ø–µ—Ä—Ç–∏

–ü–æ—Ç–æ—Ü–∏—Ç–µ –≤ –º—Ä–µ–∂–∏ (Network Flows) —Å–∞ –µ–¥–∏–Ω –æ—Ç –Ω–∞–π-–º–æ—â–Ω–∏—Ç–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏ –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–∏—á–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ. –¢–µ –º–æ–¥–µ–ª–∏—Ä–∞—Ç —à–∏—Ä–æ–∫ —Å–ø–µ–∫—Ç—ä—Ä –æ—Ç –ø—Ä–æ–±–ª–µ–º–∏: –æ—Ç —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç –Ω–∞ —Å—Ç–æ–∫–∏ –∏ –º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏—è –Ω–∞ –¥–∞–Ω–Ω–∏, –¥–æ —Ä–∞–∑–ø—Ä–µ–¥–µ–ª—è–Ω–µ –Ω–∞ –∑–∞–¥–∞—á–∏ –∏ —Å–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.

## 1. –ú–∞–∫—Å–∏–º–∞–ª–µ–Ω –ü–æ—Ç–æ–∫ (Maximum Flow)

### 1.1. –î–µ—Ñ–∏–Ω–∏—Ü–∏—è
–ù–µ–∫–∞ –∏–º–∞–º–µ –æ—Ä–∏–µ–Ω—Ç–∏—Ä–∞–Ω –≥—Ä–∞—Ñ $G = (V, E)$, –∫—ä–¥–µ—Ç–æ –≤—Å—è–∫–æ —Ä–µ–±—Ä–æ $(u, v)$ –∏–º–∞ –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç $c(u, v) \ge 0$. –ò–º–∞–º–µ –¥–≤–∞ —Å–ø–µ—Ü–∏–∞–ª–Ω–∏ –≤—ä—Ä—Ö–∞:
*   **–ò–∑—Ç–æ—á–Ω–∏–∫ (Source, $S$)**: –í—ä—Ä—Ö—ä—Ç, –æ—Ç –∫–æ–π—Ç–æ –ø–æ—Ç–æ–∫—ä—Ç –∏–∑–≤–∏—Ä–∞.
*   **–û—Ç—Ç–æ–∫ (Sink, $T$)**: –í—ä—Ä—Ö—ä—Ç, –∫—ä–¥–µ—Ç–æ –ø–æ—Ç–æ–∫—ä—Ç —Å–µ –≤–ª–∏–≤–∞.

**–ü–æ—Ç–æ–∫** –µ —Ñ—É–Ω–∫—Ü–∏—è $f(u, v)$, –∫–æ—è—Ç–æ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–≤–∞ –¥–≤–µ —É—Å–ª–æ–≤–∏—è:
1.  **–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç–∞**: $0 \le f(u, v) \le c(u, v)$.
2.  **–ó–∞–ø–∞–∑–≤–∞–Ω–µ –Ω–∞ –ø–æ—Ç–æ–∫–∞**: –ó–∞ –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö $v \in V \setminus \{S, T\}$, —Å—É–º–∞—Ç–∞ –Ω–∞ –≤–ª–∏–∑–∞—â–∏—è –ø–æ—Ç–æ–∫ –µ —Ä–∞–≤–Ω–∞ –Ω–∞ —Å—É–º–∞—Ç–∞ –Ω–∞ –∏–∑–ª–∏–∑–∞—â–∏—è.
    $\sum_{u} f(u, v) = \sum_{w} f(v, w)$

–¶–µ–ª—Ç–∞ –µ –¥–∞ –º–∞–∫—Å–∏–º–∏–∑–∏—Ä–∞–º–µ –æ–±—â–∏—è –ø–æ—Ç–æ–∫, –∏–∑–ª–∏–∑–∞—â –æ—Ç $S$ (–∫–æ–π—Ç–æ –µ —Ä–∞–≤–µ–Ω –Ω–∞ –≤–ª–∏–∑–∞—â–∏—è –≤ $T$). 

### 1.2. –ú–µ—Ç–æ–¥ –Ω–∞ –§–æ—Ä–¥-–§—É–ª–∫–µ—Ä—Å—ä–Ω (Ford-Fulkerson)
–û—Å–Ω–æ–≤–Ω–∞—Ç–∞ –∏–¥–µ—è –µ –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ —É–≤–µ–ª–∏—á–∞–≤–∞–Ω–µ –Ω–∞ –ø–æ—Ç–æ–∫–∞.
1.  –ó–∞–ø–æ—á–≤–∞–º–µ —Å $f(u, v) = 0$ –∑–∞ –≤—Å–∏—á–∫–∏ —Ä–µ–±—Ä–∞.
2.  –¢—ä—Ä—Å–∏–º –ø—ä—Ç –æ—Ç $S$ –¥–æ $T$ –≤ **–æ—Å—Ç–∞—Ç—ä—á–Ω–∏—è –≥—Ä–∞—Ñ** (Residual Graph). –û—Å—Ç–∞—Ç—ä—á–Ω–∏—è—Ç –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç –Ω–∞ —Ä–µ–±—Ä–æ –µ $c_f(u, v) = c(u, v) - f(u, v)$.
    *   –í–∞–∂–Ω–æ: –ê–∫–æ –∏–∑–ø—Ä–∞—Ç–∏–º –ø–æ—Ç–æ–∫ –ø–æ $(u, v)$, –¥–æ–±–∞–≤—è–º–µ "–æ–±—Ä–∞—Ç–Ω–æ —Ä–µ–±—Ä–æ" $(v, u)$ —Å –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç, —Ä–∞–≤–µ–Ω –Ω–∞ –ø–æ—Ç–æ–∫–∞. –¢–æ–≤–∞ –Ω–∏ –ø–æ–∑–≤–æ–ª—è–≤–∞ –¥–∞ "–æ—Ç–º–µ–Ω–∏–º" –ª–æ—à–∏ —Ä–µ—à–µ–Ω–∏—è –ø–æ-–∫—ä—Å–Ω–æ.
3.  –ê–∫–æ –Ω–∞–º–µ—Ä–∏–º —Ç–∞–∫—ä–≤ –ø—ä—Ç (–Ω–∞—Ä–µ—á–µ–Ω **Augmenting Path**), —É–≤–µ–ª–∏—á–∞–≤–∞–º–µ –ø–æ—Ç–æ–∫–∞ –ø–æ –Ω–µ–≥–æ —Å "—Ç—è—Å–Ω–æ—Ç–æ –º—è—Å—Ç–æ" (–º–∏–Ω–∏–º–∞–ª–Ω–∏—è –æ—Å—Ç–∞—Ç—ä—á–µ–Ω –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç –ø–æ –ø—ä—Ç—è).
4.  –ü–æ–≤—Ç–∞—Ä—è–º–µ, –¥–æ–∫–∞—Ç–æ –Ω–µ –º–æ–∂–µ–º –¥–∞ –¥–æ—Å—Ç–∏–≥–Ω–µ–º $T$ –æ—Ç $S$.

### 1.3. –ê–ª–≥–æ—Ä–∏—Ç—ä–º –Ω–∞ –ï–¥–º—ä–Ω–¥—Å-–ö–∞—Ä–ø (Edmonds-Karp)
–¢–æ–≤–∞ –µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞ –§–æ—Ä–¥-–§—É–ª–∫–µ—Ä—Å—ä–Ω, –∫–æ—è—Ç–æ –∏–∑–ø–æ–ª–∑–≤–∞ **BFS** –∑–∞ –Ω–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –Ω–∞–π-–∫—Ä–∞—Ç–∫–∏—è (–∫–∞—Ç–æ –±—Ä–æ–π —Ä–µ–±—Ä–∞) —É–≤–µ–ª–∏—á–∞–≤–∞—â –ø—ä—Ç.
*   –°–ª–æ–∂–Ω–æ—Å—Ç: $O(V E^2)$.
*   –ü–æ–¥—Ö–æ–¥—è—â –∑–∞ –≥—Ä–∞—Ñ–∏ —Å –¥–æ 500-1000 –≤—ä—Ä—Ö–∞.

### 1.4. –ê–ª–≥–æ—Ä–∏—Ç—ä–º –Ω–∞ –î–∏–Ω–∏–∫ (Dinic's Algorithm)
–°—Ç–∞–Ω–¥–∞—Ä—Ç—ä—Ç –∑–∞ —Å—ä—Å—Ç–µ–∑–∞–Ω–∏—è. –¢–æ–π –µ –º–Ω–æ–≥–æ –ø–æ-–±—ä—Ä–∑ –æ—Ç –ï–¥–º—ä–Ω–¥—Å-–ö–∞—Ä–ø.
*   **–ò–¥–µ—è**: –í–º–µ—Å—Ç–æ –¥–∞ –ø—É—Å–∫–∞–º–µ BFS –∑–∞ –≤—Å–µ–∫–∏ –æ—Ç–¥–µ–ª–µ–Ω –ø—ä—Ç, –î–∏–Ω–∏–∫ –∏–∑–ø–æ–ª–∑–≤–∞ BFS, –∑–∞ –¥–∞ –ø–æ—Å—Ç—Ä–æ–∏ **Level Graph** (–≥—Ä–∞—Ñ, —Å—ä–¥—ä—Ä–∂–∞—â —Å–∞–º–æ —Ä–µ–±—Ä–∞, –≤–æ–¥–µ—â–∏ –∫—ä–º –ø–æ-–¥–∞–ª–µ—á–µ–Ω –æ—Ç $S$ –≤—Ä—ä—Ö).
*   –°–ª–µ–¥ —Ç–æ–≤–∞ –ø—É—Å–∫–∞–º–µ **DFS** –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ –≤—ä—Ä—Ö—É Level Graph-–∞, –∑–∞ –¥–∞ –∏–∑–ø—Ä–∞—Ç–∏–º "–±–ª–æ–∫–∏—Ä–∞—â –ø–æ—Ç–æ–∫" (–Ω—è–∫–æ–ª–∫–æ –ø—ä—Ç—è –µ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ).
*   –°–ª–æ–∂–Ω–æ—Å—Ç: $O(V^2 E)$ –≤ –æ–±—â–∏—è —Å–ª—É—á–∞–π.
*   –ó–∞ –º—Ä–µ–∂–∏ —Å –µ–¥–∏–Ω–∏—á–Ω–∏ –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç–∏ (–Ω–∞–ø—Ä. –ø–∞—Ä–æ—Å—É—á–µ—Ç–∞–Ω–∏—è): $O(E \sqrt{V})$.

```cpp
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

const long long INF = 1e18;

struct Edge {
    int v;
    long long cap, flow;
    int rev; // –∏–Ω–¥–µ–∫—Å –Ω–∞ –æ–±—Ä–∞—Ç–Ω–æ—Ç–æ —Ä–µ–±—Ä–æ –≤ adj[v]
};

struct Dinic {
    int n;
    vector<vector<Edge>> adj;
    vector<int> level; // —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –æ—Ç S (BFS)
    vector<int> ptr;   // —Ç–µ–∫—É—â –∏–Ω–¥–µ–∫—Å –≤ adj –∑–∞ DFS (–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è)

    Dinic(int n) : n(n), adj(n), level(n), ptr(n) {}

    void add_edge(int u, int v, long long cap) {
        Edge a = {v, cap, 0, (int)adj[v].size()};
        Edge b = {u, 0, 0, (int)adj[u].size()}; // –û–±—Ä–∞—Ç–Ω–æ —Ä–µ–±—Ä–æ —Å 0 –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç
        adj[u].push_back(a);
        adj[v].push_back(b);
    }

    bool bfs(int s, int t) {
        fill(level.begin(), level.end(), -1);
        level[s] = 0;
        queue<int> q;
        q.push(s);
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (auto& e : adj[u]) {
                if (e.cap - e.flow > 0 && level[e.v] == -1) {
                    level[e.v] = level[u] + 1;
                    q.push(e.v);
                }
            }
        }
        return level[t] != -1;
    }

    long long dfs(int u, int t, long long pushed) {
        if (pushed == 0 || u == t) return pushed;
        for (int& cid = ptr[u]; cid < adj[u].size(); ++cid) {
            auto& e = adj[u][cid];
            if (level[u] + 1 != level[e.v] || e.cap - e.flow == 0) continue;
            long long tr = dfs(e.v, t, min(pushed, e.cap - e.flow));
            if (tr == 0) continue;
            e.flow += tr;
            adj[e.v][e.rev].flow -= tr;
            return tr;
        }
        return 0;
    }

    long long max_flow(int s, int t) {
        long long flow = 0;
        while (bfs(s, t)) {
            fill(ptr.begin(), ptr.end(), 0);
            while (long long pushed = dfs(s, t, INF)) {
                flow += pushed;
            }
        }
        return flow;
    }
};
```

---

## 2. –¢–µ–æ—Ä–µ–º–∞ –∑–∞ –ú–∞–∫—Å–∏–º–∞–ª–µ–Ω –ü–æ—Ç–æ–∫ –∏ –ú–∏–Ω–∏–º–∞–ª–µ–Ω –°—Ä–µ–∑ (Max-Flow Min-Cut)

–ï–¥–∏–Ω **s-t —Å—Ä–µ–∑** (cut) –µ —Ä–∞–∑–¥–µ–ª—è–Ω–µ –Ω–∞ –≤—ä—Ä—Ö–æ–≤–µ—Ç–µ –Ω–∞ –¥–≤–µ –º–Ω–æ–∂–µ—Å—Ç–≤–∞: $A$ (—Å—ä–¥—ä—Ä–∂–∞—â–æ $S$) –∏ $B$ (—Å—ä–¥—ä—Ä–∂–∞—â–æ $T$). –ö–∞–ø–∞—Ü–∏—Ç–µ—Ç—ä—Ç –Ω–∞ —Å—Ä–µ–∑–∞ –µ —Å—É–º–∞—Ç–∞ –æ—Ç –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç–∏—Ç–µ –Ω–∞ —Ä–µ–±—Ä–∞—Ç–∞, –æ—Ç–∏–≤–∞—â–∏ –æ—Ç $A$ –∫—ä–º $B$.

**–¢–µ–æ—Ä–µ–º–∞**: –°—Ç–æ–π–Ω–æ—Å—Ç—Ç–∞ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª–Ω–∏—è –ø–æ—Ç–æ–∫ –µ —Ä–∞–≤–Ω–∞ –Ω–∞ –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç–∞ –Ω–∞ –º–∏–Ω–∏–º–∞–ª–Ω–∏—è —Å—Ä–µ–∑.

### –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ: –ò–∑–±–æ—Ä –Ω–∞ –ø—Ä–æ–µ–∫—Ç–∏ (Project Selection Problem)
–ò–º–∞–º–µ –Ω–∞–±–æ—Ä –æ—Ç –ø—Ä–æ–µ–∫—Ç–∏ (–Ω–æ—Å—è—Ç –ø–µ—á–∞–ª–±–∞) –∏ –Ω–∞–±–æ—Ä –æ—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏/—Ä–µ—Å—É—Ä—Å–∏ (—Å—Ç—Ä—É–≤–∞—Ç –ø–∞—Ä–∏). –í—Å–µ–∫–∏ –ø—Ä–æ–µ–∫—Ç –∑–∞–≤–∏—Å–∏ –æ—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏. –ò—Å–∫–∞–º–µ –¥–∞ –∏–∑–±–µ—Ä–µ–º –ø—Ä–æ–µ–∫—Ç–∏ –∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏, —Ç–∞–∫–∞ —á–µ –ø–µ—á–∞–ª–±–∞—Ç–∞ –º–∏–Ω—É—Å —Ä–∞–∑—Ö–æ–¥–∏—Ç–µ –¥–∞ –µ –º–∞–∫—Å–∏–º–∞–ª–Ω–∞.

**–†–µ—à–µ–Ω–∏–µ —Å Min-Cut**:
1.  –°—ä–∑–¥–∞–≤–∞–º–µ –∏–∑—Ç–æ—á–Ω–∏–∫ $S$ –∏ —Å–≤—ä—Ä–∑–≤–∞–º–µ $S$ –∫—ä–º –≤—Å–∏—á–∫–∏ –ø—Ä–æ–µ–∫—Ç–∏ —Å –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç = –ø–µ—á–∞–ª–±–∞—Ç–∞.
2.  –°—ä–∑–¥–∞–≤–∞–º–µ –æ—Ç—Ç–æ–∫ $T$ –∏ —Å–≤—ä—Ä–∑–≤–∞–º–µ –≤—Å–∏—á–∫–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏ –∫—ä–º $T$ —Å –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç = —Ü–µ–Ω–∞—Ç–∞.
3.  –ê–∫–æ –ø—Ä–æ–µ–∫—Ç $P$ –∏–∑–∏—Å–∫–≤–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç $I$, –¥–æ–±–∞–≤—è–º–µ —Ä–µ–±—Ä–æ $P \to I$ —Å –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç $\infty$.
4.  –ú–∏–Ω–∏–º–∞–ª–Ω–∏—è—Ç —Å—Ä–µ–∑ –≤ —Ç–æ–∑–∏ –≥—Ä–∞—Ñ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–≤–∞ –º–∏–Ω–∏–º–∞–ª–Ω–∞—Ç–∞ –∑–∞–≥—É–±–∞ (–Ω–µ—Ä–µ–∞–ª–∏–∑–∏—Ä–∞–Ω–∞ –ø–µ—á–∞–ª–±–∞ + –ø–ª–∞—Ç–µ–Ω–∏ —Ä–∞–∑—Ö–æ–¥–∏).
5.  –û—Ç–≥–æ–≤–æ—Ä = (–°—É–º–∞ –Ω–∞ –≤—Å–∏—á–∫–∏ –≤—ä–∑–º–æ–∂–Ω–∏ –ø–µ—á–∞–ª–±–∏) - Max Flow.

---

## 3. –ü–∞—Ä–æ—Å—É—á–µ—Ç–∞–Ω–∏—è –≤ –î–≤—É–¥–µ–ª–µ–Ω –ì—Ä–∞—Ñ (Bipartite Matching)

–ó–∞–¥–∞—á–∞—Ç–∞ –∑–∞ –Ω–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª–µ–Ω –±—Ä–æ–π –¥–≤–æ–π–∫–∏ –≤ –¥–≤—É–¥–µ–ª–µ–Ω –≥—Ä–∞—Ñ –º–æ–∂–µ –¥–∏—Ä–µ–∫—Ç–Ω–æ –¥–∞ —Å–µ —Ä–µ—à–∏ —Å –ú–∞–∫—Å–∏–º–∞–ª–µ–Ω –ü–æ—Ç–æ–∫.
1.  –î–æ–±–∞–≤—è–º–µ $S$ –∏ $T$.
2.  –°–≤—ä—Ä–∑–≤–∞–º–µ $S$ –∫—ä–º –≤—Å–∏—á–∫–∏ –≤—ä—Ä—Ö–æ–≤–µ –æ—Ç –ª—è–≤–∞—Ç–∞ —á–∞—Å—Ç —Å –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç 1.
3.  –°–≤—ä—Ä–∑–≤–∞–º–µ –≤—Å–∏—á–∫–∏ –≤—ä—Ä—Ö–æ–≤–µ –æ—Ç –¥—è—Å–Ω–∞—Ç–∞ —á–∞—Å—Ç –∫—ä–º $T$ —Å –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç 1.
4.  –í—Å–∏—á–∫–∏ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞—â–∏ —Ä–µ–±—Ä–∞ –Ω–∞—Å–æ—á–≤–∞–º–µ –æ—Ç –ª—è–≤–æ –Ω–∞ –¥—è—Å–Ω–æ —Å –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç 1 (–∏–ª–∏ $\infty$).
5.  Max Flow = Max Matching.

–° –î–∏–Ω–∏–∫ —Ç–æ–≤–∞ —Ä–∞–±–æ—Ç–∏ –∑–∞ $O(E \sqrt{V})$, –∫–æ–µ—Ç–æ –µ –µ–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ –Ω–∞ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–∏—è –∞–ª–≥–æ—Ä–∏—Ç—ä–º –Ω–∞ –•–æ–ø–∫—Ä–æ—Ñ—Ç-–ö–∞—Ä–ø (Hopcroft-Karp).

---

## 4. –ü–æ—Ç–æ—Ü–∏ —Å –ò–∑–∏—Å–∫–≤–∞–Ω–∏—è (Flows with Demands)

–ü–æ–Ω—è–∫–æ–≥–∞ —Ä–µ–±—Ä–∞—Ç–∞ –∏–º–∞—Ç –Ω–µ —Å–∞–º–æ –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç $C_{max}$, –Ω–æ –∏ –¥–æ–ª–Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞ $L_{min}$ (—Ç.–µ. –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ —Ç—Ä—è–±–≤–∞ –¥–∞ –º–∏–Ω–µ –ø–æ–Ω–µ —Ç–æ–ª–∫–æ–≤–∞ –ø–æ—Ç–æ–∫).

### 4.1. –î–æ–ø—É—Å—Ç–∏–º–∞ —Ü–∏—Ä–∫—É–ª–∞—Ü–∏—è
–ó–∞ –¥–∞ —Ä–µ—à–∏–º —Ç–æ–≤–∞:
1.  –ó–∞ –≤—Å—è–∫–æ —Ä–µ–±—Ä–æ $(u, v)$ —Å –≥—Ä–∞–Ω–∏—Ü–∏ $[L, R]$, –∑–∞–º–µ–Ω—è–º–µ –≥–æ —Å —Ä–µ–±—Ä–æ —Å –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç $R - L$.
2.  –°—ä–∑–¥–∞–≤–∞–º–µ –º–∞—Å–∏–≤ `balance` –∑–∞ –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö. –ó–∞ –≤—Å—è–∫–æ —Ä–µ–±—Ä–æ $(u, v)$ —Å –¥–æ–ª–Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞ $L$, "–≤–∑–∏–º–∞–º–µ" $L$ –æ—Ç $u$ (`balance[u] -= L`) –∏ –≥–æ "–¥–∞–≤–∞–º–µ" –Ω–∞ $v$ (`balance[v] += L`).
3.  –°—ä–∑–¥–∞–≤–∞–º–µ –Ω–æ–≤–∏ —Å—É–ø–µ—Ä-–∏–∑—Ç–æ—á–Ω–∏–∫ $SS$ –∏ —Å—É–ø–µ—Ä-–æ—Ç—Ç–æ–∫ $TT$.
    *   –ê–∫–æ `balance[v] > 0`, –¥–æ–±–∞–≤—è–º–µ —Ä–µ–±—Ä–æ $SS \to v$ —Å –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç `balance[v]`.
    *   –ê–∫–æ `balance[v] < 0`, –¥–æ–±–∞–≤—è–º–µ —Ä–µ–±—Ä–æ $v \to TT$ —Å –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç `-balance[v]`.
4.  –ü—É—Å–∫–∞–º–µ Max Flow –æ—Ç $SS$ –¥–æ $TT$. –ê–∫–æ –≤—Å–∏—á–∫–∏ —Ä–µ–±—Ä–∞, –∏–∑–ª–∏–∑–∞—â–∏ –æ—Ç $SS$, —Å–∞ –Ω–∞—Å–∏—Ç–µ–Ω–∏ (flow == capacity), —Ç–æ –¥–æ–ø—É—Å—Ç–∏–º–∞ —Ü–∏—Ä–∫—É–ª–∞—Ü–∏—è —Å—ä—â–µ—Å—Ç–≤—É–≤–∞.

---

## 5. Min-Cost Max-Flow

–ê–∫–æ –≤—Å—è–∫–æ —Ä–µ–±—Ä–æ –∏–º–∞ –∏ "—Ü–µ–Ω–∞" (cost) –∑–∞ –µ–¥–∏–Ω–∏—Ü–∞ –ø–æ—Ç–æ–∫, –∑–∞–¥–∞—á–∞—Ç–∞ —Å—Ç–∞–≤–∞ –ø–æ-—Å–ª–æ–∂–Ω–∞. –¢—ä—Ä—Å–∏–º –º–∞–∫—Å–∏–º–∞–ª–µ–Ω –ø–æ—Ç–æ–∫ —Å –º–∏–Ω–∏–º–∞–ª–Ω–∞ –æ–±—â–∞ —Ü–µ–Ω–∞.
–¢–æ–≤–∞ –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Å–µ —Ä–µ—à–∞–≤–∞ —á—Ä–µ–∑ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è –Ω–∞ –ï–¥–º—ä–Ω–¥—Å-–ö–∞—Ä–ø, –∫—ä–¥–µ—Ç–æ –≤–º–µ—Å—Ç–æ BFS –∏–∑–ø–æ–ª–∑–≤–∞–º–µ **SPFA** (Shortest Path Faster Algorithm) –∏–ª–∏ **Dijkstra —Å –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª–∏** (–∑–∞ –¥–∞ —Å–µ —Å–ø—Ä–∞–≤–∏–º —Å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª–Ω–∏ —Ä—ä–±–æ–≤–µ), –∑–∞ –¥–∞ –Ω–∞–º–∏—Ä–∞–º–µ –Ω–∞–π-–µ–≤—Ç–∏–Ω–∏—è –ø—ä—Ç –≤ –æ—Å—Ç–∞—Ç—ä—á–Ω–∏—è –≥—Ä–∞—Ñ.

## 6. –ó–∞–¥–∞—á–∏ –∑–∞ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ
1.  **SPOJ FASTFLOW**: –¢–µ—Å—Ç –∑–∞ –±—ä—Ä–∑–∏–Ω–∞—Ç–∞ –Ω–∞ –≤–∞—à–∏—è Dinic.
2.  **CSES Download Speed**: –ö–ª–∞—Å–∏—á–µ—Å–∫–∏ Max Flow.
3.  **CSES Police Chase**: –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ —Ä–µ–±—Ä–∞—Ç–∞ –Ω–∞ Min-Cut.
4.  **Codeforces 1082G**: Petya and Graph (Project Selection).
5.  **UVa 10330**: Power Transmission (–ü–æ—Ç–æ—Ü–∏ —Å –∫–∞–ø–∞—Ü–∏—Ç–µ—Ç–∏ –Ω–∞ –≤—ä—Ä—Ö–æ–≤–µ—Ç–µ - —Ä–∞–∑–¥–µ–ª—è–º–µ –≤—ä—Ä—Ö–∞ –Ω–∞ $v_{in}$ –∏ $v_{out}$). 

–£—Å–ø–µ—Ö —Å –ø–æ—Ç–æ—Ü–∏—Ç–µ! –í–µ–¥–Ω—ä–∂ —â–æ–º —Ä–∞–∑–±–µ—Ä–µ—Ç–µ –∫–∞–∫ –¥–∞ –º–æ–¥–µ–ª–∏—Ä–∞—Ç–µ –∑–∞–¥–∞—á–∞—Ç–∞ –∫–∞—Ç–æ –≥—Ä–∞—Ñ, —Ä–µ—à–µ–Ω–∏–µ—Ç–æ —á–µ—Å—Ç–æ –µ —Å–∞–º–æ –µ–¥–∏–Ω —à–∞–±–ª–æ–Ω –Ω–∞ –î–∏–Ω–∏–∫.
