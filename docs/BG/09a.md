# üßÆ –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ –î—ä–ª–≥–∏ –ß–∏—Å–ª–∞ (BigInt)

–í C++ –Ω–∞–π-–≥–æ–ª–µ–º–∏—è—Ç —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω —Ç–∏–ø `unsigned long long` –ø–æ–¥–¥—ä—Ä–∂–∞ —á–∏—Å–ª–∞ –¥–æ $\approx 1.8 \times 10^{19}$. –ú–Ω–æ–≥–æ –∑–∞–¥–∞—á–∏ –æ–±–∞—á–µ –∏–∑–∏—Å–∫–≤–∞—Ç —Ä–∞–±–æ—Ç–∞ —Å —á–∏—Å–ª–∞ —Å—ä—Å —Å—Ç–æ—Ç–∏—Ü–∏ –∏–ª–∏ —Ö–∏–ª—è–¥–∏ —Ü–∏—Ñ—Ä–∏. –ó–∞ —Ä–∞–∑–ª–∏–∫–∞ –æ—Ç Python –∏ Java, C++ –Ω—è–º–∞ –≤–≥—Ä–∞–¥–µ–Ω–∞ –ø–æ–¥–¥—Ä—ä–∂–∫–∞ –∑–∞ BigInteger, —Ç–∞–∫–∞ —á–µ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–∏ —è –Ω–∞–ø–∏—à–µ–º —Å–∞–º–∏.

## 1. –°—Ç—Ä–∞—Ç–µ–≥–∏—è –∑–∞ —Å—ä—Ö—Ä–∞–Ω–µ–Ω–∏–µ

–ù–∞–π-–µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏—è—Ç –Ω–∞—á–∏–Ω –µ –¥–∞ —Å—ä—Ö—Ä–∞–Ω—è–≤–∞–º–µ —á–∏—Å–ª–æ—Ç–æ –≤ `std::vector<int>`, –Ω–æ –Ω–µ —Ü–∏—Ñ—Ä–∞ –ø–æ —Ü–∏—Ñ—Ä–∞ (–±–∞–∑–∞ 10), –∞ –≥—Ä—É–ø–∏—Ä–∞–π–∫–∏ –≥–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä –ø–æ 9 —Ü–∏—Ñ—Ä–∏ (–±–∞–∑–∞ $10^9$). 
*   –ë–∞–∑–∞ $10^9$ —Å–µ –ø–æ–±–∏—Ä–∞ –≤ `int`.
*   –£–º–Ω–æ–∂–µ–Ω–∏–µ—Ç–æ –Ω–∞ –¥–≤–µ "—Ü–∏—Ñ—Ä–∏" (–¥–æ $10^{18}$) —Å–µ –ø–æ–±–∏—Ä–∞ –≤ `long long`.
*   –ù–∞–º–∞–ª—è–≤–∞ –±—Ä–æ—è –Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏–∏—Ç–µ 9 –ø—ä—Ç–∏ —Å–ø—Ä—è–º–æ –±–∞–∑–∞ 10.

–í–µ–∫—Ç–æ—Ä—ä—Ç –ø–∞–∑–∏ —Ü–∏—Ñ—Ä–∏—Ç–µ –≤ **–æ–±—Ä–∞—Ç–µ–Ω —Ä–µ–¥** (–Ω–∞–π-–º–ª–∞–¥—à–∏—Ç–µ —Å–∞ –Ω–∞ –∏–Ω–¥–µ–∫—Å 0), –∑–∞ –¥–∞ –º–æ–∂–µ –ª–µ—Å–Ω–æ –¥–∞ —Å–µ —Ä–∞–∑—à–∏—Ä—è–≤–∞.

## 2. –ü—ä–ª–Ω–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è (Template)

–ï—Ç–æ –µ–¥–Ω–∞ –∫–æ–º–ø–∞–∫—Ç–Ω–∞, –Ω–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, –∫–æ—è—Ç–æ –º–æ–∂–µ—Ç–µ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞—Ç–µ –≤ —Å—ä—Å—Ç–µ–∑–∞–Ω–∏—è:

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <iomanip>

using namespace std;

const int BASE = 1e9;

struct BigInt {
    vector<int> digits;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∏
    BigInt() {}
    BigInt(long long v) {
        if (v == 0) digits.push_back(0);
        while (v > 0) {
            digits.push_back(v % BASE);
            v /= BASE;
        }
    }
    BigInt(string s) {
        for (int i = (int)s.length(); i > 0; i -= 9) {
            if (i < 9) digits.push_back(stoi(s.substr(0, i)));
            else digits.push_back(stoi(s.substr(i - 9, 9)));
        }
        trim();
    }

    void trim() {
        while (digits.size() > 1 && digits.back() == 0) 
            digits.pop_back();
    }

    // –û–ø–µ—Ä–∞—Ç–æ—Ä–∏ –∑–∞ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
    bool operator<(const BigInt &other) const {
        if (digits.size() != other.digits.size()) 
            return digits.size() < other.digits.size();
        for (int i = digits.size() - 1; i >= 0; i--)
            if (digits[i] != other.digits[i]) 
                return digits[i] < other.digits[i];
        return false;
    }
    
    bool operator>(const BigInt &other) const { return other < *this; }
    bool operator==(const BigInt &other) const { return !(*this < other) && !(other < *this); }

    // –°—ä–±–∏—Ä–∞–Ω–µ
    BigInt operator+(const BigInt &other) const {
        BigInt res = *this;
        int carry = 0;
        for (size_t i = 0; i < max(res.digits.size(), other.digits.size()) || carry; ++i) {
            if (i == res.digits.size()) res.digits.push_back(0);
            long long current = res.digits[i] + carry + (i < other.digits.size() ? other.digits[i] : 0);
            res.digits[i] = current % BASE;
            carry = current / BASE;
        }
        return res;
    }

    // –£–º–Ω–æ–∂–µ–Ω–∏–µ —Å –∫—ä—Å–æ —á–∏—Å–ª–æ (int)
    BigInt operator*(int v) const {
        if (v == 0) return BigInt(0);
        BigInt res = *this;
        long long carry = 0;
        for (size_t i = 0; i < res.digits.size() || carry; ++i) {
            if (i == res.digits.size()) res.digits.push_back(0);
            long long cur = carry + (long long)res.digits[i] * v;
            res.digits[i] = cur % BASE;
            carry = cur / BASE;
        }
        res.trim();
        return res;
    }
    
    // –£–º–Ω–æ–∂–µ–Ω–∏–µ —Å BigInt (School method O(N*M))
    BigInt operator*(const BigInt &other) const {
        BigInt res;
        res.digits.resize(digits.size() + other.digits.size(), 0);
        for (size_t i = 0; i < digits.size(); ++i) {
            long long carry = 0;
            for (size_t j = 0; j < other.digits.size() || carry; ++j) {
                long long cur = res.digits[i+j] + (long long)digits[i] * (j < other.digits.size() ? other.digits[j] : 0) + carry;
                res.digits[i+j] = cur % BASE;
                carry = cur / BASE;
            }
        }
        res.trim();
        return res;
    }

    // –ò–∑—Ö–æ–¥
    friend ostream& operator<<(ostream &os, const BigInt &bi) {
        if (bi.digits.empty()) { os << 0; return os; }
        os << bi.digits.back();
        for (int i = bi.digits.size() - 2; i >= 0; i--) {
            os << setfill('0') << setw(9) << bi.digits[i];
        }
        return os;
    }
};
```

## 3. Python –∏–ª–∏ Java?

–ê–∫–æ –∑–∞–¥–∞—á–∞—Ç–∞ –ø–æ–∑–≤–æ–ª—è–≤–∞ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ—Ç–æ –Ω–∞ –¥—Ä—É–≥–∏ –µ–∑–∏—Ü–∏ –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ—Ç–æ –∑–∞ –≤—Ä–µ–º–µ –Ω–µ –µ —Ç–≤—ä—Ä–¥–µ —Å—Ç—Ä–æ–≥–æ (Python –µ –ø–æ-–±–∞–≤–µ–Ω), —á–µ—Å—Ç–æ –µ –ø–æ-–ª–µ—Å–Ω–æ –ø—Ä–æ—Å—Ç–æ –¥–∞ –ø—Ä–µ–≤–∫–ª—é—á–∏—Ç–µ –µ–∑–∏–∫–∞.
–í Python `int` –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–æ–¥–¥—ä—Ä–∂–∞ –ø—Ä–æ–∏–∑–≤–æ–ª–Ω–∞ —Ç–æ—á–Ω–æ—Å—Ç.

**Python –ø—Ä–∏–º–µ—Ä:**
```python
a = int(input())
b = int(input())
print(a * b)
```

## 4. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

1.  **–ö–∞—Ä–∞—Ü—É–±–∞ (Karatsuba)**: –ó–∞ –º–Ω–æ–≥–æ –≥–æ–ª–µ–º–∏ —á–∏—Å–ª–∞ (–Ω–∞–ø—Ä. –Ω–∞–¥ 2000-3000 —Ü–∏—Ñ—Ä–∏) —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ—Ç–æ —É–º–Ω–æ–∂–µ–Ω–∏–µ $O(N^2)$ –µ –±–∞–≤–Ω–æ. –ê–ª–≥–æ—Ä–∏—Ç—ä–º—ä—Ç –Ω–∞ –ö–∞—Ä–∞—Ü—É–±–∞ —Ä–∞–±–æ—Ç–∏ –∑–∞ $O(N^{\log_2 3}) \approx O(N^{1.58})$.
2.  **FFT (Fast Fourier Transform)**: –ó–∞ –µ–∫—Å—Ç—Ä–µ–º–Ω–æ –≥–æ–ª–µ–º–∏ —á–∏—Å–ª–∞ ($10^5$ —Ü–∏—Ñ—Ä–∏), —É–º–Ω–æ–∂–µ–Ω–∏–µ—Ç–æ —Å—Ç–∞–≤–∞ –∑–∞ $O(N \log N)$ (–≤–∏–∂ –¢–µ–º–∞ 44).

## 5. –ó–∞–¥–∞—á–∏
1.  **UVa 10106 - Product**: –ü—Ä–æ—Å—Ç–æ —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –¥–≤–µ –≥–æ–ª–µ–º–∏ —á–∏—Å–ª–∞.
2.  **SPOJ JULKA**: –°—ä–±–∏—Ä–∞–Ω–µ –∏ –∏–∑–≤–∞–∂–¥–∞–Ω–µ / –¥–µ–ª–µ–Ω–∏–µ –Ω–∞ 2.
3.  **Codeforces 1042D**: –ú–æ–∂–µ –¥–∞ —Å–µ –Ω–∞–ª–æ–∂–∏ BigInt –∑–∞ –º–µ–∂–¥–∏–Ω–Ω–∏ —Å–º–µ—Ç–∫–∏.
