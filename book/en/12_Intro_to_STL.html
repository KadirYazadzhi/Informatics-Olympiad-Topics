<html><head><meta charset='utf-8'><style>:root { --bg: #fff; --txt: #24292e; --side: #f6f8fa; --brd: #e1e4e8; --lnk: #0366d6; } [data-theme="dark"] { --bg: #0d1117; --txt: #c9d1d9; --side: #161b22; --brd: #30363d; --lnk: #58a6ff; } body { font-family: sans-serif; margin: 0; display: flex; height: 100vh; background: var(--bg); color: var(--txt); } .sidebar { width: 280px; background: var(--side); border-right: 1px solid var(--brd); overflow-y: auto; flex-shrink: 0; padding: 15px; } .main { flex-grow: 1; overflow-y: auto; padding: 40px; } details { margin-bottom: 8px; } summary { cursor: pointer; font-weight: bold; padding: 5px; } .items a { display: block; padding: 4px 15px; font-size: 0.9em; color: var(--txt); } .active { background: var(--lnk); color: #fff !important; border-radius: 4px; } .top { display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 20px; }</style></head><body><div class='sidebar'><h3>Informatics Topics</h3><details open><summary>I. Fundamentals</summary><div class="items"><a href="01_Cpp_Environment_Data_Types_IO.html" class="">1.. ğŸ–¥ï¸ **C++ Programming Environment. Simple Data Types. Input and Output.**</a><a href="02_Operations_Conditionals.html" class="">2.. â• **Operations in C++. Conditional Operators. Compound Operator.**</a><a href="03_Loops_Functions_Strings.html" class="">3.. ğŸ”„ **Loops. Nested Loops. Functions in C++. Strings.**</a><a href="04_Basic_Divisibility_Tasks.html" class="">4.. ğŸ”¢ **Basic Tasks Related to Number Divisibility.**</a><a href="05_Date_and_Time_Tasks.html" class="">5.. ğŸ“… **Tasks Related to Dates and Time.**</a></div></details><details open><summary>II. Arrays & Math</summary><div class="items"><a href="06_One_Dimensional_Array.html" class="">6.. ğŸ“‚ **One-dimensional Arrays.**</a><a href="07_Arrays_Basic_Tasks.html" class="">7.. ğŸ“‚ **One-dimensional Arrays and Basic Tasks.**</a><a href="07a_Sorting_and_Strings.html" class="">7.1.. ğŸ” **Introduction to sorting algorithms.**</a><a href="07a_Sorting_and_Strings.html" class="">7.2.. ğŸ“ **String manipulation and searching.**</a><a href="08_Number_Divisibility_Euclidean_Algorithm.html" class="">8.. â— **Number Divisibility, Euclidean Algorithm and Applications.**</a><a href="08_Number_Divisibility_Euclidean_Algorithm.html" class="">8.1.. ğŸ§® **Calculation with common fractions.**</a><a href="08_Number_Divisibility_Euclidean_Algorithm.html" class="">8.2.. ğŸ§µ **Prime numbers and Sieve of Eratosthenes.**</a><a href="09_Numeral_Systems.html" class="">9.. ğŸ”¢ **Numeral Systems.**</a><a href="09a_BigInt_and_Random.html" class="">9.1.. ğŸ§® **BigInt and Long Numbers.**</a><a href="09a_BigInt_and_Random.html" class="">9.2.. ğŸ² **Random numbers.**</a><a href="10_Two_Dimensional_Arrays.html" class="">10.. ğŸ“Š **Two-dimensional Arrays and Tabular Data Processing.**</a></div></details><details open><summary>III. Algorithms</summary><div class="items"><a href="11_Basic_Computational_Geometry.html" class="">11.. ğŸ§­ **Basic Knowledge of Computational Geometry.**</a><a href="12_Intro_to_STL.html" class="active">12.. ğŸ“š **Introduction to STL and Sorting/Searching Tools.**</a><a href="13_Data_Structures_Stack_Queue.html" class="">13.. ğŸ“¦ **Data Structures: Stack and Queue.**</a><a href="14_Recursion.html" class="">14.. ğŸ” **Concept of Recursion.**</a><a href="15_Intro_to_Combinatorics.html" class="">15.. ğŸ”€ **Introduction to Combinatorial Configurations.**</a></div></details><details open><summary>IV. Advanced Basics</summary><div class="items"><a href="16_Graph_Concept.html" class="">16.. ğŸŒ **Concept of a Graph.**</a><a href="17_STL_Containers_Iterators_Algorithms.html" class="">17.. ğŸ“š **STL Containers and Algorithms.**</a><a href="18_Algorithm_Analysis_Quick_Search_Sort.html" class="">18.. ğŸ“Š **Algorithm Analysis. Fast Search and Fast Sort.**</a><a href="19_Modular_Arithmetic.html" class="">19.. â• **Modular Arithmetic.**</a><a href="20_Polynomials_BigInt.html" class="">20.. ğŸ“ˆ **Polynomials. Implementation of Long Number Operations.**</a></div></details><details open><summary>V. Intermediate</summary><div class="items"><a href="21_Game_Theory.html" class="">21.. ğŸ® **Game Theory: Strategies and Analysis.**</a><a href="22_Bitwise_Operations.html" class="">22.. ğŸ’» **Bitwise Operations and Applications.**</a><a href="23_Dynamic_Programming.html" class="">23.. ğŸ”„ **Dynamic Programming: Advanced Techniques.**</a><a href="24_Graph_Algorithms.html" class="">24.. ğŸŒ **Graph Algorithms: Advanced Methods.**</a><a href="25_Union_Find.html" class="">25.. ğŸ”— **Union-Find (DSU): Advanced Techniques.**</a></div></details><details open><summary>VI. Structures</summary><div class="items"><a href="26_Tree_Structures.html" class="">26.. ğŸŒ² **Tree Data Structures: Expert Level.**</a><a href="27_Advanced_Geometry_SweepLine.html" class="">27.. ğŸ“ **Computational Geometry: Basics and Vectors.**</a><a href="28_Advanced_Combinatorics.html" class="">28.. ğŸ”€ **Advanced Combinatorics: Generation and Coding.**</a><a href="29_Arithmetic_Expressions.html" class="">29.. â— **Arithmetic Expressions: Parsing and Evaluation.**</a><a href="30_Hashing.html" class="">30.. ğŸ”‘ **Hashing: Expert Techniques.**</a></div></details><details open><summary>VII. Expert I</summary><div class="items"><a href="31_Special_Number_Sequences.html" class="">31.. â• **Special Number Sequences: Deep Theory.**</a><a href="32_Geometry_Polygons.html" class="">32.. ğŸ“ **Geometry: Polygons and Lattices.**</a><a href="33_Advanced_Graph_Algorithms.html" class="">33.. ğŸŒ **Advanced Graphs: Deep Theory.**</a><a href="34_Advanced_Data_Structures.html" class="">34.. ğŸ“‚ **Advanced Data Structures: Expert Level.**</a><a href="35_Advanced_DP.html" class="">35.. ğŸ”„ **Dynamic Programming: Expert Optimizations.**</a></div></details><details open><summary>VIII. Expert II</summary><div class="items"><a href="36_String_Algorithms.html" class="">36.. ğŸ“ **String Algorithms: Expert Level.**</a><a href="37_Advanced_Game_Theory.html" class="">37.. ğŸ® **Game Theory: Expert Games.**</a><a href="38_Matrices.html" class="">38.. ğŸ“Š **Matrices: Theorems and Applications.**</a><a href="39_Voronoi_Diagrams.html" class="">39.. ğŸ“ **Voronoi Diagrams and KD-Trees.**</a><a href="40_Flows_Cuts.html" class="">40.. ğŸŒŠ **Network Flows: Expert Problems.**</a></div></details><details open><summary>IX. Master</summary><div class="items"><a href="41_Advanced_Heaps.html" class="">41.. ğŸŒ² **Heaps: Mergeable Heaps.**</a><a href="42_Suffix_Structures.html" class="">42.. ğŸ”¤ **Suffix Automaton (SAM).**</a><a href="43_Linear_Systems.html" class="">43.. ğŸ§® **Linear Algebra: Bases and Rank.**</a><a href="44_Complex_Numbers_FFT.html" class="">44.. ğŸ“ **Complex Numbers and FFT: Expert Level.**</a></div></details></div><div class='main'><div class='top'><a href='../bg/index.html'>ğŸ‡§ğŸ‡¬ BG</a><button id='t'>Theme</button></div><h1>ğŸ“š Introduction to the Standard Template Library (STL) and Sorting/Searching Tools</h1>
<p>The Standard Template Library (STL) is a fundamental tool in C++ programming. It provides ready-made implementations of algorithms, containers, and iterators that facilitate application development. One of the key aspects of STL is the availability of powerful tools for sorting and searching.</p>
<h2>ğŸ“‹ Content</h2>
<ol>
<li><strong>What is STL?</strong>  <ul>
<li>Containers  </li>
<li>Iterators  </li>
<li>Algorithms  </li>
</ul>
</li>
<li><strong>Sorting in STL</strong>  <ul>
<li>Function <code>std::sort</code>  </li>
<li>Custom sorting  </li>
</ul>
</li>
<li><strong>Searching in STL</strong>  <ul>
<li>Linear search with <code>std::find</code>  </li>
<li>Binary search with <code>std::binary_search</code>  </li>
</ul>
</li>
<li><strong>Examples of Real-world Applications</strong>  </li>
</ol>
<h2>ğŸ” What is STL?</h2>
<p>STL is a library that includes:</p>
<h3>ğŸ“¦ Containers</h3>
<p>Containers represent data structures such as arrays, lists, stacks, and queues. Examples:
- <code>std::vector</code> - dynamic array
- <code>std::list</code> - linked list
- <code>std::map</code> - associative container</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    return 0;
}
</code></pre>
<h3>ğŸ”„ Iterators</h3>
<p>Iterators allow traversing elements in containers. Example:</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {10, 20, 30, 40};
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    }
    return 0;
}
</code></pre>
<h3>âš™ï¸ Algorithms</h3>
<p>STL provides a rich set of algorithms for sorting, searching, copying, transforming, and other operations on data.</p>
<h2>ğŸ”¢ Sorting in STL</h2>
<h3>ğŸŸ¢ Function <code>std::sort</code></h3>
<p><code>std::sort</code> is one of the most used sorting algorithms in C++. It uses Quick Sort and has a time complexity of O(n log n).</p>
<p><strong>Example 1: Sorting an Array</strong></p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {5, 2, 9, 1, 5, 6};
    std::sort(numbers.begin(), numbers.end());

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    return 0;
}
</code></pre>
<p><strong>Example 2: Custom Sorting</strong></p>
<p>Creating a custom function for sorting in descending order:</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

bool descending(int a, int b) {
    return a &gt; b;
}

int main() {
    std::vector&lt;int&gt; numbers = {3, 1, 4, 1, 5, 9};
    std::sort(numbers.begin(), numbers.end(), descending);

    for (int num : numbers) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }
    return 0;
}
</code></pre>
<hr />
<h2>ğŸ” Searching in STL</h2>
<h3>ğŸŸ¡ Linear Search with <code>std::find</code></h3>
<p><code>std::find</code> performs a linear search on a range of elements.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {10, 20, 30, 40, 50};
    auto it = std::find(numbers.begin(), numbers.end(), 30);

    if (it != numbers.end()) {
        std::cout &lt;&lt; &quot;Element found at position: &quot; &lt;&lt; (it - numbers.begin()) &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &quot;Element not found.&quot; &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<h3>ğŸŸ¢ Binary Search with <code>std::binary_search</code></h3>
<p><code>std::binary_search</code> is a more efficient searching algorithm that requires a sorted container.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6};
    bool found = std::binary_search(numbers.begin(), numbers.end(), 4);

    if (found) {
        std::cout &lt;&lt; &quot;Element found.&quot; &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &quot;Element not found.&quot; &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<h2>ğŸ“ˆ Examples of Real-world Applications</h2>
<h3>1. Sorting Data from a File</h3>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::ifstream infile(&quot;data.txt&quot;);
    std::vector&lt;int&gt; numbers;
    int num;

    while (infile &gt;&gt; num) {
        numbers.push_back(num);
    }

    std::sort(numbers.begin(), numbers.end());

    for (int n : numbers) {
        std::cout &lt;&lt; n &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</code></pre>
<h3>2. Searching for a Specific Value in Sorted Data</h3>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main() {
    std::vector&lt;int&gt; data = {1, 3, 5, 7, 9};
    int target = 5;

    if (std::binary_search(data.begin(), data.end(), target)) {
        std::cout &lt;&lt; &quot;Value &quot; &lt;&lt; target &lt;&lt; &quot; found.&quot; &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &quot;Value &quot; &lt;&lt; target &lt;&lt; &quot; not found.&quot; &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<h2>ğŸ¯ Conclusion</h2>
<p>STL is a powerful tool that significantly simplifies working with data. Sorting and searching are fundamental operations which, thanks to STL, are implemented easily and efficiently. Start with the basic algorithms and gradually expand your knowledge to use the full potential of the library.</p></div><script>const b=document.getElementById("t"); let t=localStorage.getItem("theme")||"light"; document.documentElement.setAttribute("data-theme",t); b.onclick=()=>{ t=t==="dark"?"light":"dark"; document.documentElement.setAttribute("data-theme",t); localStorage.setItem("theme",t); };</script></body></html>