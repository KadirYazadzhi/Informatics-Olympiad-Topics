# üìä –ú–∞—Ç—Ä–∏—Ü–∏: –†–∞–∑—à–∏—Ä–µ–Ω–∏ —Ç–µ–æ—Ä–µ–º–∏ –∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

–ú–∞—Ç—Ä–∏—Ü–∏—Ç–µ —Å–∞ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –≤ —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ, –ø–æ—è–≤—è–≤–∞—â–∏ —Å–µ –≤ —Ä–∞–∑–ª–∏—á–Ω–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∏ - –æ—Ç –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ –¥–∏–Ω–∞–º–∏—á–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –¥–æ —Ç–µ–æ—Ä–∏—è –Ω–∞ –≥—Ä–∞—Ñ–∏—Ç–µ –∏ —Ç–µ–æ—Ä–∏—è –Ω–∞ —á–∏—Å–ª–∞—Ç–∞. –û—Ç–≤—ä–¥ –æ—Å–Ω–æ–≤–Ω–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏–∏, –Ω—è–∫–æ–ª–∫–æ –º–æ—â–Ω–∏ —Ç–µ–æ—Ä–µ–º–∏ –∏ —Ç–µ—Ö–Ω–∏–∫–∏ –∏–∑–ø–æ–ª–∑–≤–∞—Ç —Å–≤–æ–π—Å—Ç–≤–∞—Ç–∞ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏—Ç–µ –∑–∞ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ —Ä–µ—à–∞–≤–∞–Ω–µ –Ω–∞ —Å–ª–æ–∂–Ω–∏ –∑–∞–¥–∞—á–∏.

–¢–æ–≤–∞ –∏–∑—á–µ—Ä–ø–∞—Ç–µ–ª–Ω–æ —Ä—ä–∫–æ–≤–æ–¥—Å—Ç–≤–æ –æ–±—Ö–≤–∞—â–∞:
- **–¢–µ–æ—Ä–µ–º–∞ –Ω–∞ –ö–∏—Ä—Ö–æ—Ñ** (Matrix Tree Theorem) –∑–∞ –±—Ä–æ–µ–Ω–µ –Ω–∞ –ø–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞
- **–¢–µ–æ—Ä–µ–º–∞ –Ω–∞ –ö–µ–π–ª–∏-–•–∞–º–∏–ª—Ç—ä–Ω** –∑–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ –º–∞—Ç—Ä–∏—á–Ω–∏ –ø–æ–ª–∏–Ω–æ–º–∏
- **–ì–∞—É—Å–æ–≤–∞ –µ–ª–∏–º–∏–Ω–∞—Ü–∏—è** –Ω–∞–¥ —Ä–∞–∑–ª–∏—á–Ω–∏ –ø–æ–ª–µ—Ç–∞ (—Ä–µ–∞–ª–Ω–∏, –º–æ–¥—É–ª–Ω–∏, –¥–≤–æ–∏—á–Ω–∏)
- **–ú–∞—Ç—Ä–∏—á–Ω–æ —Å—Ç–µ–ø–µ–Ω—É–≤–∞–Ω–µ** –∑–∞ —Ä–µ–∫—É—Ä–µ–Ω—Ç–Ω–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
- **–°–ø–µ—Ü–∏–∞–ª–Ω–∏ —Ç–∏–ø–æ–≤–µ –º–∞—Ç—Ä–∏—Ü–∏** –∏ —Ç–µ—Ö–Ω–∏—Ç–µ —Å–≤–æ–π—Å—Ç–≤–∞
- –ü—Ä–∞–∫—Ç–∏—á–Ω–∏ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

## üßÆ –û—Å–Ω–æ–≤–∏ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏—Ç–µ

### –û—Å–Ω–æ–≤–Ω–∏ –º–∞—Ç—Ä–∏—á–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏

```cpp
struct Matrix {
    int n, m;
    vector<vector<long long>> a;
    
    Matrix(int _n, int _m) : n(_n), m(_m) {
        a.assign(n, vector<long long>(m, 0));
    }
    
    Matrix(vector<vector<long long>> _a) : a(_a) {
        n = a.size();
        m = a[0].size();
    }
    
    // –ï–¥–∏–Ω–∏—á–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞
    static Matrix identity(int n) {
        Matrix I(n, n);
        for (int i = 0; i < n; i++) {
            I.a[i][i] = 1;
        }
        return I;
    }
    
    // –°—ä–±–∏—Ä–∞–Ω–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏
    Matrix operator+(const Matrix& other) const {
        Matrix result(n, m);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                result.a[i][j] = a[i][j] + other.a[i][j];
            }
        }
        return result;
    }
    
    // –£–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏
    Matrix operator*(const Matrix& other) const {
        Matrix result(n, other.m);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < other.m; j++) {
                for (int k = 0; k < m; k++) {
                    result.a[i][j] += a[i][k] * other.a[k][j];
                }
            }
        }
        return result;
    }
    
    // –£–º–Ω–æ–∂–µ–Ω–∏–µ —Å—ä—Å —Å–∫–∞–ª–∞—Ä
    Matrix operator*(long long scalar) const {
        Matrix result(n, m);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                result.a[i][j] = a[i][j] * scalar;
            }
        }
        return result;
    }
    
    // –¢—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–∞–Ω–µ
    Matrix transpose() const {
        Matrix result(m, n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                result.a[j][i] = a[i][j];
            }
        }
        return result;
    }
};
```

### –ú–∞—Ç—Ä–∏—á–Ω–æ —Å—Ç–µ–ø–µ–Ω—É–≤–∞–Ω–µ

–ï–¥–Ω–∞ –æ—Ç –Ω–∞–π-–º–æ—â–Ω–∏—Ç–µ —Ç–µ—Ö–Ω–∏–∫–∏ –≤ —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –µ –º–∞—Ç—Ä–∏—á–Ω–æ—Ç–æ —Å—Ç–µ–ø–µ–Ω—É–≤–∞–Ω–µ –∑–∞ —Ä–µ—à–∞–≤–∞–Ω–µ –Ω–∞ –ª–∏–Ω–µ–π–Ω–∏ —Ä–µ–∫—É—Ä—Å–∏–∏:

```cpp
const long long MOD = 1e9 + 7;

struct MatrixMod {
    int n;
    vector<vector<long long>> a;
    
    MatrixMod(int _n) : n(_n) {
        a.assign(n, vector<long long>(n, 0));
    }
    
    static MatrixMod identity(int n) {
        MatrixMod I(n);
        for (int i = 0; i < n; i++) I.a[i][i] = 1;
        return I;
    }
    
    MatrixMod operator*(const MatrixMod& other) const {
        MatrixMod result(n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    result.a[i][j] = (result.a[i][j] + 
                                     a[i][k] * other.a[k][j]) % MOD;
                }
            }
        }
        return result;
    }
    
    MatrixMod power(long long p) const {
        MatrixMod result = identity(n);
        MatrixMod base = *this;
        
        while (p > 0) {
            if (p & 1) result = result * base;
            base = base * base;
            p >>= 1;
        }
        
        return result;
    }
};

// –ü—Ä–∏–º–µ—Ä: –§–∏–±–æ–Ω–∞—á–∏ —á—Ä–µ–∑ –º–∞—Ç—Ä–∏—á–Ω–æ —Å—Ç–µ–ø–µ–Ω—É–≤–∞–Ω–µ
// F(n) = F(n-1) + F(n-2)
// [F(n+1)]   [1 1]^n   [F(1)]   [1 1]^n   [1]
// [F(n)  ] = [1 0]   * [F(0)] = [1 0]   * [0]

long long fibonacci(long long n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    
    MatrixMod M(2);
    M.a[0][0] = M.a[0][1] = M.a[1][0] = 1;
    M.a[1][1] = 0;
    
    M = M.power(n);
    return M.a[1][0];  // F(n)
}

int main() {
    cout << "F(10) = " << fibonacci(10) << "\n";      // 55
    cout << "F(100) = " << fibonacci(100) << "\n";    // –ú–Ω–æ–≥–æ –≥–æ–ª—è–º–æ —á–∏—Å–ª–æ
    return 0;
}
```

**–í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç:** $O(n^3 \log p)$ –∫—ä–¥–µ—Ç–æ $n$ –µ —Ä–∞–∑–º–µ—Ä—ä—Ç –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞—Ç–∞ –∏ $p$ –µ —Å—Ç–µ–ø–µ–Ω—Ç–∞.

**–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è:**
- –õ–∏–Ω–µ–π–Ω–∏ —Ä–µ–∫—É—Ä—Å–∏–∏: –§–∏–±–æ–Ω–∞—á–∏, —Ç—Ä–∏–±–æ–Ω–∞—á–∏ –∏ –¥—Ä.
- –ë—Ä–æ–µ–Ω–µ –Ω–∞ –ø—ä—Ç–∏—â–∞ –≤ –≥—Ä–∞—Ñ: –ë—Ä–æ–π –ø—ä—Ç–∏—â–∞ —Å –¥—ä–ª–∂–∏–Ω–∞ $k$
- –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ –¥–∏–Ω–∞–º–∏—á–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ
- –õ–∏–Ω–µ–π–Ω–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏

## üå≥ –¢–µ–æ—Ä–µ–º–∞ –Ω–∞ –ö–∏—Ä—Ö–æ—Ñ (Matrix Tree Theorem)

**–¢–µ–æ—Ä–µ–º–∞—Ç–∞ –Ω–∞ –ö–∏—Ä—Ö–æ—Ñ** –µ –µ–¥–∏–Ω –æ—Ç –Ω–∞–π-–µ–ª–µ–≥–∞–Ω—Ç–Ω–∏—Ç–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –≤ —Ç–µ–æ—Ä–∏—è—Ç–∞ –Ω–∞ –≥—Ä–∞—Ñ–∏—Ç–µ, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è—â –¥–∏—Ä–µ–∫—Ç–µ–Ω –∞–ª–≥–µ–±—Ä–∏—á–µ–Ω –º–µ—Ç–æ–¥ –∑–∞ –±—Ä–æ–µ–Ω–µ –Ω–∞ –ø–æ–∫—Ä–∏–≤–∞—â–∏—Ç–µ –¥—ä—Ä–≤–µ—Ç–∞ –≤ –≥—Ä–∞—Ñ.

### –§–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∞ –Ω–∞ —Ç–µ–æ—Ä–µ–º–∞—Ç–∞

–ë—Ä–æ—è—Ç –Ω–∞ –ø–æ–∫—Ä–∏–≤–∞—â–∏—Ç–µ –¥—ä—Ä–≤–µ—Ç–∞ –≤ —Å–≤—ä—Ä–∑–∞–Ω –≥—Ä–∞—Ñ $G = (V, E)$ –µ —Ä–∞–≤–µ–Ω –Ω–∞ **–ø—Ä–æ–∏–∑–≤–æ–ª–µ–Ω –∫–æ—Ñ–∞–∫—Ç–æ—Ä** –Ω–∞ –Ω–µ–≥–æ–≤–∞—Ç–∞ –õ–∞–ø–ª–∞—Å–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü–∞ $L$.

### –õ–∞–ø–ª–∞—Å–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü–∞

–ó–∞ –≥—Ä–∞—Ñ —Å $n$ –≤—ä—Ä—Ö–∞:

**–ú–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—Ç–µ–ø–µ–Ω–∏—Ç–µ $D$**: –î–∏–∞–≥–æ–Ω–∞–ª–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞ –∫—ä–¥–µ—Ç–æ $D_{i,i} = \deg(v_i)$

**–ú–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ $A$**: $A_{i,j} = $ –±—Ä–æ–π —Ä–µ–±—Ä–∞ –º–µ–∂–¥—É $v_i$ –∏ $v_j$

**–õ–∞–ø–ª–∞—Å–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü–∞**: $L = D - A$

–ï–∫—Å–ø–ª–∏—Ü–∏—Ç–Ω–æ:
$$L_{i,j} = \begin{cases}
\deg(v_i) & \text{–∞–∫–æ } i = j \\
-(\text{–±—Ä–æ–π —Ä–µ–±—Ä–∞ –º–µ–∂–¥—É } i \text{ –∏ } j) & \text{–∞–∫–æ } i \neq j
\end{cases}$$

### –ò–∑—á–∏—Å–ª—è–≤–∞–Ω–µ –Ω–∞ –±—Ä–æ—è –ø–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞

```cpp
#include <bits/stdc++.h>
using namespace std;

const double EPS = 1e-9;

// –ò–∑—á–∏—Å–ª–∏ –¥–µ—Ç–µ—Ä–º–∏–Ω–∞–Ω—Ç–∞ —á—Ä–µ–∑ –≥–∞—É—Å–æ–≤–∞ –µ–ª–∏–º–∏–Ω–∞—Ü–∏—è
double determinant(vector<vector<double>> A) {
    int n = A.size();
    double det = 1.0;
    
    for (int i = 0; i < n; i++) {
        // –ù–∞–º–µ—Ä–∏ –ø–∏–≤–æ—Ç
        int pivot = i;
        for (int j = i + 1; j < n; j++) {
            if (abs(A[j][i]) > abs(A[pivot][i])) {
                pivot = j;
            }
        }
        
        if (abs(A[pivot][i]) < EPS) {
            return 0;  // –°–∏–Ω–≥—É–ª—è—Ä–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞
        }
        
        if (pivot != i) {
            swap(A[i], A[pivot]);
            det *= -1;  // –ü—Ä–æ–º—è–Ω–∞ –Ω–∞ –∑–Ω–∞–∫–∞ –ø—Ä–∏ —Ä–∞–∑–º—è–Ω–∞ –Ω–∞ —Ä–µ–¥–æ–≤–µ
        }
        
        det *= A[i][i];
        
        // –ï–ª–∏–º–∏–Ω–∏—Ä–∞–π –∫–æ–ª–æ–Ω–∞—Ç–∞
        for (int j = i + 1; j < n; j++) {
            double factor = A[j][i] / A[i][i];
            for (int k = i; k < n; k++) {
                A[j][k] -= factor * A[i][k];
            }
        }
    }
    
    return det;
}

// –ë—Ä–æ–π –ø–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞ –∏–∑–ø–æ–ª–∑–≤–∞–π–∫–∏ —Ç–µ–æ—Ä–µ–º–∞—Ç–∞ –Ω–∞ –ö–∏—Ä—Ö–æ—Ñ
long long countSpanningTrees(int n, vector<pair<int, int>>& edges) {
    // –ü–æ—Å—Ç—Ä–æ–π –õ–∞–ø–ª–∞—Å–æ–≤–∞ –º–∞—Ç—Ä–∏—Ü–∞
    vector<vector<double>> L(n, vector<double>(n, 0));
    
    for (auto [u, v] : edges) {
        L[u][u]++;
        L[v][v]++;
        L[u][v]--;
        L[v][u]--;
    }
    
    // –ü—Ä–µ–º–∞—Ö–Ω–∏ –ø—ä—Ä–≤–∏—è —Ä–µ–¥ –∏ –∫–æ–ª–æ–Ω–∞ (–∏–∑—á–∏—Å–ª–∏ –∫–æ—Ñ–∞–∫—Ç–æ—Ä)
    vector<vector<double>> cofactor(n - 1, vector<double>(n - 1));
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < n; j++) {
            cofactor[i - 1][j - 1] = L[i][j];
        }
    }
    
    // –î–µ—Ç–µ—Ä–º–∏–Ω–∞–Ω—Ç–∞—Ç–∞ –¥–∞–≤–∞ –±—Ä–æ—è –ø–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞
    double result = determinant(cofactor);
    return (long long)(result + 0.5);  // –ó–∞–∫—Ä—ä–≥–ª–∏ –¥–æ –Ω–∞–π-–±–ª–∏–∑–∫–æ—Ç–æ —Ü—è–ª–æ
}

int main() {
    // –ü—Ä–∏–º–µ—Ä: K4 (–ø—ä–ª–µ–Ω –≥—Ä–∞—Ñ —Å 4 –≤—ä—Ä—Ö–∞)
    // –ò–∑–≤–µ—Å—Ç–µ–Ω –æ—Ç–≥–æ–≤–æ—Ä: 16 –ø–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞
    int n = 4;
    vector<pair<int, int>> edges = {
        {0, 1}, {0, 2}, {0, 3},
        {1, 2}, {1, 3}, {2, 3}
    };
    
    cout << "–ü–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞ –≤ K4: " << countSpanningTrees(n, edges) << "\n";
    // –ò–∑—Ö–æ–¥: 16
    
    return 0;
}
```

**–í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç:** $O(n^3)$ –∑–∞ –≥–∞—É—Å–æ–≤–∞—Ç–∞ –µ–ª–∏–º–∏–Ω–∞—Ü–∏—è

### –ú–æ–¥—É–ª–Ω–∞ –≤–µ—Ä—Å–∏—è

–ó–∞ –≥–æ–ª–µ–º–∏ –≥—Ä–∞—Ñ–∏ –∏–∑—á–∏—Å–ª–µ—Ç–µ –¥–µ—Ç–µ—Ä–º–∏–Ω–∞–Ω—Ç–∞—Ç–∞ –ø–æ –º–æ–¥—É–ª –ø—Ä–æ—Å—Ç–æ —á–∏—Å–ª–æ:

```cpp
const long long MOD = 1e9 + 7;

long long modPow(long long base, long long exp, long long mod) {
    long long result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) result = (result * base) % mod;
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

long long modInv(long long a, long long mod) {
    return modPow(a, mod - 2, mod);  // –ú–∞–ª–∫–∞—Ç–∞ —Ç–µ–æ—Ä–µ–º–∞ –Ω–∞ –§–µ—Ä–º–∞
}

long long determinantMod(vector<vector<long long>> A, long long mod) {
    int n = A.size();
    long long det = 1;
    
    for (int i = 0; i < n; i++) {
        int pivot = -1;
        for (int j = i; j < n; j++) {
            if (A[j][i] % mod != 0) {
                pivot = j;
                break;
            }
        }
        
        if (pivot == -1) return 0;
        
        if (pivot != i) {
            swap(A[i], A[pivot]);
            det = (mod - det) % mod;
        }
        
        det = (det * A[i][i]) % mod;
        long long inv = modInv(A[i][i], mod);
        
        for (int j = i + 1; j < n; j++) {
            long long factor = (A[j][i] * inv) % mod;
            for (int k = i; k < n; k++) {
                A[j][k] = ((A[j][k] - factor * A[i][k]) % mod + mod) % mod;
            }
        }
    }
    
    return det;
}

long long countSpanningTreesMod(int n, vector<pair<int, int>>& edges) {
    vector<vector<long long>> L(n, vector<long long>(n, 0));
    
    for (auto [u, v] : edges) {
        L[u][u]++;
        L[v][v]++;
        L[u][v] = (L[u][v] - 1 + MOD) % MOD;
        L[v][u] = (L[v][u] - 1 + MOD) % MOD;
    }
    
    vector<vector<long long>> cofactor(n - 1, vector<long long>(n - 1));
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < n; j++) {
            cofactor[i - 1][j - 1] = L[i][j];
        }
    }
    
    return determinantMod(cofactor, MOD);
}
```

### –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è

1. **–ë—Ä–æ–µ–Ω–µ –Ω–∞ –µ—Ç–∏–∫–µ—Ç–∏—Ä–∞–Ω–∏ –¥—ä—Ä–≤–µ—Ç–∞**: $n^{n-2}$ (—Ñ–æ—Ä–º—É–ª–∞ –Ω–∞ –ö–µ–π–ª–∏, –¥–æ–∫–∞–∑—É–µ–º–∞ —á—Ä–µ–∑ —Ç–µ–æ—Ä–µ–º–∞—Ç–∞ –Ω–∞ –ö–∏—Ä—Ö–æ—Ñ)
2. **–ù–∞–¥–µ–∂–¥–Ω–æ—Å—Ç –Ω–∞ –º—Ä–µ–∂–∞—Ç–∞**: –ë—Ä–æ–π –Ω–∞—á–∏–Ω–∏ –∑–∞ –ø–æ–¥–¥—ä—Ä–∂–∞–Ω–µ –Ω–∞ —Å–≤—ä—Ä–∑–∞–Ω–æ—Å—Ç
3. **–ï–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–∏ –º—Ä–µ–∂–∏**: –°–≤—ä—Ä–∑–∞–Ω–æ —Å –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Ç–æ —Å—ä–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ
4. **–°–ª—É—á–∞–π–Ω–∏ –ø–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞**: –ê–ª–≥–æ—Ä–∏—Ç–º–∏ –∑–∞ —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ –≤–∑–µ–º–∞–Ω–µ –Ω–∞ –ø—Ä–æ–±–∏

## üèÅ –ì–∞—É—Å–æ–≤–∞ –µ–ª–∏–º–∏–Ω–∞—Ü–∏—è –ø–æ –º–æ–¥—É–ª 2 (XOR —Å–∏—Å—Ç–µ–º–∏)

–ö–æ–≥–∞—Ç–æ —Ä–∞–±–æ—Ç–∏–º –Ω–∞–¥ $GF(2)$ (–¥–≤–æ–∏—á–Ω–æ—Ç–æ –ø–æ–ª–µ), —Å—ä–±–∏—Ä–∞–Ω–µ—Ç–æ —Å—Ç–∞–≤–∞ XOR –∏ –º–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –ø–æ–±–∏—Ç–æ–≤–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ –∑–∞ –º–∞—Å–∏–≤–Ω–∏ —É—Å–∫–æ—Ä–µ–Ω–∏—è.

### –î–≤–æ–∏—á–Ω–∞ –≥–∞—É—Å–æ–≤–∞ –µ–ª–∏–º–∏–Ω–∞—Ü–∏—è —Å bitset

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 2000;
bitset<MAXN> matrix[MAXN];  // –í—Å–µ–∫–∏ —Ä–µ–¥ –µ bitset
bitset<MAXN> rhs;           // –î—è—Å–Ω–∞ —Å—Ç—Ä–∞–Ω–∞ (–∑–∞ Ax = b)

int gaussianEliminationBinary(int n, int m) {
    // n = —Ä–µ–¥–æ–≤–µ, m = –∫–æ–ª–æ–Ω–∏
    int rank = 0;
    
    for (int col = 0; col < m && rank < n; col++) {
        // –ù–∞–º–µ—Ä–∏ –ø–∏–≤–æ—Ç
        int pivot = -1;
        for (int row = rank; row < n; row++) {
            if (matrix[row][col]) {
                pivot = row;
                break;
            }
        }
        
        if (pivot == -1) continue;  // –ö–æ–ª–æ–Ω–∞—Ç–∞ –µ —Ü—è–ª–∞ –æ—Ç –Ω—É–ª–∏
        
        // –†–∞–∑–º–µ–Ω–∏ —Ä–µ–¥–æ–≤–µ
        swap(matrix[rank], matrix[pivot]);
        
        // –ï–ª–∏–º–∏–Ω–∏—Ä–∞–π –≤—Å–∏—á–∫–∏ –¥—Ä—É–≥–∏ 1-—Ü–∏ –≤ —Ç–∞–∑–∏ –∫–æ–ª–æ–Ω–∞
        for (int row = 0; row < n; row++) {
            if (row != rank && matrix[row][col]) {
                matrix[row] ^= matrix[rank];  // XOR —Ü–µ–ª–∏ —Ä–µ–¥–æ–≤–µ!
                rhs[row] = rhs[row] ^ rhs[rank];
            }
        }
        
        rank++;
    }
    
    return rank;
}

// –ü—Ä–∏–º–µ—Ä: –ü—ä–∑–µ–ª Lights Out
// n x n –º—Ä–µ–∂–∞, –∫–ª–∏–∫–≤–∞–Ω–µ—Ç–æ –Ω–∞ —Å–≤–µ—Ç–ª–∏–Ω–∞ —è –ø—Ä–µ–≤–∫–ª—é—á–≤–∞ –∑–∞–µ–¥–Ω–æ —Å—ä—Å —Å—ä—Å–µ–¥–∏—Ç–µ
// –ù–∞–º–µ—Ä–µ—Ç–µ –¥–∞–ª–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è—Ç–∞ –µ —Ä–∞–∑—Ä–µ—à–∏–º–∞

bool lightsOut(int n, vector<vector<int>>& target) {
    int N = n * n;
    
    // –ü–æ—Å—Ç—Ä–æ–π —Å–∏—Å—Ç–µ–º–∞ –æ—Ç —É—Ä–∞–≤–Ω–µ–Ω–∏—è
    // –ü—Ä–æ–º–µ–Ω–ª–∏–≤–∞ x[i][j] = 1 –∞–∫–æ –∫–ª–∏–∫–Ω–µ–º –Ω–∞ –ø–æ–∑–∏—Ü–∏—è (i,j)
    // –í—Å—è–∫–æ —É—Ä–∞–≤–Ω–µ–Ω–∏–µ: —Å—É–º–∞ –Ω–∞ –∫–ª–∏–∫–≤–∞–Ω–∏—è—Ç–∞, –∑–∞—Å—è–≥–∞—â–∏ –ø–æ–∑–∏—Ü–∏—è—Ç–∞ = —Ü–µ–ª–µ–≤–æ —Å—ä—Å—Ç–æ—è–Ω–∏–µ
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            int eq = i * n + j;  // –ù–æ–º–µ—Ä –Ω–∞ —É—Ä–∞–≤–Ω–µ–Ω–∏–µ—Ç–æ
            rhs[eq] = target[i][j];
            
            // –ö–ª–∏–∫–≤–∞–Ω–µ—Ç–æ –Ω–∞ (i,j) –∑–∞—Å—è–≥–∞ —Å–µ–±–µ —Å–∏
            matrix[eq][i * n + j] = 1;
            
            // –ò —Å—ä—Å–µ–¥–∏—Ç–µ
            if (i > 0) matrix[eq][(i-1) * n + j] = 1;      // –Ω–∞–≥–æ—Ä–µ
            if (i < n-1) matrix[eq][(i+1) * n + j] = 1;    // –Ω–∞–¥–æ–ª—É
            if (j > 0) matrix[eq][i * n + (j-1)] = 1;      // –Ω–∞–ª—è–≤–æ
            if (j < n-1) matrix[eq][i * n + (j+1)] = 1;    // –Ω–∞–¥—è—Å–Ω–æ
        }
    }
    
    int rank = gaussianEliminationBinary(N, N);
    
    // –ü—Ä–æ–≤–µ—Ä–∏ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç: –∞–∫–æ –Ω—è–∫–æ–µ —É—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å—Ç–∞–Ω–∞ 0 = 1, –Ω—è–º–∞ —Ä–µ—à–µ–Ω–∏–µ
    for (int i = rank; i < N; i++) {
        if (rhs[i]) return false;
    }
    
    return true;
}

int main() {
    // –ü—Ä–∏–º–µ—Ä: 3x3 lights out
    vector<vector<int>> target = {
        {1, 0, 1},
        {0, 1, 0},
        {1, 0, 1}
    };
    
    if (lightsOut(3, target)) {
        cout << "–†–∞–∑—Ä–µ—à–∏–º–æ!\n";
    } else {
        cout << "–ù—è–º–∞ —Ä–µ—à–µ–Ω–∏–µ\n";
    }
    
    return 0;
}
```

**–£—Å–∫–æ—Ä–µ–Ω–∏–µ**: –û–ø–µ—Ä–∞—Ü–∏–∏—Ç–µ —Å–∞ $64 \times$ –ø–æ-–±—ä—Ä–∑–∏ –ø–æ—Ä–∞–¥–∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏—Ç–µ –Ω–∞ bitset!
- –í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç: $O(n^3 / 64)$ –≤–º–µ—Å—Ç–æ $O(n^3)$

### –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–∞ –¥–≤–æ–∏—á–Ω–∞—Ç–∞ –≥–∞—É—Å–æ–≤–∞ –µ–ª–∏–º–∏–Ω–∞—Ü–∏—è

1. **–ü—ä–∑–µ–ª Lights Out**: –ö–ª–∞—Å–∏—á–µ—Å–∫–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
2. **XOR –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞**: –ù–∞–º–µ—Ä–∏ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ —Å –∫–æ–Ω–∫—Ä–µ—Ç–µ–Ω XOR
3. **–õ–∏–Ω–µ–π–Ω–∏ –∫–æ–¥–æ–≤–µ**: –ö–æ–¥–æ–≤–µ –∑–∞ –∫–æ—Ä–∏–≥–∏—Ä–∞–Ω–µ –Ω–∞ –≥—Ä–µ—à–∫–∏
4. **–ö—Ä–∏–ø—Ç–æ–∞–Ω–∞–ª–∏–∑**: –†–∞–∑–±–∏–≤–∞–Ω–µ –Ω–∞ –ª–∏–Ω–µ–π–Ω–∏ —à–∏—Ñ—Ä–∏
5. **–¢–µ–æ—Ä–∏—è –Ω–∞ –∏–≥—Ä–∏—Ç–µ**: –ê–Ω–∞–ª–∏–∑ –Ω–∞ XOR –∏–≥—Ä–∏ (–≤–∞—Ä–∏–∞–Ω—Ç–∏ –Ω–∞ Nim)

### –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ XOR –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ

```cpp
// –î–∞–¥–µ–Ω –º–∞—Å–∏–≤, –Ω–∞–º–µ—Ä–∏ –¥–∞–ª–∏ —Å—ä—â–µ—Å—Ç–≤—É–≤–∞ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ —Å XOR —Ä–∞–≤–µ–Ω –Ω–∞ —Ü–µ–ª
bool findXORSubset(vector<int>& arr, int target) {
    const int BITS = 30;  // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–º–µ 30-–±–∏—Ç–æ–≤–∏ —Ü–µ–ª–∏ —á–∏—Å–ª–∞
    int n = arr.size();
    
    // –í—Å—è–∫–æ —á–∏—Å–ª–æ –µ —Ä–µ–¥ –≤ –¥–≤–æ–∏—á–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞
    for (int i = 0; i < n; i++) {
        for (int bit = 0; bit < BITS; bit++) {
            matrix[i][bit] = (arr[i] >> bit) & 1;
        }
    }
    
    // –¶–µ–ª—Ç–∞ –∫–∞—Ç–æ –¥—è—Å–Ω–∞ —Å—Ç—Ä–∞–Ω–∞
    for (int bit = 0; bit < BITS; bit++) {
        rhs[bit] = (target >> bit) & 1;
    }
    
    int rank = gaussianEliminationBinary(n, BITS);
    
    // –ü—Ä–æ–≤–µ—Ä–∏ –¥–∞–ª–∏ —Å–∏—Å—Ç–µ–º–∞—Ç–∞ –µ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∞
    for (int i = rank; i < n; i++) {
        bool all_zero = true;
        for (int j = 0; j < BITS; j++) {
            if (matrix[i][j]) {
                all_zero = false;
                break;
            }
        }
        if (all_zero && rhs[i]) return false;
    }
    
    return true;
}
```

## üéØ –¢–µ–æ—Ä–µ–º–∞ –Ω–∞ –ö–µ–π–ª–∏-–•–∞–º–∏–ª—Ç—ä–Ω

**–¢–µ–æ—Ä–µ–º–∞—Ç–∞ –Ω–∞ –ö–µ–π–ª–∏-–•–∞–º–∏–ª—Ç—ä–Ω** –≥–ª–∞—Å–∏, —á–µ –≤—Å—è–∫–∞ –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–≤–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–æ—Ç–æ —Å–∏ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–Ω–æ —É—Ä–∞–≤–Ω–µ–Ω–∏–µ.

### –§–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∞ –Ω–∞ —Ç–µ–æ—Ä–µ–º–∞—Ç–∞

–ê–∫–æ $p(\lambda) = \det(A - \lambda I)$ –µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–Ω–∏—è—Ç –ø–æ–ª–∏–Ω–æ–º –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞ $A$, —Ç–æ–≥–∞–≤–∞:
$$p(A) = 0$$

### –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ: –ë—ä—Ä–∑–æ –º–∞—Ç—Ä–∏—á–Ω–æ —Å—Ç–µ–ø–µ–Ω—É–≤–∞–Ω–µ

–ó–∞ $k \times k$ –º–∞—Ç—Ä–∏—Ü–∞, –≤–º–µ—Å—Ç–æ –¥–∞ –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ $A^n$ –¥–∏—Ä–µ–∫—Ç–Ω–æ, –º–æ–∂–µ–º –¥–∞:
1. –ù–∞–º–µ—Ä–∏–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–Ω–∏—è –ø–æ–ª–∏–Ω–æ–º $p(\lambda)$
2. –†–µ–¥—É—Ü–∏—Ä–∞–º–µ –≤–∏—Å–æ–∫–∏—Ç–µ —Å—Ç–µ–ø–µ–Ω–∏ –∏–∑–ø–æ–ª–∑–≤–∞–π–∫–∏ $p(A) = 0$
3. –ò–∑—Ä–∞–∑–∏–º $A^n$ –∫–∞—Ç–æ –ø–æ–ª–∏–Ω–æ–º –æ—Ç —Å—Ç–µ–ø–µ–Ω $< k$

```cpp
// –ó–∞ 2x2 –º–∞—Ç—Ä–∏—Ü–∞ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏—á–Ω–∏—è—Ç –ø–æ–ª–∏–Ω–æ–º –µ:
// p(Œª) = Œª¬≤ - tr(A)Œª + det(A)
// –¢–∞–∫–∞ A¬≤ = tr(A)¬∑A - det(A)¬∑I

MatrixMod fastPower2x2(MatrixMod A, long long n) {
    // –ó–∞ n > 2 –∏–∑–ø–æ–ª–∑–≤–∞–π: A^n = c‚ÇÅA + c‚ÇÄI
    // –ò–∑—á–∏—Å–ª–∏ c‚ÇÅ, c‚ÇÄ –∏–∑–ø–æ–ª–∑–≤–∞–π–∫–∏ —Ä–µ–∫—É—Ä–µ–Ω—Ç–Ω–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç
    
    long long trace = (A.a[0][0] + A.a[1][1]) % MOD;
    long long det = (A.a[0][0] * A.a[1][1] - A.a[0][1] * A.a[1][0]) % MOD;
    det = (det % MOD + MOD) % MOD;
    
    // –ò–∑–ø–æ–ª–∑–≤–∞–π –º–∞—Ç—Ä–∏—á–Ω–æ —Å—Ç–µ–ø–µ–Ω—É–≤–∞–Ω–µ –Ω–∞ —Ä–µ–∫—É—Ä—Å–∏—è—Ç–∞ –Ω–∞ –∫–æ–µ—Ñ–∏—Ü–∏–µ–Ω—Ç–∏—Ç–µ
    // –¢–æ–≤–∞ –µ —Å–ª–æ–∂–Ω–æ, –Ω–æ —Å–ø–µ—Å—Ç—è–≤–∞ —Ñ–∞–∫—Ç–æ—Ä –Ω–∞ –ø—Ä–∞–∫—Ç–∏–∫–∞
    return A.power(n);  // –†–µ–∑–µ—Ä–≤–µ–Ω –≤–∞—Ä–∏–∞–Ω—Ç –∫—ä–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏—è –º–µ—Ç–æ–¥
}
```

**–ó–∞–±–µ–ª–µ–∂–∫–∞**: –ù–∞ –ø—Ä–∞–∫—Ç–∏–∫–∞ –¥–∏—Ä–µ–∫—Ç–Ω–æ—Ç–æ –º–∞—Ç—Ä–∏—á–Ω–æ —Å—Ç–µ–ø–µ–Ω—É–≤–∞–Ω–µ —á–µ—Å—Ç–æ –µ –ø–æ-–ø—Ä–æ—Å—Ç–æ, –æ—Å–≤–µ–Ω –∞–∫–æ –º–∞—Ç—Ä–∏—Ü–∞—Ç–∞ –Ω–µ –µ –º–Ω–æ–≥–æ –≥–æ–ª—è–º–∞.

## üí° –°–ø–µ—Ü–∏–∞–ª–Ω–∏ —Ç–∏–ø–æ–≤–µ –º–∞—Ç—Ä–∏—Ü–∏

### –°–∏–º–µ—Ç—Ä–∏—á–Ω–∏ –º–∞—Ç—Ä–∏—Ü–∏

$A = A^T$ (—Ç—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–∞–Ω–∞—Ç–∞ –µ —Ä–∞–≤–Ω–∞ –Ω–∞ —Å–µ–±–µ —Å–∏)

**–°–≤–æ–π—Å—Ç–≤–∞:**
- –í–∏–Ω–∞–≥–∏ –¥–∏–∞–≥–æ–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º–∏
- –°–æ–±—Å—Ç–≤–µ–Ω–∏—Ç–µ —Å—Ç–æ–π–Ω–æ—Å—Ç–∏ —Å–∞ —Ä–µ–∞–ª–Ω–∏
- –°–æ–±—Å—Ç–≤–µ–Ω–∏—Ç–µ –≤–µ–∫—Ç–æ—Ä–∏ —Å–∞ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª–Ω–∏

### –û—Ä—Ç–æ–≥–æ–Ω–∞–ª–Ω–∏ –º–∞—Ç—Ä–∏—Ü–∏

$A^T A = I$ (—Ç—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–∞–Ω–∞—Ç–∞ –µ –æ–±—Ä–∞—Ç–Ω–∞)

**–°–≤–æ–π—Å—Ç–≤–∞:**
- –ó–∞–ø–∞–∑–≤–∞—Ç —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è –∏ —ä–≥–ª–∏
- –î–µ—Ç–µ—Ä–º–∏–Ω–∞–Ω—Ç–∞—Ç–∞ –µ $\pm 1$
- –†–æ—Ç–∞—Ü–∏–∏ –∏ –æ—Ç—Ä–∞–∂–µ–Ω–∏—è

### –ü–µ—Ä–º—É—Ç–∞—Ü–∏–æ–Ω–Ω–∏ –º–∞—Ç—Ä–∏—Ü–∏

–¢–æ—á–Ω–æ –µ–¥–Ω–∞ 1 –≤—ä–≤ –≤—Å–µ–∫–∏ —Ä–µ–¥ –∏ –∫–æ–ª–æ–Ω–∞, –æ—Å—Ç–∞–Ω–∞–ª–∏—Ç–µ 0.

**–°–≤–æ–π—Å—Ç–≤–∞:**
- –ü—Ä–µ–¥—Å—Ç–∞–≤—è—Ç –ø–µ—Ä–º—É—Ç–∞—Ü–∏–∏
- $P^T = P^{-1}$
- –î–µ—Ç–µ—Ä–º–∏–Ω–∞–Ω—Ç–∞—Ç–∞ –µ $\pm 1$

## üöÄ –†–∞–∑—à–∏—Ä–µ–Ω–∏ —Ç–µ—Ö–Ω–∏–∫–∏

### –ë–ª–æ–∫–æ–≤–æ —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏

–ó–∞ –º–Ω–æ–≥–æ –≥–æ–ª–µ–º–∏ –º–∞—Ç—Ä–∏—Ü–∏ —Ä–∞–∑–¥–µ–ª–µ—Ç–µ –Ω–∞ –±–ª–æ–∫–æ–≤–µ:

```cpp
// –ê–ª–≥–æ—Ä–∏—Ç—ä–º –Ω–∞ –©—Ä–∞—Å–µ–Ω: O(n^2.807) –≤–º–µ—Å—Ç–æ O(n^3)
// –ü—Ä–∞–∫—Ç–∏—á–µ–Ω –∑–∞ n > 64, –Ω–æ —Å–ª–æ–∂–µ–Ω –∑–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è
```

### –†–∞–∑—Ä–µ–¥–µ–Ω–∏ –º–∞—Ç—Ä–∏—Ü–∏

–ó–∞ –º–∞—Ç—Ä–∏—Ü–∏ —Å –ø—Ä–µ–¥–∏–º–Ω–æ –Ω—É–ª–∏:

```cpp
struct SparseMatrix {
    map<pair<int,int>, long long> data;
    int n, m;
    
    long long get(int i, int j) {
        auto it = data.find({i, j});
        return (it == data.end()) ? 0 : it->second;
    }
    
    void set(int i, int j, long long val) {
        if (val != 0) {
            data[{i, j}] = val;
        } else {
            data.erase({i, j});
        }
    }
};
```

### –í–µ—Ä–∏–≥–∞ –æ—Ç —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏

–ù–∞–º–µ—Ä–µ—Ç–µ –æ–ø—Ç–∏–º–∞–ª–Ω–∏—è —Ä–µ–¥ –∑–∞ —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏, –∑–∞ –¥–∞ –º–∏–Ω–∏–º–∏–∑–∏—Ä–∞—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏–∏—Ç–µ:

```cpp
// –ö–ª–∞—Å–∏—á–µ—Å–∫–∞ –î–ü –∑–∞–¥–∞—á–∞
// dp[i][j] = –º–∏–Ω–∏–º–∞–ª–Ω–∞ —Ü–µ–Ω–∞ –∑–∞ —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏ –æ—Ç i –¥–æ j
int matrixChainOrder(vector<int>& dims) {
    int n = dims.size() - 1;
    vector<vector<int>> dp(n, vector<int>(n, 0));
    
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i < n - len + 1; i++) {
            int j = i + len - 1;
            dp[i][j] = INT_MAX;
            
            for (int k = i; k < j; k++) {
                int cost = dp[i][k] + dp[k+1][j] + 
                          dims[i] * dims[k+1] * dims[j+1];
                dp[i][j] = min(dp[i][j], cost);
            }
        }
    }
    
    return dp[0][n-1];
}
```

## üìù –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –∑–∞–¥–∞—á–∏

### –ó–∞–¥–∞—á–∞ 1: –í–∞—Ä–∏–∞–Ω—Ç –Ω–∞ –§–∏–±–æ–Ω–∞—á–∏
–ò–∑—á–∏—Å–ª–µ—Ç–µ $F(n) = 2F(n-1) + 3F(n-2)$ —Å $F(0) = 1, F(1) = 1$.

```cpp
long long fibVariant(long long n) {
    if (n == 0) return 1;
    if (n == 1) return 1;
    
    MatrixMod M(2);
    M.a[0][0] = 2; M.a[0][1] = 3;
    M.a[1][0] = 1; M.a[1][1] = 0;
    
    M = M.power(n);
    return M.a[1][0];
}
```

### –ó–∞–¥–∞—á–∞ 2: –ë—Ä–æ–µ–Ω–µ –Ω–∞ –ø—ä—Ç–∏—â–∞
–ë—Ä–æ–µ—Ç–µ –ø—ä—Ç–∏—â–∞ —Å —Ç–æ—á–Ω–∞ –¥—ä–ª–∂–∏–Ω–∞ $k$ –≤ –≥—Ä–∞—Ñ.

```cpp
long long countPaths(vector<vector<int>>& adj, int k, int start, int end) {
    int n = adj.size();
    MatrixMod A(n);
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            A.a[i][j] = adj[i][j];
        }
    }
    
    A = A.power(k);
    return A.a[start][end];
}
```

### –ó–∞–¥–∞—á–∞ 3: –ü–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞ –≤ –º—Ä–µ–∂–∞
–ë—Ä–æ–µ—Ç–µ –ø–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞ –≤ $n \times m$ –≥—Ä–∞—Ñ–æ–≤–∞ –º—Ä–µ–∂–∞.

```cpp
// –ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ —Ç–µ–æ—Ä–µ–º–∞—Ç–∞ –Ω–∞ –ö–∏—Ä—Ö–æ—Ñ –≤—ä—Ä—Ö—É –õ–∞–ø–ª–∞—Å–æ–≤–∞—Ç–∞ –º–∞—Ç—Ä–∏—Ü–∞ –Ω–∞ –≥—Ä–∞—Ñ–æ–≤–∞—Ç–∞ –º—Ä–µ–∂–∞
// –û—Ç–≥–æ–≤–æ—Ä—ä—Ç –∏–º–∞ –∑–∞—Ç–≤–æ—Ä–µ–Ω–∞ —Ñ–æ—Ä–º–∞ –∑–∞ –º–∞–ª–∫–∏ –º—Ä–µ–∂–∏
```

---

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–¢–µ–æ—Ä–∏—è—Ç–∞ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏—Ç–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è –º–æ—â–Ω–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏ –∑–∞ —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ:

### –ö–ª—é—á–æ–≤–∏ —Ç–µ—Ö–Ω–∏–∫–∏:

1. **–ú–∞—Ç—Ä–∏—á–Ω–æ —Å—Ç–µ–ø–µ–Ω—É–≤–∞–Ω–µ**: $O(\log n)$ —Ä–µ—à–µ–Ω–∏–µ –∑–∞ –ª–∏–Ω–µ–π–Ω–∏ —Ä–µ–∫—É—Ä—Å–∏–∏
   - –§–∏–±–æ–Ω–∞—á–∏, –î–ü –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è, –±—Ä–æ–µ–Ω–µ –Ω–∞ –ø—ä—Ç–∏—â–∞
   - –í—Ä–µ–º–µ: $O(k^3 \log n)$ –∑–∞ $k \times k$ –º–∞—Ç—Ä–∏—Ü–∞

2. **–¢–µ–æ—Ä–µ–º–∞ –Ω–∞ –ö–∏—Ä—Ö–æ—Ñ**: –ë—Ä–æ–µ–Ω–µ –Ω–∞ –ø–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞ –≤ $O(n^3)$
   - –ü—Ä–µ–≤—Ä—ä—â–∞–Ω–µ –Ω–∞ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∏–∫–∞ –≤ –ª–∏–Ω–µ–π–Ω–∞ –∞–ª–≥–µ–±—Ä–∞
   - –¢–æ—á–Ω–∏ –±—Ä–æ–µ–Ω–∏—è –ø–æ –º–æ–¥—É–ª –ø—Ä–æ—Å—Ç–æ —á–∏—Å–ª–æ

3. **–î–≤–æ–∏—á–Ω–∞ –≥–∞—É—Å–æ–≤–∞ –µ–ª–∏–º–∏–Ω–∞—Ü–∏—è**: XOR —Å–∏—Å—Ç–µ–º–∏ –≤ $O(n^3/64)$
   - Lights Out, XOR –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ, —Ç–µ–æ—Ä–∏—è –Ω–∞ –∏–≥—Ä–∏—Ç–µ
   - Bitset –∑–∞ 64√ó —É—Å–∫–æ—Ä–µ–Ω–∏–µ

4. **–ö–µ–π–ª–∏-–•–∞–º–∏–ª—Ç—ä–Ω**: –ü–æ–ª–∏–Ω–æ–º–Ω–æ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ –Ω–∞ –º–∞—Ç—Ä–∏—á–Ω–∏ —Å—Ç–µ–ø–µ–Ω–∏
   - –†–µ–¥—É—Ü–∏—Ä–∞ –∏–∑—á–∏—Å–ª–µ–Ω–∏—è—Ç–∞ –∑–∞ —Å–ø–µ—Ü–∏–∞–ª–Ω–∏ –º–∞—Ç—Ä–∏—Ü–∏
   - –ü–æ-—Å–∫–æ—Ä–æ —Ç–µ–æ—Ä–µ—Ç–∏—á–µ–Ω –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –æ—Ç –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏

### –û–±–æ–±—â–µ–Ω–∏–µ –Ω–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç—Ç–∞:

| –û–ø–µ—Ä–∞—Ü–∏—è | –í—Ä–µ–º–µ–≤–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç | –ü–∞–º–µ—Ç |
|----------|------------------|-------|
| –£–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏ | $O(n^3)$ | $O(n^2)$ |
| –ú–∞—Ç—Ä–∏—á–Ω–æ —Å—Ç–µ–ø–µ–Ω—É–≤–∞–Ω–µ | $O(n^3 \log k)$ | $O(n^2)$ |
| –î–µ—Ç–µ—Ä–º–∏–Ω–∞–Ω—Ç–∞ | $O(n^3)$ | $O(n^2)$ |
| –ì–∞—É—Å–æ–≤–∞ –µ–ª–∏–º–∏–Ω–∞—Ü–∏—è | $O(n^3)$ –∏–ª–∏ $O(n^3/64)$ | $O(n^2)$ |
| –ë—Ä–æ–π –ø–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞ | $O(n^3)$ | $O(n^2)$ |

### –ö–æ–≥–∞ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –º–∞—Ç—Ä–∏—Ü–∏:

- **–õ–∏–Ω–µ–π–Ω–∏ —Ä–µ–∫—É—Ä—Å–∏–∏** —Å –≥–æ–ª—è–º–æ $n$: –ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –º–∞—Ç—Ä–∏—á–Ω–æ —Å—Ç–µ–ø–µ–Ω—É–≤–∞–Ω–µ
- **–ë—Ä–æ–µ–Ω–µ –Ω–∞ –ø—ä—Ç–∏—â–∞** –≤ –≥—Ä–∞—Ñ–∏: –°—Ç–µ–ø–µ–Ω–∏ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞—Ç–∞ –Ω–∞ —Å—ä—Å–µ–¥—Å—Ç–≤–æ
- **–ë—Ä–æ–µ–Ω–µ –Ω–∞ –ø–æ–∫—Ä–∏–≤–∞—â–∏ –¥—ä—Ä–≤–µ—Ç–∞**: –¢–µ–æ—Ä–µ–º–∞ –Ω–∞ –ö–∏—Ä—Ö–æ—Ñ
- **XOR –∑–∞–¥–∞—á–∏**: –î–≤–æ–∏—á–Ω–∞ –≥–∞—É—Å–æ–≤–∞ –µ–ª–∏–º–∏–Ω–∞—Ü–∏—è
- **–î–ü –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è**: –ú–∞—Ç—Ä–∏—á–Ω–æ –ø—Ä–µ–¥—Å—Ç–∞–≤—è–Ω–µ –Ω–∞ –ø—Ä–µ—Ö–æ–¥–∏—Ç–µ

–ú–∞—Ç—Ä–∏—á–Ω–∏—Ç–µ —Ç–µ—Ö–Ω–∏–∫–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–∞—Ç –ø—Ä–∏–≤–∏–¥–Ω–æ —Å–ª–æ–∂–Ω–∏ –∑–∞–¥–∞—á–∏ –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ –ø–æ –ª–∏–Ω–µ–π–Ω–∞ –∞–ª–≥–µ–±—Ä–∞, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—è–π–∫–∏ –µ–ª–µ–≥–∞–Ω—Ç–Ω–∏ –∏ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–∏ —Ä–µ—à–µ–Ω–∏—è. –û–≤–ª–∞–¥–µ–π—Ç–µ —Ç–µ–∑–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏ –∏ —â–µ –∏–º–∞—Ç–µ –∑–Ω–∞—á–∏—Ç–µ–ª–Ω–æ –ø—Ä–µ–¥–∏–º—Å—Ç–≤–æ –≤ –Ω–∞–ø—Ä–µ–¥–Ω–∞–ª–æ—Ç–æ —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ!