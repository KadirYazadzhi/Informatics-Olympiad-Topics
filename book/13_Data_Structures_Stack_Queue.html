
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ“¦ Data Structures: Stack and Queue.</title>
    <style>
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif; margin: 0; display: flex; height: 100vh; color: #333; }
a { color: #007bff; text-decoration: none; }
a:hover { text-decoration: underline; }
.sidebar { width: 300px; background: #f5f7f9; border-right: 1px solid #e1e4e8; overflow-y: auto; padding: 20px; flex-shrink: 0; }
.sidebar h3 { margin-top: 0; color: #555; }
.sidebar ul { list-style: none; padding: 0; }
.sidebar li { margin-bottom: 8px; }
.sidebar li a { color: #364149; display: block; padding: 5px; border-radius: 4px; }
.sidebar li a:hover, .sidebar li a.active { background: #fff; color: #007bff; }
.content-wrapper { flex-grow: 1; overflow-y: auto; padding: 40px 60px; max-width: 900px; margin: 0 auto; }
.content { line-height: 1.6; }
h1, h2, h3 { color: #242a31; margin-top: 1.5em; }
h1 { border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
code { background: #f0f0f0; padding: 2px 5px; border-radius: 3px; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace; font-size: 0.9em; }
pre { background: #f6f8fa; padding: 16px; border-radius: 6px; overflow-x: auto; }
pre code { background: none; padding: 0; font-size: 0.9em; color: #333; }
table { border-collapse: collapse; width: 100%; margin: 20px 0; }
th, td { border: 1px solid #dfe2e5; padding: 8px 12px; }
th { background: #f6f8fa; }
blockquote { border-left: 4px solid #dfe2e5; color: #6a737d; padding-left: 16px; margin: 20px 0; }
.nav-buttons { margin-top: 40px; display: flex; justify-content: space-between; border-top: 1px solid #eaecef; padding-top: 20px; }
.nav-btn { padding: 10px 20px; border: 1px solid #e1e4e8; border-radius: 4px; color: #333; }
.nav-btn:hover { border-color: #007bff; color: #007bff; text-decoration: none; }
</style>
</head>
<body>
    <div class="sidebar">
        <h3>ğŸ“š Topics</h3>
        <ul>
            <li><a href="index.html">Introduction</a></li><li><a href="01_Cpp_Environment_Data_Types_IO.html">ğŸ–¥ï¸ C++ Programming Environment. Simple Data Types. Input and Output.</a></li><li><a href="02_Operations_Conditionals.html">â• Operations in C++. Conditional Operators. Compound Operator.</a></li><li><a href="03_Loops_Functions_Strings.html">ğŸ”„ Loops. Nested Loops. Functions in C++. Strings.</a></li><li><a href="04_Basic_Divisibility_Tasks.html">ğŸ”¢ Basic Tasks Related to Number Divisibility.</a></li><li><a href="05_Date_and_Time_Tasks.html">ğŸ“… Tasks Related to Dates and Time.</a></li><li><a href="06_One_Dimensional_Array.html">ğŸ“‚ One-dimensional Arrays.</a></li><li><a href="07_Arrays_Basic_Tasks.html">ğŸ“‚ One-dimensional Arrays and Basic Tasks.</a></li><li><a href="08_Number_Divisibility_Euclidean_Algorithm.html">â— Number Divisibility, Euclidean Algorithm and Applications.</a></li><li><a href="09_Numeral_Systems.html">ğŸ”¢ Numeral Systems.</a></li><li><a href="10_Two_Dimensional_Arrays.html">ğŸ“Š Two-dimensional Arrays and Tabular Data Processing.</a></li><li><a href="11_Basic_Computational_Geometry.html">ğŸ§­ Basic Knowledge of Computational Geometry.</a></li><li><a href="12_Intro_to_STL.html">ğŸ“š Introduction to the Standard Template Library (STL) and Sorting/Searching Tools.</a></li><li><a href="13_Data_Structures_Stack_Queue.html" class="active">ğŸ“¦ Data Structures: Stack and Queue.</a></li><li><a href="14_Recursion.html">ğŸ” Concept of Recursion.</a></li><li><a href="15_Intro_to_Combinatorics.html">ğŸ”€ Introduction to Combinatorial Configurations.</a></li><li><a href="16_Graph_Concept.html">ğŸŒ Concept of a Graph.</a></li><li><a href="17_STL_Containers_Iterators_Algorithms.html">ğŸ“š STL Standard Library: Containers, Iterators, and Basic Algorithms.</a></li><li><a href="18_Algorithm_Analysis_Quick_Search_Sort.html">ğŸ“Š Algorithm Analysis. Fast Search and Fast Sort.</a></li><li><a href="19_Modular_Arithmetic.html">â• Modular Arithmetic.</a></li><li><a href="20_Polynomials_BigInt.html">ğŸ“ˆ Polynomials. Implementation of Long Number Operations.</a></li><li><a href="21_Game_Theory.html">ğŸ® Games with Parity and Symmetry Strategies.</a></li><li><a href="22_Bitwise_Operations.html">ğŸ’» Bitwise Operations and Applications.</a></li><li><a href="23_Dynamic_Programming.html">ğŸ”„ Dynamic Programming: Classic One-dimensional and Two-dimensional Problems.</a></li><li><a href="24_Graph_Algorithms.html">ğŸŒ Graphs: Representation and Traversal.</a></li><li><a href="25_Union_Find.html">ğŸ”— Disjoint Set Union (DSU) / Union-Find Structure.</a></li><li><a href="26_Tree_Structures.html">ğŸŒ² Binary Trees and Search Trees.</a></li><li><a href="27_Advanced_Geometry_SweepLine.html">ğŸ“ Computational Geometry: Oriented Point Triplets and Applications.</a></li><li><a href="28_Advanced_Combinatorics.html">ğŸ”„ Permutations: Basic Properties.</a></li><li><a href="29_Arithmetic_Expressions.html">â— Arithmetic Expressions: Representation, Calculation, and Transformation.</a></li><li><a href="30_Hashing.html">ğŸ”‘ Hashing.</a></li><li><a href="31_Special_Number_Sequences.html">â• Catalan Numbers. Gray Codes. Partitioning of Sets and Numbers.</a></li><li><a href="32_Geometry_Polygons.html">ğŸ“ Computational Geometry: Relative Position of Points and Lines.</a></li><li><a href="33_Advanced_Graph_Algorithms.html">ğŸŒ Graphs: Biconnectivity, Strong Connectivity, Matchings.</a></li><li><a href="34_Advanced_Data_Structures.html">ğŸ“‚ Advanced Data Structures:</a></li><li><a href="35_Advanced_DP.html">ğŸ”„ Dynamic Programming: Profiles, Recursions, and Relations.</a></li><li><a href="36_String_Algorithms.html">ğŸ“ Strings: Efficient Structures and Algorithms.</a></li><li><a href="37_Advanced_Game_Theory.html">ğŸ® Games: Nim, Alpha-Beta Pruning. Reactive Games.</a></li><li><a href="38_Matrices.html">ğŸ“Š Matrices: Multiplication and Exponentiation.</a></li><li><a href="39_Voronoi_Diagrams.html">ğŸ“ Voronoi Diagrams.</a></li><li><a href="40_Flows_Cuts.html">ğŸŒŠ Minimum Cut.</a></li><li><a href="41_Advanced_Heaps.html">ğŸŒ² Complex Variants of Heaps (Binomial and Fibonacci Heaps).</a></li><li><a href="42_Suffix_Structures.html">ğŸ”¤ Formal Grammars, Automata.</a></li><li><a href="43_Linear_Systems.html">ğŸ§® Systems of Linear Equations.</a></li><li><a href="44_Complex_Numbers_FFT.html">ğŸ“ Complex Numbers.</a></li>
        </ul>
    </div>
    <div class="content-wrapper">
        <div class="content">
            <h1>ğŸ“š Data Structures: Stack and Queue</h1>
<p>Data structures "stack" and "queue" are fundamental elements in programming and are widely used to solve various problems. In this material, we will examine their characteristics, basic operations, and how they can be implemented via the Standard Template Library (STL) of C++.</p>
<h2>ğŸ“‹ Content</h2>
<ol>
<li><strong>What is a Stack?</strong>  <ul>
<li>Basic Operations  </li>
<li>Example of using a stack  </li>
</ul>
</li>
<li><strong>What is a Queue?</strong>  <ul>
<li>Basic Operations  </li>
<li>Example of using a queue  </li>
</ul>
</li>
<li><strong>Variations of Stacks and Queues</strong>  <ul>
<li><code>std::deque</code>  </li>
<li>Priority Queue (<code>std::priority_queue</code>)  </li>
</ul>
</li>
<li><strong>Real-world Applications of Stack and Queue</strong>  </li>
</ol>
<h2>ğŸŸ¢ What is a Stack?</h2>
<p>A stack is a data structure that follows the "Last In, First Out" (LIFO) principle. This means that the last added element is the first one to be removed.</p>
<h3>Basic Operations</h3>
<ol>
<li><strong><code>push</code></strong> - adding an element to the top of the stack.</li>
<li><strong><code>pop</code></strong> - removing an element from the top of the stack.</li>
<li><strong><code>top</code></strong> - retrieving the value of the top element without removing it.</li>
<li><strong><code>empty</code></strong> - checking if the stack is empty.</li>
</ol>
<h3>Example of Using a Stack</h3>
<pre><code class="language-cpp">#include &lt;stack&gt;
#include &lt;iostream&gt;

int main() {
    std::stack&lt;int&gt; stack;

    // Adding elements
    stack.push(10);
    stack.push(20);
    stack.push(30);

    // Outputting and removing elements
    while (!stack.empty()) {
        std::cout &lt;&lt; &quot;Top of stack: &quot; &lt;&lt; stack.top() &lt;&lt; std::endl;
        stack.pop();
    }

    return 0;
}
</code></pre>
<h2>ğŸŸ¡ What is a Queue?</h2>
<p>A queue is a data structure that follows the "First In, First Out" (FIFO) principle. This means that the first added element is the first one to be removed.</p>
<h3>Basic Operations</h3>
<ol>
<li><strong><code>push</code></strong> - adding an element to the end of the queue.</li>
<li><strong><code>pop</code></strong> - removing an element from the beginning of the queue.</li>
<li><strong><code>front</code></strong> - retrieving the value of the first element.</li>
<li><strong><code>back</code></strong> - retrieving the value of the last element.</li>
<li><strong><code>empty</code></strong> - checking if the queue is empty.</li>
</ol>
<h3>Example of Using a Queue</h3>
<pre><code class="language-cpp">#include &lt;queue&gt;
#include &lt;iostream&gt;

int main() {
    std::queue&lt;int&gt; queue;

    // Adding elements
    queue.push(1);
    queue.push(2);
    queue.push(3);

    // Outputting and removing elements
    while (!queue.empty()) {
        std::cout &lt;&lt; &quot;Front of queue: &quot; &lt;&lt; queue.front() &lt;&lt; std::endl;
        queue.pop();
    }

    return 0;
}
</code></pre>
<h2>ğŸ”„ Variations of Stacks and Queues</h2>
<h3>ğŸ“Œ Double-ended Queue (<code>std::deque</code>)</h3>
<p><code>std::deque</code> is a flexible structure that allows adding and removing elements from both the beginning and the end.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">#include &lt;deque&gt;
#include &lt;iostream&gt;

int main() {
    std::deque&lt;int&gt; deque;

    deque.push_back(10); // Add to end
    deque.push_front(20); // Add to beginning

    for (int num : deque) {
        std::cout &lt;&lt; num &lt;&lt; &quot; &quot;;
    }

    return 0;
}
</code></pre>
<h3>ğŸ“Š Priority Queue (<code>std::priority_queue</code>)</h3>
<p><code>std::priority_queue</code> is a special structure where elements are sorted according to priority.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-cpp">#include &lt;queue&gt;
#include &lt;iostream&gt;

int main() {
    std::priority_queue&lt;int&gt; pq;

    pq.push(10);
    pq.push(5);
    pq.push(20);

    while (!pq.empty()) {
        std::cout &lt;&lt; &quot;Highest priority: &quot; &lt;&lt; pq.top() &lt;&lt; std::endl;
        pq.pop();
    }

    return 0;
}
</code></pre>
<h2>ğŸ“ˆ Real-world Applications of Stack and Queue</h2>
<h3>1. <strong>Stack in Parentheses Analysis</strong></h3>
<pre><code class="language-cpp">#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

bool areParenthesesBalanced(const std::string&amp; expr) {
    std::stack&lt;char&gt; stack;
    for (char ch : expr) {
        if (ch == '(') {
            stack.push(ch);
        } else if (ch == ')') {
            if (stack.empty()) {
                return false;
            }
            stack.pop();
        }
    }
    return stack.empty();
}

int main() {
    std::string expr = &quot;(a+b)*(c-d)&quot;;
    if (areParenthesesBalanced(expr)) {
        std::cout &lt;&lt; &quot;Parentheses are balanced.&quot; &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; &quot;Parentheses are not balanced.&quot; &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
<h3>2. <strong>Queue for Task Management</strong></h3>
<pre><code class="language-cpp">#include &lt;queue&gt;
#include &lt;iostream&gt;

int main() {
    std::queue&lt;std::string&gt; tasks;

    tasks.push(&quot;Task 1&quot;);
    tasks.push(&quot;Task 2&quot;);
    tasks.push(&quot;Task 3&quot;);

    while (!tasks.empty()) {
        std::cout &lt;&lt; &quot;Executing: &quot; &lt;&lt; tasks.front() &lt;&lt; std::endl;
        tasks.pop();
    }

    return 0;
}
</code></pre>
<h2>ğŸ¯ Conclusion</h2>
<p>Data structures "stack" and "queue" are key tools for data management. Through STL, their implementation and usage become extremely efficient and easy to understand. Mastering these structures is an important step towards advanced programming.</p>
        </div>
        <div class="nav-buttons">
            <a href="12_Intro_to_STL.html" class="nav-btn">â¬… Prev</a>
            <a href="14_Recursion.html" class="nav-btn">Next â¡</a>
        </div>
    </div>
</body>
</html>
