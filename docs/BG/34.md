# üå≥ –ù–∞–ø—Ä–µ–¥–Ω–∞–ª–∏ –°—Ç—Ä—É–∫—Ç—É—Ä–∏ –æ—Ç –î–∞–Ω–Ω–∏: –ü—ä–ª–µ–Ω –ü—Ä–µ–≥–ª–µ–¥

–í —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ –º–Ω–æ–≥–æ –∑–∞–¥–∞—á–∏ –∏–∑–∏—Å–∫–≤–∞—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞ –ø–æ—Ä–µ–¥–∏—Ü–∞ –æ—Ç –∑–∞—è–≤–∫–∏ –≤—ä—Ä—Ö—É –º–∞—Å–∏–≤–∏. –î–æ–∫–∞—Ç–æ –Ω–∞–∏–≤–Ω–∏—è—Ç –ø–æ–¥—Ö–æ–¥ –æ—Ç–Ω–µ–º–∞ $O(N)$ –Ω–∞ –∑–∞—è–≤–∫–∞, —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–∏—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –ø–æ—Å—Ç–∏–≥–∞—Ç $O(\log N)$ –∏–ª–∏ –¥–æ—Ä–∏ $O(1)$.

---

## 1. –î—ä—Ä–≤–æ –Ω–∞ –§–µ–Ω—É–∏–∫ (Binary Indexed Tree - BIT)

BIT –µ –µ–ª–µ–≥–∞–Ω—Ç–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–∞ –ø—Ä–µ—Ñ–∏–∫—Å–Ω–∏ —Å—É–º–∏, –∫–æ—è—Ç–æ —Å–µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ —Å –∏–∑–∫–ª—é—á–∏—Ç–µ–ª–Ω–æ –º–∞–ª–∫–æ –∫–æ–¥.

*   **Update ($O(\log N)$)**: –ü—Ä–æ–º—è–Ω–∞ –Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –Ω–∞ –¥–∞–¥–µ–Ω –∏–Ω–¥–µ–∫—Å.
*   **Query ($O(\log N)$)**: –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ —Å—É–º–∞—Ç–∞ –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ $[0, i]$.

```cpp
int bit[MAXN];
int n;

void add(int idx, int val) {
    for (++idx; idx <= n; idx += idx & -idx)
        bit[idx] += val;
}

int sum(int idx) {
    int res = 0;
    for (++idx; idx > 0; idx -= idx & -idx)
        res += bit[idx];
    return res;
}

int range_sum(int l, int r) {
    return sum(r) - sum(l - 1);
}
```

---

## 2. –°–µ–≥–º–µ–Ω—Ç–Ω–æ –î—ä—Ä–≤–æ (Segment Tree)

–°–µ–≥–º–µ–Ω—Ç–Ω–æ—Ç–æ –¥—ä—Ä–≤–æ –µ –Ω–∞–π-—É–Ω–∏–≤–µ—Ä—Å–∞–ª–Ω–∞—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–Ω–∏ –∑–∞—è–≤–∫–∏. –¢–æ –º–æ–∂–µ –¥–∞ –ø–æ–¥–¥—ä—Ä–∂–∞ –≤—Å—è–∫–∞ –∞—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è: —Å—É–º–∞, –º–∏–Ω–∏–º—É–º, –º–∞–∫—Å–∏–º—É–º, –ù–û–î, —É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ –º–∞—Ç—Ä–∏—Ü–∏.

### 2.1. –ö–ª–∞—Å–∏—á–µ—Å–∫–æ –°–µ–≥–º–µ–Ω—Ç–Ω–æ –î—ä—Ä–≤–æ (Point Update)
```cpp
int tree[4 * MAXN];

void build(int a[], int v, int tl, int tr) {
    if (tl == tr) {
        tree[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a, 2*v, tl, tm);
        build(a, 2*v+1, tm+1, tr);
        tree[v] = tree[2*v] + tree[2*v+1];
    }
}

int query(int v, int tl, int tr, int l, int r) {
    if (l > r) return 0;
    if (l == tl && r == tr) return tree[v];
    int tm = (tl + tr) / 2;
    return query(2*v, tl, tm, l, min(r, tm))
         + query(2*v+1, tm+1, tr, max(l, tm+1), r);
}
```

### 2.2. Lazy Propagation (Range Update)
–ü–æ–∑–≤–æ–ª—è–≤–∞ –æ–±–Ω–æ–≤—è–≤–∞–Ω–µ –Ω–∞ —Ü—è–ª –∏–Ω—Ç–µ—Ä–≤–∞–ª (–Ω–∞–ø—Ä. "–¥–æ–±–∞–≤–∏ $X$ –∫—ä–º –≤—Å–∏—á–∫–∏ —á–∏—Å–ª–∞ –æ—Ç $L$ –¥–æ $R$") –∑–∞ $O(\log N)$.
–ò–¥–µ—è—Ç–∞ –µ –¥–∞ –æ—Ç–ª–æ–∂–∏–º –æ–±–Ω–æ–≤—è–≤–∞–Ω–µ—Ç–æ –Ω–∞ –¥–µ—Ü–∞—Ç–∞, –¥–æ–∫–∞—Ç–æ –Ω–µ —Å–µ –Ω–∞–ª–æ–∂–∏ –¥–∞ –≥–∏ –ø–æ—Å–µ—Ç–∏–º.

---

## 3. –†–∞–∑—Ä–µ–¥–µ–Ω–∞ –¢–∞–±–ª–∏—Ü–∞ (Sparse Table)

Sparse Table —Ä–µ—à–∞–≤–∞ RMQ (Range Minimum Query) –∑–∞ $O(1)$ —Å–ª–µ–¥ $O(N \log N)$ –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å–∏–Ω–≥. –ü—Ä–∏–ª–æ–∂–∏–º–∞ –µ —Å–∞–º–æ –∑–∞ **—Å—Ç–∞—Ç–∏—á–Ω–∏** –º–∞—Å–∏–≤–∏ (–±–µ–∑ –ø—Ä–æ–º–µ–Ω–∏).

*   **–ò–¥–µ—è**: –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–æ –ø—Ä–µ—Å–º—è—Ç–∞–º–µ –æ—Ç–≥–æ–≤–æ—Ä–∏—Ç–µ –∑–∞ –≤—Å–∏—á–∫–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∏ —Å –¥—ä–ª–∂–∏–Ω–∞ $2^k$.
*   **–ó–∞—è–≤–∫–∞**: –í—Å–µ–∫–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª $[L, R]$ –º–æ–∂–µ –¥–∞ –±—ä–¥–µ –ø–æ–∫—Ä–∏—Ç –æ—Ç –¥–≤–∞ –∑–∞—Å—Ç—ä–ø–≤–∞—â–∏ —Å–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ —Å –¥—ä–ª–∂–∏–Ω–∞ $2^k$, –∫—ä–¥–µ—Ç–æ $2^k$ –µ –Ω–∞–π-–≥–æ–ª—è–º–∞—Ç–∞ —Å—Ç–µ–ø–µ–Ω –Ω–∞ 2, –Ω–µ–Ω–∞–¥–≤–∏—à–∞–≤–∞—â–∞ –¥—ä–ª–∂–∏–Ω–∞—Ç–∞ –Ω–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞.

```cpp
int st[MAXN][20];
int logs[MAXN];

void build(int n, int a[]) {
    logs[1] = 0;
    for (int i = 2; i <= n; i++) logs[i] = logs[i/2] + 1;
    for (int i = 0; i < n; i++) st[i][0] = a[i];
    for (int j = 1; j < 20; j++)
        for (int i = 0; i + (1 << j) <= n; i++)
            st[i][j] = min(st[i][j-1], st[i + (1 << (j-1))][j-1]);
}

int query(int l, int r) {
    int j = logs[r - l + 1];
    return min(st[l][j], st[r - (1 << j) + 1][j]);
}
```

---

## 4. Sqrt Decomposition

–ê–∫–æ $N$ –µ –æ–∫–æ–ª–æ $10^5$, –º–æ–∂–µ–º –¥–∞ —Ä–∞–∑–¥–µ–ª–∏–º –º–∞—Å–∏–≤–∞ –Ω–∞ –±–ª–æ–∫–æ–≤–µ —Å —Ä–∞–∑–º–µ—Ä $\sqrt{N}$.
*   **Update**: $O(1)$ –∏–ª–∏ $O(\sqrt{N})$.
*   **Query**: $O(\sqrt{N})$.
*   **–ê–ª–≥–æ—Ä–∏—Ç—ä–º –Ω–∞ –ú–æ (Mo's Algorithm)**: –ü–æ–∑–≤–æ–ª—è–≤–∞ —Ä–µ—à–∞–≤–∞–Ω–µ –Ω–∞ —Å–ª–æ–∂–Ω–∏ –æ—Ñ–ª–∞–π–Ω –∑–∞—è–≤–∫–∏ (–Ω–∞–ø—Ä. –±—Ä–æ–π —Ä–∞–∑–ª–∏—á–Ω–∏ –µ–ª–µ–º–µ–Ω—Ç–∏) –∑–∞ $O((N+Q)\sqrt{N})$.

---

## 5. –ó–∞–¥–∞—á–∏
1.  **CSES Dynamic Range Minimum Queries**: –°–µ–≥–º–µ–Ω—Ç–Ω–æ –¥—ä—Ä–≤–æ.
2.  **CSES Static Range Sum Queries**: –ü—Ä–µ—Ñ–∏–∫—Å–Ω–∏ —Å—É–º–∏.
3.  **Codeforces 86D**: Powerful array (Mo's algorithm).
4.  **SPOJ GSS1**: Can you answer these queries I (SegTree).

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ
–ó–∞–ø–æ—á–Ω–µ—Ç–µ —Å BIT –∑–∞ —Å—É–º–∏. –ê–∫–æ –≤–∏ —Ç—Ä—è–±–≤–∞ Min/Max, –Ω–∞—É—á–µ—Ç–µ Sparse Table. –ó–∞ —Å–ª–æ–∂–Ω–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏, –°–µ–≥–º–µ–Ω—Ç–Ω–æ—Ç–æ –¥—ä—Ä–≤–æ –µ –Ω–µ–∑–∞–º–µ–Ω–∏–º–æ.