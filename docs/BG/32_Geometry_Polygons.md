# üî∑ –ì–µ–æ–º–µ—Ç—Ä–∏—è –Ω–∞ –ü–æ–ª–∏–≥–æ–Ω–∏

–ü–æ–ª–∏–≥–æ–Ω—ä—Ç –µ –∑–∞—Ç–≤–æ—Ä–µ–Ω–∞ –≤–µ—Ä–∏–≥–∞ –æ—Ç –æ—Ç—Å–µ—á–∫–∏. –í —Å—ä—Å—Ç–µ–∑–∞–Ω–∏—è—Ç–∞ –≤—ä—Ä—Ö–æ–≤–µ—Ç–µ –æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ —Å–µ –¥–∞–≤–∞—Ç –≤ —Ä–µ–¥ (–ø–æ –∏–ª–∏ –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ —á–∞—Å–æ–≤–Ω–∏–∫–æ–≤–∞—Ç–∞ —Å—Ç—Ä–µ–ª–∫–∞).

–ü–æ–ª–∏–≥–æ–Ω—ä—Ç —Å–µ –Ω–∞—Ä–∏—á–∞ **–ø—Ä–æ—Å—Ç**, –∞–∫–æ –Ω–µ–≥–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏ –Ω–µ —Å–µ –ø—Ä–µ—Å–∏—á–∞—Ç –µ–¥–Ω–∞ —Å –¥—Ä—É–≥–∞ (–æ—Å–≤–µ–Ω –≤ –æ–±—â–∏—Ç–µ –≤—ä—Ä—Ö–æ–≤–µ). –ü–æ–ª–∏–≥–æ–Ω—ä—Ç —Å–µ –Ω–∞—Ä–∏—á–∞ **–∏–∑–ø—ä–∫–Ω–∞–ª**, –∞–∫–æ –≤—Å–∏—á–∫–∏ –≤—ä—Ç—Ä–µ—à–Ω–∏ —ä–≥–ª–∏ —Å–∞ –ø–æ-–º–∞–ª–∫–∏ –æ—Ç 180¬∞ –∏ –≤—Å–µ–∫–∏ –æ—Ç—Ä–µ–∑—ä–∫ –º–µ–∂–¥—É –¥–≤–µ —Ç–æ—á–∫–∏ –≤ –ø–æ–ª–∏–≥–æ–Ω–∞ –ª–µ–∂–∏ –∏–∑—Ü—è–ª–æ –≤—ä—Ç—Ä–µ –≤ –Ω–µ–≥–æ.

## 0. –û—Å–Ω–æ–≤–Ω–∏ –î–µ—Ñ–∏–Ω–∏—Ü–∏–∏ –∏ –°—Ç—Ä—É–∫—Ç—É—Ä–∏

```cpp
struct Point {
    long long x, y;
    Point(long long x = 0, long long y = 0) : x(x), y(y) {}
    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }
    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }
};

// –í–µ–∫—Ç–æ—Ä–Ω–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ (Cross Product)
long long cross(const Point& a, const Point& b) {
    return (long long)a.x * b.y - (long long)a.y * b.x;
}

// –°–∫–∞–ª–∞—Ä–Ω–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ (Dot Product)
long long dot(const Point& a, const Point& b) {
    return (long long)a.x * b.x + (long long)a.y * b.y;
}

// –î—ä–ª–∂–∏–Ω–∞ –Ω–∞ –≤–µ–∫—Ç–æ—Ä –Ω–∞ –∫–≤–∞–¥—Ä–∞—Ç
long long len2(const Point& a) {
    return a.x * a.x + a.y * a.y;
}
```

## 1. –õ–∏—Ü–µ –Ω–∞ –ü–æ–ª–∏–≥–æ–Ω (Shoelace Formula)

–ü–ª–æ—â—Ç–∞ –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–ª–µ–Ω –ø—Ä–æ—Å—Ç –ø–æ–ª–∏–≥–æ–Ω —Å –≤—ä—Ä—Ö–æ–≤–µ $(x_1, y_1), \dots, (x_n, y_n)$ –º–æ–∂–µ –¥–∞ —Å–µ –ø—Ä–µ—Å–º–µ—Ç–Ω–µ —á—Ä–µ–∑ **—Ñ–æ—Ä–º—É–ª–∞—Ç–∞ –Ω–∞ –æ–±—É—â–∞—Ä—Å–∫–∏—è –≤—Ä—ä–∑–∫–∞** (Shoelace Formula). –¢—è –µ –±–∞–∑–∏—Ä–∞–Ω–∞ –Ω–∞ –æ—Ä–∏–µ–Ω—Ç–∏—Ä–∞–Ω–∏—Ç–µ –ª–∏—Ü–∞ –Ω–∞ —Ç—Ä–∞–ø–µ—Ü–∏ (–∏–ª–∏ —Ç—Ä–∏—ä–≥—ä–ª–Ω–∏—Ü–∏).

$2 \cdot S = \left| \sum_{i=1}^{n} (x_i y_{i+1} - x_{i+1} y_i) \right|$

–∫—ä–¥–µ—Ç–æ $(x_{n+1}, y_{n+1}) = (x_1, y_1)$.

### –ì–µ–æ–º–µ—Ç—Ä–∏—á–Ω–∞ –ò–Ω—Ç—É–∏—Ü–∏—è
–§–æ—Ä–º—É–ª–∞—Ç–∞ —Ä–∞–±–æ—Ç–∏, –∫–∞—Ç–æ —Ä–∞–∑–≥–ª–µ–∂–¥–∞ –≤—Å—è–∫–∞ —Å—Ç—Ä–∞–Ω–∞ –Ω–∞ –ø–æ–ª–∏–≥–æ–Ω–∞ –∏ –∏–∑—á–∏—Å–ª—è–≤–∞ "–æ—Ä–∏–µ–Ω—Ç–∏—Ä–∞–Ω–æ—Ç–æ –ª–∏—Ü–µ" –Ω–∞ —Ç—Ä–∞–ø–µ—Ü–∞, –æ–±—Ä–∞–∑—É–≤–∞–Ω –º–µ–∂–¥—É —Ç–∞–∑–∏ —Å—Ç—Ä–∞–Ω–∞ –∏ x-–æ—Å—Ç–∞. –ê–∫–æ –≤—ä—Ä—Ö–æ–≤–µ—Ç–µ —Å–∞ –≤ –æ–±—Ä–∞—Ç–µ–Ω —Ä–µ–¥ –Ω–∞ —á–∞—Å–æ–≤–Ω–∏–∫–æ–≤–∞—Ç–∞ —Å—Ç—Ä–µ–ª–∫–∞, —Å—É–º–∞—Ç–∞ –¥–∞–≤–∞ –ø–æ–ª–æ–∂–∏—Ç–µ–ª–Ω–∞ –ø–ª–æ—â; –∞–∫–æ —Å–∞ –ø–æ —á–∞—Å–æ–≤–Ω–∏–∫–æ–≤–∞—Ç–∞ —Å—Ç—Ä–µ–ª–∫–∞ ‚Äì –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª–Ω–∞.

### –ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è
```cpp
// –í—Ä—ä—â–∞ —É–¥–≤–æ–µ–Ω–æ—Ç–æ –ª–∏—Ü–µ (2 * S)
long long polygonArea2(const vector<Point>& p) {
    long long area = 0;
    int n = p.size();
    for (int i = 0; i < n; i++) {
        area += cross(p[i], p[(i + 1) % n]);
    }
    return abs(area); // –ê–±—Å–æ–ª—é—Ç–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –∑–∞ –ø–æ–ª–æ–∂–∏—Ç–µ–ª–Ω–æ –ª–∏—Ü–µ
}

// –í—Ä—ä—â–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–Ω–æ—Ç–æ –ª–∏—Ü–µ (–º–æ–∂–µ –¥–∞ –µ –¥—Ä–æ–±–Ω–æ)
double polygonArea(const vector<Point>& p) {
    return polygonArea2(p) / 2.0;
}

// –ó–Ω–∞–∫–æ–≤–æ –ª–∏—Ü–µ (–ø–æ–∑–∏—Ç–∏–≤–Ω–æ –∞–∫–æ –≤—ä—Ä—Ö–æ–≤–µ—Ç–µ —Å–∞ counter-clockwise)
long long signedArea2(const vector<Point>& p) {
    long long area = 0;
    int n = p.size();
    for (int i = 0; i < n; i++) {
        area += cross(p[i], p[(i + 1) % n]);
    }
    return area;
}
```

### –ü—Ä–∏–º–µ—Ä
–ó–∞ –∫–≤–∞–¥—Ä–∞—Ç —Å –≤—ä—Ä—Ö–æ–≤–µ $(0, 0), (2, 0), (2, 2), (0, 2)$:
- $2S = |0 \cdot 0 - 2 \cdot 0 + 2 \cdot 2 - 2 \cdot 0 + 2 \cdot 2 - 0 \cdot 2 + 0 \cdot 0 - 0 \cdot 2| = |0 + 4 + 4 + 0| = 8$
- $S = 4$ (–∫–æ—Ä–µ–∫—Ç–Ω–æ –∑–∞ –∫–≤–∞–¥—Ä–∞—Ç —Å—ä—Å —Å—Ç—Ä–∞–Ω–∞ 2)

## 2. –ü–µ—Ä–∏–º–µ—Ç—ä—Ä –Ω–∞ –ü–æ–ª–∏–≥–æ–Ω

–ü–µ—Ä–∏–º–µ—Ç—ä—Ä—ä—Ç –µ —Å—É–º–∞—Ç–∞ –æ—Ç –¥—ä–ª–∂–∏–Ω–∏—Ç–µ –Ω–∞ –≤—Å–∏—á–∫–∏ —Å—Ç—Ä–∞–Ω–∏ –Ω–∞ –ø–æ–ª–∏–≥–æ–Ω–∞.

```cpp
// –ü–µ—Ä–∏–º–µ—Ç—ä—Ä (–¥—Ä–æ–±–Ω–æ —á–∏—Å–ª–æ)
double polygonPerimeter(const vector<Point>& p) {
    double perimeter = 0;
    int n = p.size();
    for (int i = 0; i < n; i++) {
        Point diff = p[(i + 1) % n] - p[i];
        perimeter += sqrt(len2(diff));
    }
    return perimeter;
}

// –ó–∞ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ - –Ω–∞ –∫–≤–∞–¥—Ä–∞—Ç
long long polygonPerimeter2(const vector<Point>& p) {
    long long perimeter2 = 0;
    int n = p.size();
    for (int i = 0; i < n; i++) {
        Point diff = p[(i + 1) % n] - p[i];
        perimeter2 += len2(diff);
    }
    return perimeter2;
}
```

## 3. –¢–µ–æ—Ä–µ–º–∞ –Ω–∞ –ü–∏–∫ (Pick's Theorem)

–ó–∞ –ø–æ–ª–∏–≥–æ–Ω, —á–∏–∏—Ç–æ –≤—ä—Ä—Ö–æ–≤–µ —Å–∞ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ (lattice polygon):
$S = I + \frac{B}{2} - 1$

*   $S$: –õ–∏—Ü–µ –Ω–∞ –ø–æ–ª–∏–≥–æ–Ω–∞.
*   $I$: –ë—Ä–æ–π —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–∏ —Ç–æ—á–∫–∏ **–≤—ä—Ç—Ä–µ** –≤ –ø–æ–ª–∏–≥–æ–Ω–∞.
*   $B$: –ë—Ä–æ–π —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–∏ —Ç–æ—á–∫–∏ **–ø–æ –≥—Ä–∞–Ω–∏—Ü–∞—Ç–∞** (boundary).

### –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ B (Boundary Points)
$B$ –º–æ–∂–µ –¥–∞ —Å–µ –Ω–∞–º–µ—Ä–∏, –∫–∞—Ç–æ —Å–µ —Å—É–º–∏—Ä–∞—Ç –ù–û–î –Ω–∞ —Ä–∞–∑–ª–∏–∫–∏—Ç–µ –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏—Ç–µ –∑–∞ –≤—Å—è–∫–∞ —Å—Ç—Ä–∞–Ω–∞:
$B = \sum_{i=1}^{n} \gcd(|x_i - x_{i+1}|, |y_i - y_{i+1}|)$

```cpp
long long gcd(long long a, long long b) {
    return b ? gcd(b, a % b) : a;
}

// –ë—Ä–æ–π —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–∏ —Ç–æ—á–∫–∏ –ø–æ –≥—Ä–∞–Ω–∏—Ü–∞—Ç–∞
long long boundaryPoints(const vector<Point>& p) {
    long long B = 0;
    int n = p.size();
    for (int i = 0; i < n; i++) {
        Point diff = p[(i + 1) % n] - p[i];
        B += gcd(abs(diff.x), abs(diff.y));
    }
    return B;
}

// –ë—Ä–æ–π —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–∏ —Ç–æ—á–∫–∏ –≤—ä—Ç—Ä–µ (–∏–∑–ø–æ–ª–∑–≤–∞–π–∫–∏ Pick's Theorem)
long long interiorPoints(const vector<Point>& p) {
    long long area2 = polygonArea2(p);
    long long B = boundaryPoints(p);
    // S = I + B/2 - 1  =>  I = S - B/2 + 1
    // 2S = 2I + B - 2  =>  I = (2S - B + 2) / 2
    return (area2 - B + 2) / 2;
}
```

### –ü—Ä–∏–º–µ—Ä
–ó–∞ —Ç—Ä–∏—ä–≥—ä–ª–Ω–∏–∫ —Å –≤—ä—Ä—Ö–æ–≤–µ $(0, 0), (3, 0), (0, 4)$:
- –õ–∏—Ü–µ: $S = \frac{3 \cdot 4}{2} = 6$
- $B = \gcd(3, 0) + \gcd(3, 4) + \gcd(0, 4) = 3 + 1 + 4 = 8$
- $I = S - \frac{B}{2} + 1 = 6 - 4 + 1 = 3$

## 4. –¢–æ—á–∫–∞ –≤ –ü–æ–ª–∏–≥–æ–Ω (Point in Polygon)

### 4.1. –ò–∑–ø—ä–∫–Ω–∞–ª –ø–æ–ª–∏–≥–æ–Ω
–ó–∞ –∏–∑–ø—ä–∫–Ω–∞–ª –ø–æ–ª–∏–≥–æ–Ω –º–æ–∂–µ –¥–∞ —Å–µ —Ä–µ—à–∏ –∑–∞ $O(\log N)$ —Å –¥–≤–æ–∏—á–Ω–æ —Ç—ä—Ä—Å–µ–Ω–µ –ø–æ —ä–≥–ª–∏—Ç–µ.

```cpp
// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ —Ç–æ—á–∫–∞ –µ –≤ –∏–∑–ø—ä–∫–Ω–∞–ª –ø–æ–ª–∏–≥–æ–Ω (O(log n))
bool inConvexPolygon(const vector<Point>& p, Point pt) {
    int n = p.size();
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ —Ç–æ—á–∫–∞—Ç–∞ –µ –æ—Ç –ø—Ä–∞–≤–∏–ª–Ω–∞—Ç–∞ —Å—Ç—Ä–∞–Ω–∞ –Ω–∞ –≤—Å–∏—á–∫–∏ —Å—Ç—Ä–∞–Ω–∏
    bool pos = false, neg = false;
    for (int i = 0; i < n; i++) {
        long long cp = cross(p[(i + 1) % n] - p[i], pt - p[i]);
        if (cp > 0) pos = true;
        if (cp < 0) neg = true;
    }
    return !(pos && neg); // –í—ä—Ç—Ä–µ, –∞–∫–æ –≤—Å–∏—á–∫–∏ cross products —Å–∞ —Å –µ–¥–∏–Ω –∑–Ω–∞–∫
}
```

### 4.2. –ü—Ä–æ–∏–∑–≤–æ–ª–µ–Ω –ø–æ–ª–∏–≥–æ–Ω (Ray Casting)
–ó–∞ –ø—Ä–æ–∏–∑–≤–æ–ª–µ–Ω (–Ω–µ –Ω–µ–ø—Ä–µ–º–µ–Ω–Ω–æ –∏–∑–ø—ä–∫–Ω–∞–ª) –ø–æ–ª–∏–≥–æ–Ω –∏–∑–ø–æ–ª–∑–≤–∞–º–µ **–∞–ª–≥–æ—Ä–∏—Ç—ä–º–∞ Ray Casting**.

**–ò–¥–µ—è:** –ü—É—Å–∫–∞–º–µ –ª—ä—á –æ—Ç —Ç–æ—á–∫–∞—Ç–∞ $P$ –Ω–∞–¥—è—Å–Ω–æ (–∫—ä–º $+\infty$). –ë—Ä–æ–∏–º –∫–æ–ª–∫–æ –ø—ä—Ç–∏ –ª—ä—á—ä—Ç –ø—Ä–µ—Å–∏—á–∞ —Å—Ç—Ä–∞–Ω–∏—Ç–µ –Ω–∞ –ø–æ–ª–∏–≥–æ–Ω–∞.
*   –ù–µ—á–µ—Ç–µ–Ω –±—Ä–æ–π –ø—Ä–µ—Å–∏—á–∞–Ω–∏—è $\implies$ –¢–æ—á–∫–∞—Ç–∞ –µ **–≤—ä—Ç—Ä–µ**.
*   –ß–µ—Ç–µ–Ω –±—Ä–æ–π (–≤–∫–ª—é—á–∏—Ç–µ–ª–Ω–æ 0) $\implies$ –¢–æ—á–∫–∞—Ç–∞ –µ **–≤—ä–Ω**.

**–ì—Ä–∞–Ω–∏—á–Ω–∏ —Å–ª—É—á–∞–∏:**
- –¢–æ—á–∫–∞—Ç–∞ –ª–µ–∂–∏ —Ç–æ—á–Ω–æ –Ω–∞ —Ä—ä–±
- –õ—ä—á—ä—Ç –º–∏–Ω–∞–≤–∞ –ø—Ä–µ–∑ –≤—Ä—ä—Ö –Ω–∞ –ø–æ–ª–∏–≥–æ–Ω–∞
- –õ—ä—á—ä—Ç –µ —É—Å–ø–æ—Ä–µ–¥–µ–Ω –Ω–∞ –Ω—è–∫–æ—è —Å—Ç—Ä–∞–Ω–∞

```cpp
// Ray Casting –∞–ª–≥–æ—Ä–∏—Ç—ä–º - –ø—Ä–æ–∏–∑–≤–æ–ª–µ–Ω –ø–æ–ª–∏–≥–æ–Ω
bool isInside(const vector<Point>& p, Point pt) {
    int n = p.size();
    bool inside = false;
    for (int i = 0, j = n - 1; i < n; j = i++) {
        // –ü—Ä–æ–≤–µ—Ä—è–≤–∞–º–µ –¥–∞–ª–∏ –ª—ä—á—ä—Ç –ø—Ä–µ—Å–∏—á–∞ —Ä—ä–±–∞ (j, i)
        if (((p[i].y > pt.y) != (p[j].y > pt.y)) &&
            (pt.x < (p[j].x - p[i].x) * (pt.y - p[i].y) / (double)(p[j].y - p[i].y) + p[i].x)) {
            inside = !inside;
        }
    }
    return inside;
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ —Ç–æ—á–∫–∞ –ª–µ–∂–∏ –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞—Ç–∞ –Ω–∞ –ø–æ–ª–∏–≥–æ–Ω–∞
bool onBoundary(const vector<Point>& p, Point pt) {
    int n = p.size();
    for (int i = 0; i < n; i++) {
        Point a = p[i], b = p[(i + 1) % n];
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ pt –ª–µ–∂–∏ –Ω–∞ –æ—Ç—Å–µ—á–∫–∞—Ç–∞ [a, b]
        if (cross(pt - a, b - a) == 0 &&
            min(a.x, b.x) <= pt.x && pt.x <= max(a.x, b.x) &&
            min(a.y, b.y) <= pt.y && pt.y <= max(a.y, b.y)) {
            return true;
        }
    }
    return false;
}

// –ü—ä–ª–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞: –≤—ä—Ç—Ä–µ, –≤—ä–Ω –∏–ª–∏ –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞—Ç–∞
// –í—Ä—ä—â–∞: 0 = –≤—ä–Ω, 1 = –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞—Ç–∞, 2 = –≤—ä—Ç—Ä–µ
int pointInPolygon(const vector<Point>& p, Point pt) {
    if (onBoundary(p, pt)) return 1;
    return isInside(p, pt) ? 2 : 0;
}
```

### 4.3. Winding Number Algorithm
–ê–ª—Ç–µ—Ä–Ω–∞—Ç–∏–≤–µ–Ω –º–µ—Ç–æ–¥, –∫–æ–π—Ç–æ –±—Ä–æ–∏ –∫–æ–ª–∫–æ –ø—ä—Ç–∏ –ø–æ–ª–∏–≥–æ–Ω—ä—Ç "–æ–±–≤–∏–≤–∞" —Ç–æ—á–∫–∞—Ç–∞.

```cpp
// Winding number - –ø–æ-—Ä–æ–±—É—Å—Ç–µ–Ω –∑–∞ –¥–µ–ª–∏–∫–∞—Ç–Ω–∏ —Å–ª—É—á–∞–∏
int windingNumber(const vector<Point>& p, Point pt) {
    int wn = 0;
    int n = p.size();
    for (int i = 0; i < n; i++) {
        Point a = p[i], b = p[(i + 1) % n];
        if (a.y <= pt.y) {
            if (b.y > pt.y && cross(b - a, pt - a) > 0)
                wn++;
        } else {
            if (b.y <= pt.y && cross(b - a, pt - a) < 0)
                wn--;
        }
    }
    return wn; // != 0 –æ–∑–Ω–∞—á–∞–≤–∞ –≤—ä—Ç—Ä–µ
}
```

## 5. –ò–∑–ø—ä–∫–Ω–∞–ª–æ—Å—Ç (Convexity Check)

–ü–æ–ª–∏–≥–æ–Ω –µ **–∏–∑–ø—ä–∫–Ω–∞–ª**, –∞–∫–æ –≤—Å–∏—á–∫–∏ –∑–∞–≤–æ–∏ —Å–∞ –≤ –µ–¥–Ω–∞ –∏ —Å—ä—â–∞ –ø–æ—Å–æ–∫–∞ (—Å–∞–º–æ –Ω–∞–ª—è–≤–æ –∏–ª–∏ —Å–∞–º–æ –Ω–∞–¥—è—Å–Ω–æ). –¢–æ–≤–∞ –æ–∑–Ω–∞—á–∞–≤–∞, —á–µ –≤—Å–∏—á–∫–∏ –≤—ä—Ç—Ä–µ—à–Ω–∏ —ä–≥–ª–∏ —Å–∞ –ø–æ-–º–∞–ª–∫–∏ –æ—Ç 180¬∞.

–ü–æ–ª–∏–≥–æ–Ω –µ **–≤–¥–ª—ä–±–Ω–∞—Ç (concave)**, –∞–∫–æ –∏–º–∞ –ø–æ–Ω–µ –µ–¥–∏–Ω –≤—ä—Ç—Ä–µ—à–µ–Ω —ä–≥—ä–ª –ø–æ-–≥–æ–ª—è–º –æ—Ç 180¬∞.

### –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –ò–∑–ø—ä–∫–Ω–∞–ª–æ—Å—Ç
–ò–∑–ø–æ–ª–∑–≤–∞–º–µ –≤–µ–∫—Ç–æ—Ä–Ω–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ (cross product) –∑–∞ –≤—Å–µ–∫–∏ —Ç—Ä–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏ –≤—ä—Ä—Ö–∞. –ê–∫–æ –≤—Å–∏—á–∫–∏ –∏–º–∞—Ç –µ–¥–∏–Ω –∏ —Å—ä—â–∏ –∑–Ω–∞–∫, –ø–æ–ª–∏–≥–æ–Ω—ä—Ç –µ –∏–∑–ø—ä–∫–Ω–∞–ª.

```cpp
// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –ø–æ–ª–∏–≥–æ–Ω –µ –∏–∑–ø—ä–∫–Ω–∞–ª
bool isConvex(const vector<Point>& p) {
    int n = p.size();
    if (n < 3) return false;
    
    bool hasPos = false, hasNeg = false;
    for (int i = 0; i < n; i++) {
        Point a = p[i];
        Point b = p[(i + 1) % n];
        Point c = p[(i + 2) % n];
        
        long long cp = cross(b - a, c - b);
        if (cp > 0) hasPos = true;
        if (cp < 0) hasNeg = true;
    }
    
    return !(hasPos && hasNeg); // –ò–∑–ø—ä–∫–Ω–∞–ª, –∞–∫–æ –≤—Å–∏—á–∫–∏ —Å–∞ —Å –µ–¥–∏–Ω –∑–Ω–∞–∫
}

// –û–ø—Ä–µ–¥–µ–ª—è–Ω–µ –Ω–∞ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è—Ç–∞ (–ø–æ –∏–ª–∏ –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ —á–∞—Å–æ–≤–Ω–∏–∫–æ–≤–∞—Ç–∞ —Å—Ç—Ä–µ–ª–∫–∞)
// –í—Ä—ä—â–∞: 1 = counter-clockwise, -1 = clockwise, 0 = –¥–µ–≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω
int orientation(const vector<Point>& p) {
    long long area = signedArea2(p);
    if (area > 0) return 1;  // CCW
    if (area < 0) return -1; // CW
    return 0; // –î–µ–≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω
}

// –û–±—Ä—ä—â–∞–Ω–µ –Ω–∞ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è—Ç–∞ –Ω–∞ –ø–æ–ª–∏–≥–æ–Ω
void reversePolygon(vector<Point>& p) {
    reverse(p.begin(), p.end());
}
```

### –î–µ—Ç–µ–∫—Ü–∏—è –Ω–∞ –ò–∑–ø—ä–∫–ª–∏ –∏ –í–¥–ª—ä–±–Ω–∞—Ç–∏ –í—ä—Ä—Ö–æ–≤–µ
```cpp
// –ö–ª–∞—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –Ω–∞ –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö: –∏–∑–ø—ä–∫–Ω–∞–ª (convex) –∏–ª–∏ –≤–¥–ª—ä–±–Ω–∞—Ç (reflex)
// –í—Ä—ä—â–∞ –≤–µ–∫—Ç–æ—Ä: true = –∏–∑–ø—ä–∫–Ω–∞–ª –≤—Ä—ä—Ö, false = –≤–¥–ª—ä–±–Ω–∞—Ç –≤—Ä—ä—Ö
vector<bool> classifyVertices(const vector<Point>& p) {
    int n = p.size();
    vector<bool> isConvexVertex(n);
    
    for (int i = 0; i < n; i++) {
        Point a = p[(i - 1 + n) % n];
        Point b = p[i];
        Point c = p[(i + 1) % n];
        
        long long cp = cross(b - a, c - b);
        // –ó–∞ CCW –ø–æ–ª–∏–≥–æ–Ω: cp > 0 => –∏–∑–ø—ä–∫–Ω–∞–ª –≤—Ä—ä—Ö
        isConvexVertex[i] = (cp >= 0);
    }
    
    return isConvexVertex;
}
```

## 6. –¢—Ä–∏–∞–Ω–≥—É–ª–∞—Ü–∏—è –Ω–∞ –ü–æ–ª–∏–≥–æ–Ω

–í—Å–µ–∫–∏ –ø—Ä–æ—Å—Ç –ø–æ–ª–∏–≥–æ–Ω –º–æ–∂–µ –¥–∞ –±—ä–¥–µ —Ä–∞–∑–¥–µ–ª–µ–Ω –Ω–∞ —Ç—Ä–∏—ä–≥—ä–ª–Ω–∏—Ü–∏. –¢–æ–≤–∞ –µ –ø–æ–ª–µ–∑–Ω–æ –∑–∞ –º–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∏ –∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏.

### 6.1. Ear Clipping Method
–ú–µ—Ç–æ–¥ "–æ—Ç—Ä—è–∑–≤–∞–Ω–µ –Ω–∞ —É—à–∏" - –Ω–∞–º–∏—Ä–∞ "—É—Ö–æ" (—Ç—Ä–∏—ä–≥—ä–ª–Ω–∏–∫, —á–∏–∏—Ç–æ –¥–∏–∞–≥–æ–Ω–∞–ª –µ –≤—ä—Ç—Ä–µ –≤ –ø–æ–ª–∏–≥–æ–Ω–∞) –∏ –≥–æ –ø—Ä–µ–º–∞—Ö–≤–∞.

```cpp
// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ —Ç—Ä–∏—ä–≥—ä–ª–Ω–∏–∫ (a, b, c) —Å—ä–¥—ä—Ä–∂–∞ —Ç–æ—á–∫–∞ p
bool triangleContains(Point a, Point b, Point c, Point p) {
    long long cp1 = cross(b - a, p - a);
    long long cp2 = cross(c - b, p - b);
    long long cp3 = cross(a - c, p - c);
    
    return (cp1 >= 0 && cp2 >= 0 && cp3 >= 0) ||
           (cp1 <= 0 && cp2 <= 0 && cp3 <= 0);
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –¥–∏–∞–≥–æ–Ω–∞–ª—ä—Ç –æ—Ç i –¥–æ k –µ –≤–∞–ª–∏–¥–µ–Ω (–Ω–µ –ø—Ä–µ—Å–∏—á–∞ –ø–æ–ª–∏–≥–æ–Ω–∞)
bool isValidDiagonal(const vector<Point>& p, int i, int k) {
    int n = p.size();
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –¥–∏–∞–≥–æ–Ω–∞–ª—ä—Ç –µ –≤—ä—Ç—Ä–µ –≤ –ø–æ–ª–∏–≥–æ–Ω–∞
    Point mid = Point((p[i].x + p[k].x) / 2, (p[i].y + p[k].y) / 2);
    if (!isInside(p, mid)) return false;
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –Ω—è–∫–æ–π –≤—Ä—ä—Ö –µ –≤—ä—Ç—Ä–µ –≤ —Ç—Ä–∏—ä–≥—ä–ª–Ω–∏–∫–∞
    for (int j = 0; j < n; j++) {
        if (j == i || j == k || j == (i + 1) % n) continue;
        if (triangleContains(p[i], p[(i + 1) % n], p[k], p[j]))
            return false;
    }
    
    return true;
}

// Ear Clipping —Ç—Ä–∏–∞–Ω–≥—É–ª–∞—Ü–∏—è (O(n^2) –∑–∞ –ø—Ä–æ—Å—Ç–∏ –ø–æ–ª–∏–≥–æ–Ω–∏)
vector<array<int, 3>> triangulate(vector<Point> p) {
    vector<array<int, 3>> triangles;
    int n = p.size();
    vector<int> indices(n);
    for (int i = 0; i < n; i++) indices[i] = i;
    
    while (indices.size() > 3) {
        bool found = false;
        for (int i = 0; i < indices.size(); i++) {
            int prev = (i - 1 + indices.size()) % indices.size();
            int next = (i + 1) % indices.size();
            
            Point a = p[indices[prev]];
            Point b = p[indices[i]];
            Point c = p[indices[next]];
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ —Ç–æ–≤–∞ –µ "—É—Ö–æ"
            if (cross(b - a, c - b) > 0) {
                bool isEar = true;
                for (int j = 0; j < indices.size(); j++) {
                    if (j == prev || j == i || j == next) continue;
                    if (triangleContains(a, b, c, p[indices[j]])) {
                        isEar = false;
                        break;
                    }
                }
                
                if (isEar) {
                    triangles.push_back({indices[prev], indices[i], indices[next]});
                    indices.erase(indices.begin() + i);
                    found = true;
                    break;
                }
            }
        }
        if (!found) break; // –ù–µ –º–æ–∂–µ –¥–∞ —Å–µ —Ç—Ä–∏–∞–Ω–≥—É–ª–∏—Ä–∞
    }
    
    if (indices.size() == 3) {
        triangles.push_back({indices[0], indices[1], indices[2]});
    }
    
    return triangles;
}
```

### 6.2. –ú–æ–Ω–æ—Ç–æ–Ω–Ω–∞ –¢—Ä–∏–∞–Ω–≥—É–ª–∞—Ü–∏—è (–∑–∞ –Ω–∞–ø—Ä–µ–¥–Ω–∞–ª–∏)
–ó–∞ –∏–∑–ø—ä–∫–Ω–∞–ª–∏ –ø–æ–ª–∏–≥–æ–Ω–∏ —Ç—Ä–∏–∞–Ω–≥—É–ª–∞—Ü–∏—è—Ç–∞ –µ —Ç—Ä–∏–≤–∏–∞–ª–Ω–∞ - –≤—Å–∏—á–∫–∏ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ –æ—Ç –µ–¥–∏–Ω –≤—Ä—ä—Ö.

```cpp
// –¢—Ä–∏–∞–Ω–≥—É–ª–∞—Ü–∏—è –Ω–∞ –∏–∑–ø—ä–∫–Ω–∞–ª –ø–æ–ª–∏–≥–æ–Ω –æ—Ç –≤—Ä—ä—Ö 0
vector<array<int, 3>> triangulateConvex(int n) {
    vector<array<int, 3>> triangles;
    for (int i = 1; i < n - 1; i++) {
        triangles.push_back({0, i, i + 1});
    }
    return triangles;
}
```

## 7. –†–∞–∑–ª–∞–≥–∞–Ω–µ –Ω–∞ –ü–æ–ª–∏–≥–æ–Ω (Decomposition)

### 7.1. –†–∞–∑–ª–∞–≥–∞–Ω–µ –Ω–∞ –ò–∑–ø—ä–∫–Ω–∞–ª–∏ –ß–∞—Å—Ç–∏
–í–¥–ª—ä–±–Ω–∞—Ç –ø–æ–ª–∏–≥–æ–Ω –º–æ–∂–µ –¥–∞ —Å–µ —Ä–∞–∑–¥–µ–ª–∏ –Ω–∞ –∏–∑–ø—ä–∫–Ω–∞–ª–∏ —á–∞—Å—Ç–∏.

```cpp
// –ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –≤—Å–∏—á–∫–∏ –≤–¥–ª—ä–±–Ω–∞—Ç–∏ –≤—ä—Ä—Ö–æ–≤–µ (reflex vertices)
vector<int> findReflexVertices(const vector<Point>& p) {
    vector<int> reflex;
    int n = p.size();
    
    for (int i = 0; i < n; i++) {
        Point a = p[(i - 1 + n) % n];
        Point b = p[i];
        Point c = p[(i + 1) % n];
        
        if (cross(b - a, c - b) < 0) { // –ó–∞ CCW –ø–æ–ª–∏–≥–æ–Ω
            reflex.push_back(i);
        }
    }
    
    return reflex;
}
```

## 8. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è –∏ –°–ø–µ—Ü–∏–∞–ª–Ω–∏ –°–ª—É—á–∞–∏

### 8.1. –¶–µ–Ω—Ç—ä—Ä –Ω–∞ –¢–µ–∂–µ—Å—Ç (Centroid)
```cpp
// –¶–µ–Ω—Ç—ä—Ä –Ω–∞ —Ç–µ–∂–µ—Å—Ç –Ω–∞ –ø–æ–ª–∏–≥–æ–Ω
Point centroid(const vector<Point>& p) {
    long long cx = 0, cy = 0, area = 0;
    int n = p.size();
    
    for (int i = 0; i < n; i++) {
        long long cp = cross(p[i], p[(i + 1) % n]);
        cx += (p[i].x + p[(i + 1) % n].x) * cp;
        cy += (p[i].y + p[(i + 1) % n].y) * cp;
        area += cp;
    }
    
    // –î–µ–ª–∏–º –Ω–∞ 3 * –ø–ª–æ—â—Ç–∞ (–∑–∞ –¥–∞ –∏–∑–±–µ–≥–Ω–µ–º –¥–µ–ª–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ –Ω–∞ –Ω–∞—Ç—Ä—É–ø–≤–∞–Ω–µ)
    return Point(cx / (3 * area), cy / (3 * area));
}
```

### 8.2. –ù–∞–π-–¥–∞–ª–µ—á–Ω–∞ –î–≤–æ–π–∫–∞ –¢–æ—á–∫–∏ (Rotating Calipers)
–ó–∞ –∏–∑–ø—ä–∫–Ω–∞–ª –ø–æ–ª–∏–≥–æ–Ω –º–æ–∂–µ–º –¥–∞ –Ω–∞–º–µ—Ä–∏–º –Ω–∞–π-–¥–∞–ª–µ—á–Ω–∞—Ç–∞ –¥–≤–æ–π–∫–∞ —Ç–æ—á–∫–∏ –∑–∞ O(n).

### 8.3. –ú–∏–Ω–∫–æ–≤—Å–∫–∏ –°—É–º–∞
–°—É–º–∞—Ç–∞ –Ω–∞ –¥–≤–∞ –ø–æ–ª–∏–≥–æ–Ω–∞ $P + Q = \{p + q : p \in P, q \in Q\}$.

### 8.4. –ü—Ä–µ—Å–∏—á–∞–Ω–µ –Ω–∞ –ü–æ–ª–∏–≥–æ–Ω–∏
–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –¥–≤–∞ –ø–æ–ª–∏–≥–æ–Ω–∞ —Å–µ –ø—Ä–µ—Å–∏—á–∞—Ç –∏–ª–∏ –µ–¥–∏–Ω —Å—ä–¥—ä—Ä–∂–∞ –¥—Ä—É–≥.

```cpp
// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –¥–≤–∞ –∏–∑–ø—ä–∫–Ω–∞–ª–∏ –ø–æ–ª–∏–≥–æ–Ω–∞ —Å–µ –ø—Ä–µ—Å–∏—á–∞—Ç
bool convexPolygonsIntersect(const vector<Point>& p1, const vector<Point>& p2) {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –Ω—è–∫–æ–π –≤—Ä—ä—Ö –Ω–∞ p1 –µ –≤ p2
    for (const Point& pt : p1) {
        if (inConvexPolygon(p2, pt)) return true;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –Ω—è–∫–æ–π –≤—Ä—ä—Ö –Ω–∞ p2 –µ –≤ p1
    for (const Point& pt : p2) {
        if (inConvexPolygon(p1, pt)) return true;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –Ω—è–∫–æ–∏ —Å—Ç—Ä–∞–Ω–∏ —Å–µ –ø—Ä–µ—Å–∏—á–∞—Ç
    for (int i = 0; i < p1.size(); i++) {
        for (int j = 0; j < p2.size(); j++) {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –ø—Ä–µ—Å–∏—á–∞–Ω–µ –Ω–∞ –æ—Ç—Å–µ—á–∫–∏ [p1[i], p1[i+1]] –∏ [p2[j], p2[j+1]]
            // (–∏–∑–∏—Å–∫–≤–∞ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞ –ø—Ä–µ—Å–∏—á–∞–Ω–µ –Ω–∞ –æ—Ç—Å–µ—á–∫–∏)
        }
    }
    
    return false;
}
```

## 9. –°–ø–µ—Ü–∏–∞–ª–Ω–∏ –°–ª—É—á–∞–∏ –∏ –ì—Ä–µ—à–∫–∏

### –ß–µ—Å—Ç–æ –°—Ä–µ—â–∞–Ω–∏ –ì—Ä–µ—à–∫–∏:
1. **–î–µ–ª–µ–Ω–∏–µ —Å –Ω—É–ª–∞** –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –ø—Ä–µ—Å–∏—á–∞–Ω–µ
2. **Overflow** - –≤–∏–Ω–∞–≥–∏ –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ `long long` –∑–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏
3. **–ì—Ä–µ—à–∫–∏ –ø—Ä–∏ –∑–∞–∫—Ä—ä–≥–ª—è–Ω–µ** - —Ä–∞–±–æ—Ç–µ—Ç–µ —Å —É–¥–≤–æ–µ–Ω–æ –ª–∏—Ü–µ (2*S) –¥–æ–∫–∞—Ç–æ –µ –≤—ä–∑–º–æ–∂–Ω–æ
4. **–î–µ–≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ —Å–ª—É—á–∞–∏** - –∫–æ–ª–∏–Ω–µ–∞—Ä–Ω–∏ —Ç–æ—á–∫–∏, –ø–æ–ª–∏–≥–æ–Ω —Å –ø–ª–æ—â 0
5. **–ì—Ä–∞–Ω–∏—á–Ω–∏ —Å–ª—É—á–∞–∏** –ø—Ä–∏ Point-in-Polygon - —Ç–æ—á–∫–∞ –Ω–∞ —Ä—ä–± –∏–ª–∏ –≤—Ä—ä—Ö

### –ü—Ä–æ–≤–µ—Ä–∫–∏ –∑–∞ –í–∞–ª–∏–¥–Ω–æ—Å—Ç:
```cpp
// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –ø–æ–ª–∏–≥–æ–Ω –µ –≤–∞–ª–∏–¥–µ–Ω (–Ω–µ —Å–µ —Å–∞–º–æ–ø–µ—Ä–µ—Å–∏—á–∞)
bool isSimplePolygon(const vector<Point>& p) {
    int n = p.size();
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ —Å–∞–º–æ–ø—Ä–µ—Å–∏—á–∞–Ω–µ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏
    for (int i = 0; i < n; i++) {
        for (int j = i + 2; j < n; j++) {
            if (j == (i + n - 1) % n) continue; // –°—ä—Å–µ–¥–Ω–∏ —Å—Ç—Ä–∞–Ω–∏
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –æ—Ç—Å–µ—á–∫–∏ [i, i+1] –∏ [j, j+1] —Å–µ –ø—Ä–µ—Å–∏—á–∞—Ç
            // (–∏–∑–∏—Å–∫–≤–∞ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞ –ø—Ä–µ—Å–∏—á–∞–Ω–µ –Ω–∞ –æ—Ç—Å–µ—á–∫–∏)
        }
    }
    return true;
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –¥–µ–≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω –ø–æ–ª–∏–≥–æ–Ω (—Å –ø–ª–æ—â 0)
bool isDegenerate(const vector<Point>& p) {
    return polygonArea2(p) == 0;
}
```

## 10. –ó–∞–¥–∞—á–∏
1.  **Codeforces 166B**: Polygon (Point inside convex polygon).
2.  **POJ 1265**: Area (Pick's theorem).
3.  **SPOJ GSSQ**: General queries.

## 11. –°–ª–æ–∂–Ω–æ—Å—Ç –∏ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

### –í—Ä–µ–º–µ–≤–∞ –°–ª–æ–∂–Ω–æ—Å—Ç:
- **–õ–∏—Ü–µ –Ω–∞ –ø–æ–ª–∏–≥–æ–Ω**: O(n)
- **–ü–µ—Ä–∏–º–µ—Ç—ä—Ä**: O(n)
- **Point in Polygon (Ray Casting)**: O(n)
- **Point in Polygon (–∏–∑–ø—ä–∫–Ω–∞–ª, –¥–≤–æ–∏—á–Ω–æ —Ç—ä—Ä—Å–µ–Ω–µ)**: O(log n)
- **–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –∏–∑–ø—ä–∫–Ω–∞–ª–æ—Å—Ç**: O(n)
- **–¢—Ä–∏–∞–Ω–≥—É–ª–∞—Ü–∏—è (Ear Clipping)**: O(n¬≤)
- **–¢—Ä–∏–∞–Ω–≥—É–ª–∞—Ü–∏—è (–æ–ø—Ç–∏–º–∞–ª–Ω–∞)**: O(n log n)

### –°—ä–≤–µ—Ç–∏ –∑–∞ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è:
1. –ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ `long long` –∑–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏, –∑–∞ –¥–∞ –∏–∑–±–µ–≥–Ω–µ—Ç–µ overflow
2. –†–∞–±–æ—Ç–µ—Ç–µ —Å —É–¥–≤–æ–µ–Ω–æ –ª–∏—Ü–µ (2*S) –¥–æ–∫–∞—Ç–æ –µ –≤—ä–∑–º–æ–∂–Ω–æ
3. –ö–µ—à–∏—Ä–∞–π—Ç–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –∫–∞—Ç–æ –ª–∏—Ü–µ –∏ –ø–µ—Ä–∏–º–µ—Ç—ä—Ä, –∞–∫–æ —Å–µ –∏–∑–ø–æ–ª–∑–≤–∞—Ç –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ
4. –ó–∞ –∏–∑–ø—ä–∫–Ω–∞–ª–∏ –ø–æ–ª–∏–≥–æ–Ω–∏ –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–∞–Ω–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∏
5. –ò–∑–±—è–≥–≤–∞–π—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –ø–ª–∞–≤–∞—â–∞ –∑–∞–ø–µ—Ç–∞—è, –∫–æ–≥–∞—Ç–æ –µ –≤—ä–∑–º–æ–∂–Ω–æ

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ì–µ–æ–º–µ—Ç—Ä–∏—è—Ç–∞ –Ω–∞ –ø–æ–ª–∏–≥–æ–Ω–∏ –µ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª–Ω–∞ —Ç–µ–º–∞ –≤ —Å—ä—Å—Ç–µ–∑–∞—Ç–µ–ª–Ω–æ—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ. –û—Å–Ω–æ–≤–Ω–∏—Ç–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –≤–∫–ª—é—á–≤–∞—Ç:

‚úÖ **–í–∏–Ω–∞–≥–∏ —Ä–∞–±–æ—Ç–µ—Ç–µ —Å $2 \cdot S$ (—É–¥–≤–æ–µ–Ω–æ –ª–∏—Ü–µ)**, –∑–∞ –¥–∞ –æ—Å—Ç–∞–Ω–µ—Ç–µ –≤ —Ü–µ–ª–∏—Ç–µ —á–∏—Å–ª–∞ (`long long`) –¥–æ –ø–æ—Å–ª–µ–¥–Ω–∏—è –º–æ–º–µ–Ω—Ç.

‚úÖ **–í–Ω–∏–º–∞–≤–∞–π—Ç–µ –∑–∞ overflow** - –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ `long long` –∑–∞ –≤—Å–∏—á–∫–∏ –º–µ–∂–¥–∏–Ω–Ω–∏ –∏–∑—á–∏—Å–ª–µ–Ω–∏—è.

‚úÖ **–¢–µ—Å—Ç–≤–∞–π—Ç–µ –≥—Ä–∞–Ω–∏—á–Ω–∏ —Å–ª—É—á–∞–∏** - –¥–µ–≥–µ–Ω–µ—Ä–∏—Ä–∞–Ω–∏ –ø–æ–ª–∏–≥–æ–Ω–∏, –∫–æ–ª–∏–Ω–µ–∞—Ä–Ω–∏ —Ç–æ—á–∫–∏, —Ç–æ—á–∫–∏ –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞—Ç–∞.

‚úÖ **–ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –≤–µ–∫—Ç–æ—Ä–Ω–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ** - —Ç–æ –µ –æ—Å–Ω–æ–≤–µ–Ω –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∑–∞ –ø–æ–≤–µ—á–µ—Ç–æ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –ø–æ–ª–∏–≥–æ–Ω–∏.

‚úÖ **–†–∞–∑–±–∏—Ä–∞–π—Ç–µ —Ä–∞–∑–ª–∏–∫–∞—Ç–∞** –º–µ–∂–¥—É –∏–∑–ø—ä–∫–Ω–∞–ª–∏ –∏ –≤–¥–ª—ä–±–Ω–∞—Ç–∏ –ø–æ–ª–∏–≥–æ–Ω–∏ - —Ä–∞–∑–ª–∏—á–Ω–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∏ –∏–º–∞—Ç —Ä–∞–∑–ª–∏—á–Ω–∞ –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç.

–ü—Ä–∞–∫—Ç–∏–∫—É–≤–∞–π—Ç–µ —Å —Ä–µ–∞–ª–Ω–∏ –∑–∞–¥–∞—á–∏, –∑–∞ –¥–∞ –∑–∞—Ç–≤—ä—Ä–¥–∏—Ç–µ –ø–æ–∑–Ω–∞–Ω–∏—è—Ç–∞ —Å–∏!