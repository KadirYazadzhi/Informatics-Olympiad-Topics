# üß† –ù–∞–ø—Ä–µ–¥–Ω–∞–ª–æ –î–∏–Ω–∞–º–∏—á–Ω–æ –ü—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ (Advanced DP)

–°–ª–µ–¥ –∫–∞—Ç–æ –æ–≤–ª–∞–¥–µ–µ—Ç–µ –∫–ª–∞—Å–∏—á–µ—Å–∫–æ—Ç–æ DP (–†–∞–Ω–∏—Ü–∞, LIS, LCS), —Å–ª–µ–¥–≤–∞—â–æ—Ç–æ –Ω–∏–≤–æ –≤–∫–ª—é—á–≤–∞ —Ç–µ—Ö–Ω–∏–∫–∏ –∑–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ —Å—ä—Å—Ç–æ—è–Ω–∏—è—Ç–∞ –∏ –ø—Ä–µ—Ö–æ–¥–∏—Ç–µ. –ù–∞–ø—Ä–µ–¥–Ω–∞–ª–∏—Ç–µ DP —Ç–µ—Ö–Ω–∏–∫–∏ –≤–∏ –ø–æ–∑–≤–æ–ª—è–≤–∞—Ç –¥–∞ —Ä–µ—à–∞–≤–∞—Ç–µ –∑–∞–¥–∞—á–∏ —Å –ø–æ-—Å–ª–æ–∂–Ω–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –æ—Ç –¥–∞–Ω–Ω–∏ (–¥—ä—Ä–≤–µ—Ç–∞, –≥—Ä–∞—Ñ–∏, –±–∏—Ç–æ–≤–∏ –º–∞—Å–∫–∏) –∏ –¥–∞ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–∞—Ç–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—Ç–∞ –æ—Ç $O(N^2)$ –∏–ª–∏ $O(N^3)$ –¥–æ $O(N \log N)$ –∏–ª–∏ –¥–æ—Ä–∏ $O(N)$.

## 1. –î–ü –≤—ä—Ä—Ö—É –î—ä—Ä–≤–æ (Tree DP)

–ó–∞–¥–∞—á–∏—Ç–µ –≤—ä—Ä—Ö—É –¥—ä—Ä–≤–µ—Ç–∞ —á–µ—Å—Ç–æ —Å–µ —Ä–µ—à–∞–≤–∞—Ç —Å DFS, –∫–∞—Ç–æ –∑–∞ –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö $u$ –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ $dp[u]$ –Ω–∞ –±–∞–∑–∞—Ç–∞ –Ω–∞ –¥–µ—Ü–∞—Ç–∞ –º—É. –ò–¥–µ—è—Ç–∞ –µ –¥–∞ —Ä–∞–∑–≥–ª–µ–∂–¥–∞–º–µ –¥—ä—Ä–≤–æ—Ç–æ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ - –ø—ä—Ä–≤–æ –æ–±—Ä–∞–±–æ—Ç–≤–∞–º–µ –ø–æ–¥–¥—ä—Ä–≤–µ—Ç–∞—Ç–∞, –ø–æ—Å–ª–µ –∫–æ–º–±–∏–Ω–∏—Ä–∞–º–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏—Ç–µ.

### 1.1. –ö–ª–∞—Å–∏—á–µ—Å–∫–æ Tree DP
–ü—Ä–∏–º–µ—Ä: –ú–∞–∫—Å–∏–º–∞–ª–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –º–Ω–æ–∂–µ—Å—Ç–≤–æ (Maximum Independent Set) –≤ –¥—ä—Ä–≤–æ.

–û–ø—Ä–µ–¥–µ–ª—è–º–µ —Å—ä—Å—Ç–æ—è–Ω–∏—è:
- $dp[u][0]$: –º–∞–∫—Å–∏–º–∞–ª–µ–Ω –±—Ä–æ–π –∏–∑–±—Ä–∞–Ω–∏ –≤—ä—Ä—Ö–æ–≤–µ –≤ –ø–æ–¥–¥—ä—Ä–≤–æ—Ç–æ –Ω–∞ $u$, –∫–æ–≥–∞—Ç–æ $u$ **–Ω–µ –µ –∏–∑–±—Ä–∞–Ω**
- $dp[u][1]$: –º–∞–∫—Å–∏–º–∞–ª–µ–Ω –±—Ä–æ–π –∏–∑–±—Ä–∞–Ω–∏ –≤—ä—Ä—Ö–æ–≤–µ –≤ –ø–æ–¥–¥—ä—Ä–≤–æ—Ç–æ –Ω–∞ $u$, –∫–æ–≥–∞—Ç–æ $u$ **–µ –∏–∑–±—Ä–∞–Ω**

–ü—Ä–µ—Ö–æ–¥–∏:
- –ê–∫–æ $u$ –Ω–µ –µ –∏–∑–±—Ä–∞–Ω: $dp[u][0] = \sum_{v \in children(u)} \max(dp[v][0], dp[v][1])$
- –ê–∫–æ $u$ –µ –∏–∑–±—Ä–∞–Ω: $dp[u][1] = 1 + \sum_{v \in children(u)} dp[v][0]$

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;
vector<int> adj[MAXN];
int dp[MAXN][2];

void dfs(int u, int parent) {
    dp[u][0] = 0; // u –Ω–µ –µ –∏–∑–±—Ä–∞–Ω
    dp[u][1] = 1; // u –µ –∏–∑–±—Ä–∞–Ω
    
    for (int v : adj[u]) {
        if (v == parent) continue;
        dfs(v, u);
        
        // –ê–∫–æ u –Ω–µ –µ –∏–∑–±—Ä–∞–Ω, –¥–µ—Ç–µ—Ç–æ –º–æ–∂–µ –¥–∞ –µ –∏–ª–∏ –¥–∞ –Ω–µ –µ
        dp[u][0] += max(dp[v][0], dp[v][1]);
        
        // –ê–∫–æ u –µ –∏–∑–±—Ä–∞–Ω, –¥–µ—Ç–µ—Ç–æ –Ω–µ –º–æ–∂–µ –¥–∞ –µ –∏–∑–±—Ä–∞–Ω–æ
        dp[u][1] += dp[v][0];
    }
}

int main() {
    int n;
    cin >> n;
    
    for (int i = 0; i < n - 1; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    dfs(1, 0);
    cout << max(dp[1][0], dp[1][1]) << endl;
    
    return 0;
}
```

### 1.2. –û—â–µ –ø—Ä–∏–º–µ—Ä–∏ –∑–∞ Tree DP

**–î–∏–∞–º–µ—Ç—ä—Ä –Ω–∞ –¥—ä—Ä–≤–æ:** –ó–∞ –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö –ø–∞–∑–∏–º –Ω–∞–π-–¥—ä–ª–≥–∏—è –ø—ä—Ç, –∫–æ–π—Ç–æ –º–∏–Ω–∞–≤–∞ –ø—Ä–µ–∑ –Ω–µ–≥–æ.

```cpp
int maxPath[MAXN]; // –Ω–∞–π-–¥—ä–ª–≥–∏—è—Ç –ø—ä—Ç –º–∏–Ω–∞–≤–∞—â –ø—Ä–µ–∑ u
int maxDown[MAXN]; // –Ω–∞–π-–¥—ä–ª–≥–∏—è—Ç –ø—ä—Ç –Ω–∞–¥–æ–ª—É –æ—Ç u

void dfs(int u, int p) {
    maxDown[u] = 0;
    int max1 = 0, max2 = 0; // –¥–≤–∞—Ç–∞ –Ω–∞–π-–¥—ä–ª–≥–∏ –ø—ä—Ç—è –Ω–∞–¥–æ–ª—É
    
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs(v, u);
        
        int curr = maxDown[v] + 1;
        if (curr > max1) {
            max2 = max1;
            max1 = curr;
        } else if (curr > max2) {
            max2 = curr;
        }
    }
    
    maxDown[u] = max1;
    maxPath[u] = max1 + max2; // –¥–∏–∞–º–µ—Ç—ä—Ä—ä—Ç –º–∏–Ω–∞–≤–∞—â –ø—Ä–µ–∑ u
}
```

### 1.3. Rerooting Technique (–î–ü —Å –≤—Å–∏—á–∫–∏ –∫–æ—Ä–µ–Ω–∏)
–ê–∫–æ —Ç—Ä—è–±–≤–∞ –¥–∞ –Ω–∞–º–µ—Ä–∏–º –æ—Ç–≥–æ–≤–æ—Ä–∞ –∑–∞ *–≤—Å–µ–∫–∏* –≤—Ä—ä—Ö, –∞–∫–æ —Ç–æ–π –±–µ—à–µ –∫–æ—Ä–µ–Ω.

–ü–æ–¥—Ö–æ–¥ (–¥–≤–∞ DFS-–∞):
1. **Bottom-up DFS:** –ü—Ä–µ—Å–º—è—Ç–∞–º–µ DP –∑–∞ –ø—Ä–æ–∏–∑–≤–æ–ª–µ–Ω –∫–æ—Ä–µ–Ω (–Ω–∞–ø—Ä. 1), –æ–±—Ä–∞–±–æ—Ç–≤–∞–π–∫–∏ –ø–æ–¥–¥—ä—Ä–≤–µ—Ç–∞—Ç–∞.
2. **Top-down DFS:** –ü—Ä–µ—Ö–≤—ä—Ä–ª—è–º–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –æ—Ç —Ä–æ–¥–∏—Ç–µ–ª—è –∫—ä–º –¥–µ—Ç–µ—Ç–æ, "–ø—Ä–µ–º–µ—Å—Ç–≤–∞–π–∫–∏" –∫–æ—Ä–µ–Ω–∞.

–ü—Ä–∏–º–µ—Ä: –ó–∞ –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö –Ω–∞–º–µ—Ä–∏ —Å—É–º–∞—Ç–∞ –æ—Ç —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è—Ç–∞ –¥–æ –≤—Å–∏—á–∫–∏ –¥—Ä—É–≥–∏ –≤—ä—Ä—Ö–æ–≤–µ.

```cpp
const int MAXN = 200005;
vector<int> adj[MAXN];
long long subtree[MAXN]; // –±—Ä–æ–π –≤—ä—Ä—Ö–æ–≤–µ –≤ –ø–æ–¥–¥—ä—Ä–≤–æ—Ç–æ
long long down[MAXN];    // —Å—É–º–∞ –Ω–∞ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è—Ç–∞ –Ω–∞–¥–æ–ª—É
long long ans[MAXN];     // –æ—Ç–≥–æ–≤–æ—Ä –∑–∞ –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö
int n;

// Bottom-up: –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ –∑–∞ –∫–æ—Ä–µ–Ω 1
void dfs1(int u, int p) {
    subtree[u] = 1;
    down[u] = 0;
    
    for (int v : adj[u]) {
        if (v == p) continue;
        dfs1(v, u);
        
        subtree[u] += subtree[v];
        down[u] += down[v] + subtree[v];
    }
}

// Top-down: –ø—Ä–µ–Ω–∞—Å—è–º–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –∫—ä–º –≤—Å–∏—á–∫–∏ –≤—ä–∑–º–æ–∂–Ω–∏ –∫–æ—Ä–µ–Ω–∏
void dfs2(int u, int p) {
    for (int v : adj[u]) {
        if (v == p) continue;
        
        // –ü—Ä–µ–º–µ—Å—Ç–≤–∞–º–µ –∫–æ—Ä–µ–Ω–∞ –æ—Ç u –∫—ä–º v
        // –ü—Ä–µ–º–∞—Ö–≤–∞–º–µ –ø—Ä–∏–Ω–æ—Å –æ—Ç –ø–æ–¥–¥—ä—Ä–≤–æ—Ç–æ –Ω–∞ v
        // –î–æ–±–∞–≤—è–º–µ –ø—Ä–∏–Ω–æ—Å –æ—Ç –æ—Å—Ç–∞–Ω–∞–ª–æ—Ç–æ –¥—ä—Ä–≤–æ
        ans[v] = ans[u] - subtree[v] + (n - subtree[v]);
        
        dfs2(v, u);
    }
}
```

## 2. –î–ü –≤—ä—Ä—Ö—É –ü—Ä–æ—Ñ–∏–ª (Broken Profile DP)

–ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∑–∞ –ø–æ–∫—Ä–∏–≤–∞–Ω–µ –Ω–∞ –º—Ä–µ–∂–∏ $N \times M$ —Å —Ñ–∏–≥—É—Ä–∏ (–¥–æ–º–∏–Ω–æ, –ø–ª–æ—á–∫–∏), –∫—ä–¥–µ—Ç–æ $N$ –µ –º–∞–ª–∫–æ (–æ–±–∏–∫–Ω–æ–≤–µ–Ω–æ $N \le 13$).

–°—ä—Å—Ç–æ—è–Ω–∏–µ—Ç–æ –µ –±–∏—Ç–æ–≤–∞ –º–∞—Å–∫–∞, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–≤–∞—â–∞ –≥—Ä–∞–Ω–∏—Ü–∞—Ç–∞ ("–ø—Ä–æ—Ñ–∏–ª–∞") –º–µ–∂–¥—É –æ–±—Ä–∞–±–æ—Ç–µ–Ω–∞—Ç–∞ –∏ –Ω–µ–æ–±—Ä–∞–±–æ—Ç–µ–Ω–∞—Ç–∞ —á–∞—Å—Ç –Ω–∞ –º—Ä–µ–∂–∞—Ç–∞. –û–±—Ä–∞–±–æ—Ç–≤–∞–º–µ –º—Ä–µ–∂–∞—Ç–∞ –∫–æ–ª–æ–Ω–∞ –ø–æ –∫–æ–ª–æ–Ω–∞ (–∏–ª–∏ —Ä–µ–¥ –ø–æ —Ä–µ–¥).

**–ü—Ä–∏–º–µ—Ä:** –ü–æ–∫—Ä–∏–≤–∞–Ω–µ –Ω–∞ $N \times M$ —à–∞—Ö–º–∞—Ç–Ω–∞ –¥—ä—Å–∫–∞ —Å $1 \times 2$ –¥–æ–º–∏–Ω–∞.

–ë–∏—Ç–æ–≤–∞—Ç–∞ –º–∞—Å–∫–∞ –ø–æ–∫–∞–∑–≤–∞ –∫–æ–∏ –∫–ª–µ—Ç–∫–∏ –æ—Ç —Ç–µ–∫—É—â–∞—Ç–∞ –∫–æ–ª–æ–Ω–∞ "–∏–∑–ª–∏–∑–∞—Ç" –≤ —Å–ª–µ–¥–≤–∞—â–∞—Ç–∞ (–≤–µ—Ä—Ç–∏–∫–∞–ª–Ω–∏ –¥–æ–º–∏–Ω–∞).

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m;
long long dp[1005][1 << 13]; // dp[–∫–æ–ª–æ–Ω–∞][–º–∞—Å–∫–∞]
bool valid[1 << 13][1 << 13]; // –≤–∞–ª–∏–¥–Ω–∏ –ø—Ä–µ—Ö–æ–¥–∏

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ –º–æ–∂–µ–º –¥–∞ –ø—Ä–µ–º–∏–Ω–µ–º –æ—Ç –º–∞—Å–∫–∞ cur –∫—ä–º next
void precompute(int pos, int cur, int next, int curMask, int nextMask) {
    if (pos == n) {
        valid[curMask][nextMask] = true;
        return;
    }
    
    if (cur & (1 << pos)) {
        // –¢–∞–∑–∏ –∫–ª–µ—Ç–∫–∞ –µ –∑–∞–µ—Ç–∞ –æ—Ç –ø—Ä–µ–¥–∏—à–Ω–∞ –∫–æ–ª–æ–Ω–∞
        precompute(pos + 1, cur, next, curMask, nextMask);
    } else {
        // –ü–æ—Å—Ç–∞–≤—è–º–µ –≤–µ—Ä—Ç–∏–∫–∞–ª–Ω–æ –¥–æ–º–∏–Ω–æ
        precompute(pos + 1, cur | (1 << pos), next | (1 << pos), 
                   curMask, nextMask | (1 << pos));
        
        // –ü–æ—Å—Ç–∞–≤—è–º–µ —Ö–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–Ω–æ –¥–æ–º–∏–Ω–æ (–∞–∫–æ –∏–º–∞ –º—è—Å—Ç–æ)
        if (pos + 1 < n && !(cur & (1 << (pos + 1)))) {
            precompute(pos + 2, cur | (1 << pos) | (1 << (pos + 1)), 
                       next, curMask, nextMask);
        }
    }
}

int main() {
    cin >> n >> m;
    
    // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–æ –∏–∑—á–∏—Å–ª—è–≤–∞–º–µ –≤–∞–ª–∏–¥–Ω–∏—Ç–µ –ø—Ä–µ—Ö–æ–¥–∏
    for (int mask = 0; mask < (1 << n); mask++) {
        precompute(0, mask, 0, mask, 0);
    }
    
    dp[0][0] = 1; // –ù–∞—á–∞–ª–Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
    
    for (int col = 0; col < m; col++) {
        for (int mask = 0; mask < (1 << n); mask++) {
            if (dp[col][mask] == 0) continue;
            
            for (int nextMask = 0; nextMask < (1 << n); nextMask++) {
                if (valid[mask][nextMask]) {
                    dp[col + 1][nextMask] += dp[col][mask];
                }
            }
        }
    }
    
    cout << dp[m][0] << endl; // –í—Å–∏—á–∫–∏ –∫–ª–µ—Ç–∫–∏ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–∞ –ø–æ–∫—Ä–∏—Ç–∏
    
    return 0;
}
```

–°–ª–æ–∂–Ω–æ—Å—Ç: $O(N \cdot M \cdot 2^N \cdot 2^N)$ –∑–∞ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–æ—Ç–æ –∏–∑—á–∏—Å–ª–µ–Ω–∏–µ, $O(M \cdot 2^{2N})$ –∑–∞ DP.

## 3. –î–ü —Å –ë–∏—Ç–æ–≤–∏ –ú–∞—Å–∫–∏ (Bitmask DP)

–ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∫–æ–≥–∞—Ç–æ –∏–º–∞–º–µ –º–∞–ª–∫–æ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –æ—Ç –µ–ª–µ–º–µ–Ω—Ç–∏ ($N \le 20$) –∏ —Ç—Ä—è–±–≤–∞ –¥–∞ –ø–∞–∑–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞ –ø–æ–¥–Ω–µ–∂–¥–µ—Å—Ç–≤–∞—Ç–∞.

**–ü—Ä–∏–º–µ—Ä: Travelling Salesman Problem (TSP)**

–°—ä—Å—Ç–æ—è–Ω–∏–µ: $dp[mask][i]$ = –º–∏–Ω–∏–º–∞–ª–Ω–∞ —Ü–µ–Ω–∞ –¥–∞ –ø–æ—Å–µ—Ç–∏–º –≤—ä—Ä—Ö–æ–≤–µ—Ç–µ –≤ $mask$ –∏ –¥–∞ –∑–∞–≤—ä—Ä—à–∏–º –Ω–∞ –≤—Ä—ä—Ö $i$.

```cpp
const int MAXN = 20;
const int INF = 1e9;
int dist[MAXN][MAXN];
int dp[1 << MAXN][MAXN];
int n;

int tsp() {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    for (int mask = 0; mask < (1 << n); mask++) {
        for (int i = 0; i < n; i++) {
            dp[mask][i] = INF;
        }
    }
    
    // –ó–∞–ø–æ—á–≤–∞–º–µ –æ—Ç –≤—Ä—ä—Ö 0
    dp[1][0] = 0;
    
    // –ó–∞ –≤—Å—è–∫–∞ –º–∞—Å–∫–∞ (–º–Ω–æ–∂–µ—Å—Ç–≤–æ –æ—Ç –ø–æ—Å–µ—Ç–µ–Ω–∏ –≤—ä—Ä—Ö–æ–≤–µ)
    for (int mask = 1; mask < (1 << n); mask++) {
        for (int i = 0; i < n; i++) {
            if (!(mask & (1 << i))) continue; // i —Ç—Ä—è–±–≤–∞ –¥–∞ –µ –≤ –º–∞—Å–∫–∞—Ç–∞
            if (dp[mask][i] == INF) continue;
            
            // –û–ø–∏—Ç–≤–∞–º–µ –¥–∞ –¥–æ–±–∞–≤–∏–º –≤—Ä—ä—Ö j
            for (int j = 0; j < n; j++) {
                if (mask & (1 << j)) continue; // j –≤–µ—á–µ –µ –ø–æ—Å–µ—Ç–µ–Ω
                
                int newMask = mask | (1 << j);
                dp[newMask][j] = min(dp[newMask][j], 
                                     dp[mask][i] + dist[i][j]);
            }
        }
    }
    
    // –ù–∞–º–∏—Ä–∞–º–µ –º–∏–Ω–∏–º–∞–ª–Ω–∞—Ç–∞ —Ü–µ–Ω–∞ –∑–∞ –ø–æ—Å–µ—â–µ–Ω–∏–µ –Ω–∞ –≤—Å–∏—á–∫–∏ –≤—ä—Ä—Ö–æ–≤–µ
    int fullMask = (1 << n) - 1;
    int result = INF;
    for (int i = 0; i < n; i++) {
        result = min(result, dp[fullMask][i] + dist[i][0]); // –≤—Ä—ä—â–∞–º–µ —Å–µ –≤ –Ω–∞—á–∞–ª–æ—Ç–æ
    }
    
    return result;
}
```

**–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: Subset Sum —Å –±–∏—Ç–æ–≤–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏**

–ê–∫–æ –∏–º–∞–º–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —á–∏—Å–ª–∞ –∏ –∏—Å–∫–∞–º–µ –¥–∞ –Ω–∞–º–µ—Ä–∏–º –≤—Å–∏—á–∫–∏ –≤—ä–∑–º–æ–∂–Ω–∏ —Å—É–º–∏, –º–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ `bitset`:

```cpp
#include <bitset>

bitset<100005> dp;

void subsetSum(vector<int>& nums) {
    dp[0] = 1; // —Å—É–º–∞—Ç–∞ 0 –µ –≤—ä–∑–º–æ–∂–Ω–∞
    
    for (int x : nums) {
        dp |= (dp << x); // –¥–æ–±–∞–≤—è–º–µ x –∫—ä–º –≤—Å–∏—á–∫–∏ –≤—ä–∑–º–æ–∂–Ω–∏ —Å—É–º–∏
    }
}
```

## 4. Digit DP (–î–ü —Å –¶–∏—Ñ—Ä–∏)

–ò–∑–ø–æ–ª–∑–≤–∞ —Å–µ –∑–∞ –±—Ä–æ–µ–Ω–µ –Ω–∞ —á–∏—Å–ª–∞ –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª $[L, R]$, –∫–æ–∏—Ç–æ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–≤–∞—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ —Å–≤–æ–π—Å—Ç–≤–æ.

**–ü–æ–¥—Ö–æ–¥:** –ë—Ä–æ–∏–º —á–∏—Å–ª–∞ –æ—Ç $[0, R]$ –º–∏–Ω—É—Å —á–∏—Å–ª–∞ –æ—Ç $[0, L-1]$.

–°—ä—Å—Ç–æ—è–Ω–∏–µ: $dp[pos][tight][started][...]$ –∫—ä–¥–µ—Ç–æ:
- $pos$ = —Ç–µ–∫—É—â–∞ –ø–æ–∑–∏—Ü–∏—è –≤ —á–∏—Å–ª–æ—Ç–æ
- $tight$ = –¥–∞–ª–∏ —Å–º–µ –æ—â–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏ –æ—Ç –≥–æ—Ä–Ω–∞—Ç–∞ –≥—Ä–∞–Ω–∏—Ü–∞
- $started$ = –¥–∞–ª–∏ —Å–º–µ –∑–∞–ø–æ—á–Ω–∞–ª–∏ –¥–∞ –ø–æ—Å—Ç–∞–≤—è–º–µ –Ω–µ–Ω—É–ª–µ–≤–∏ —Ü–∏—Ñ—Ä–∏
- –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —Å–ø–æ—Ä–µ–¥ –∑–∞–¥–∞—á–∞—Ç–∞

**–ü—Ä–∏–º–µ—Ä:** –ë—Ä–æ–µ–Ω–µ –Ω–∞ —á–∏—Å–ª–∞ –≤ $[L, R]$ —Å—ä—Å —Å—É–º–∞ –Ω–∞ —Ü–∏—Ñ—Ä–∏—Ç–µ, –¥–µ–ª–∏–º–∞ –Ω–∞ $K$.

```cpp
#include <bits/stdc++.h>
using namespace std;

string num;
int K;
int dp[20][2][2][200]; // [pos][tight][started][sum % K]

// –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞ digit DP
int solve(int pos, int tight, int started, int sum) {
    // –ë–∞–∑–æ–≤ —Å–ª—É—á–∞–π: –æ–±—Ä–∞–±–æ—Ç–µ–Ω–∏ –≤—Å–∏—á–∫–∏ —Ü–∏—Ñ—Ä–∏
    if (pos == num.size()) {
        return started && (sum % K == 0);
    }
    
    // –ú–µ–º–æ–∏–∑–∞—Ü–∏—è
    if (dp[pos][tight][started][sum] != -1) {
        return dp[pos][tight][started][sum];
    }
    
    int limit = tight ? (num[pos] - '0') : 9;
    int result = 0;
    
    for (int digit = 0; digit <= limit; digit++) {
        int newTight = tight && (digit == limit);
        int newStarted = started || (digit > 0);
        int newSum = sum + digit;
        
        result += solve(pos + 1, newTight, newStarted, newSum);
    }
    
    return dp[pos][tight][started][sum] = result;
}

int countNumbers(long long x) {
    if (x < 0) return 0;
    num = to_string(x);
    memset(dp, -1, sizeof(dp));
    return solve(0, 1, 0, 0);
}

int main() {
    long long L, R;
    cin >> L >> R >> K;
    
    int answer = countNumbers(R) - countNumbers(L - 1);
    cout << answer << endl;
    
    return 0;
}
```

**–î—Ä—É–≥–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–∞ Digit DP:**
- –ß–∏—Å–ª–∞ –±–µ–∑ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–∏ –µ–¥–Ω–∞–∫–≤–∏ —Ü–∏—Ñ—Ä–∏
- –ß–∏—Å–ª–∞ —Å —Ç–æ—á–Ω–æ K —Ä–∞–∑–ª–∏—á–Ω–∏ —Ü–∏—Ñ—Ä–∏
- –ß–∏—Å–ª–∞, —á–∏–∏—Ç–æ —Ü–∏—Ñ—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–∞—Ç —Ä–∞—Å—Ç—è—â–∞/–Ω–∞–º–∞–ª—è–≤–∞—â–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–Ω–æ—Å—Ç
- –ß–∏—Å–ª–∞, –¥–µ–ª–∏–º–∏ –Ω–∞ —Å—É–º–∞—Ç–∞ –Ω–∞ —Ü–∏—Ñ—Ä–∏—Ç–µ —Å–∏

## 5. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –Ω–∞ –ø—Ä–µ—Ö–æ–¥–∏—Ç–µ

–ú–Ω–æ–≥–æ DP –∑–∞–¥–∞—á–∏ –∏–º–∞—Ç —Ñ–æ—Ä–º—É–ª–∞ –æ—Ç –≤–∏–¥–∞:
$dp[i] = \min_{j < i} \{ dp[j] + cost(j, i) \}$

–î–∏—Ä–µ–∫—Ç–Ω–æ—Ç–æ –ø—Ä–µ—Å–º—è—Ç–∞–Ω–µ –µ $O(N^2)$. –¶–µ–ª—Ç–∞ –µ –¥–∞ –≥–æ —Å–≤–µ–¥–µ–º –¥–æ $O(N \log N)$ –∏–ª–∏ $O(N)$.

### 5.1. Convex Hull Trick (CHT)

–ü—Ä–∏–ª–æ–∂–∏–º–æ –∫–æ–≥–∞—Ç–æ $cost(j, i)$ –º–æ–∂–µ –¥–∞ —Å–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏ –∫–∞—Ç–æ –ª–∏–Ω–µ–π–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è: $cost(j, i) = b_j \cdot a_i + c_j$

–¢–æ–≥–∞–≤–∞: $dp[i] = \min_{j < i} \{ dp[j] + b_j \cdot a_i + c_j \} = \min_{j < i} \{ (dp[j] + c_j) + b_j \cdot a_i \}$

–í—Å—è–∫–æ $j$ –¥–µ—Ñ–∏–Ω–∏—Ä–∞ –ø—Ä–∞–≤–∞ —Å –Ω–∞–∫–ª–æ–Ω $m_j = b_j$ –∏ —Å–≤–æ–±–æ–¥–µ–Ω —á–ª–µ–Ω $c_j = dp[j] + c_j$.

**–ò–¥–µ—è:** –ü–æ–¥–¥—ä—Ä–∂–∞–º–µ –¥–æ–ª–Ω–∞—Ç–∞ –∏–∑–ø—ä–∫–Ω–∞–ª–∞ –æ–±–≤–∏–≤–∫–∞ –Ω–∞ –ø—Ä–∞–≤–∏—Ç–µ. –ó–∞ –≤—Å—è–∫–æ $a_i$ –Ω–∞–º–∏—Ä–∞–º–µ –ø—Ä–∞–≤–∞—Ç–∞ —Å –º–∏–Ω–∏–º–∞–ª–Ω–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç.

**–ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è —Å Deque (–∫–æ–≥–∞—Ç–æ –Ω–∞–∫–ª–æ–Ω–∏—Ç–µ —Å–∞ –º–æ–Ω–æ—Ç–æ–Ω–Ω–∏):**

```cpp
struct Line {
    long long m, c; // y = m*x + c
    long long eval(long long x) { return m * x + c; }
};

deque<Line> hull;

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª–∏ —Å—Ä–µ–¥–Ω–∞—Ç–∞ –ø—Ä–∞–≤–∞ –µ –∏–∑–ª–∏—à–Ω–∞
bool bad(Line l1, Line l2, Line l3) {
    // l2 –µ –ª–æ—à–∞ –∞–∫–æ l1 –∏ l3 —Å–µ –ø—Ä–µ—Å–∏—á–∞—Ç –ø—Ä–µ–¥–∏ l1 –∏ l2
    return (__int128)(l3.c - l1.c) * (l1.m - l2.m) <= 
           (__int128)(l2.c - l1.c) * (l1.m - l3.m);
}

void addLine(Line newLine) {
    // –ü—Ä–µ–º–∞—Ö–≤–∞–º–µ –ª–æ—à–∏ –ø—Ä–∞–≤–∏ –æ—Ç –∫—Ä–∞—è
    while (hull.size() >= 2 && 
           bad(hull[hull.size()-2], hull[hull.size()-1], newLine)) {
        hull.pop_back();
    }
    hull.push_back(newLine);
}

long long query(long long x) {
    // –ê–∫–æ x-–æ–≤–µ—Ç–µ —Å–∞ –º–æ–Ω–æ—Ç–æ–Ω–Ω–∏, –º–æ–∂–µ–º –¥–∞ –ø—Ä–µ–º–∞—Ö–≤–∞–º–µ –æ—Ç –Ω–∞—á–∞–ª–æ—Ç–æ
    while (hull.size() >= 2 && hull[0].eval(x) >= hull[1].eval(x)) {
        hull.pop_front();
    }
    return hull[0].eval(x);
}
```

**–ü—Ä–∏–º–µ—Ä –∑–∞–¥–∞—á–∞:** –ò–º–∞–º–µ –º–∞—Å–∏–≤–∏ $a[]$ –∏ $b[]$. –¢—Ä—è–±–≤–∞ –¥–∞ –∏–∑—á–∏—Å–ª–∏–º:
$dp[i] = \min_{j < i} \{ dp[j] + b[j] \cdot a[i] \}$

```cpp
const int MAXN = 100005;
long long a[MAXN], b[MAXN], dp[MAXN];
int n;

void solve() {
    dp[0] = 0;
    addLine({b[0], dp[0]});
    
    for (int i = 1; i < n; i++) {
        dp[i] = query(a[i]);
        addLine({b[i], dp[i]});
    }
}
```

–°–ª–æ–∂–Ω–æ—Å—Ç: $O(N)$ –∞–∫–æ –Ω–∞–∫–ª–æ–Ω–∏—Ç–µ –∏ $x$-–æ–≤–µ—Ç–µ —Å–∞ –º–æ–Ω–æ—Ç–æ–Ω–Ω–∏.

### 5.2. Divide and Conquer Optimization

–ü—Ä–∏–ª–æ–∂–∏–º–æ –∫–æ–≥–∞—Ç–æ –æ–ø—Ç–∏–º–∞–ª–Ω–∞—Ç–∞ —Ç–æ—á–∫–∞ –Ω–∞ –ø—Ä–µ—Ö–æ–¥–∞ –µ –º–æ–Ω–æ—Ç–æ–Ω–Ω–∞: $opt[i] \le opt[i+1]$.

–£—Å–ª–æ–≤–∏–µ (Quadrangle Inequality): $cost(a, c) + cost(b, d) \le cost(a, d) + cost(b, c)$ –∑–∞ $a \le b \le c \le d$.

**–ü—Ä–∏–º–µ—Ä:** $dp[i][k]$ = –º–∏–Ω–∏–º–∞–ª–Ω–∞ —Ü–µ–Ω–∞ –¥–∞ —Ä–∞–∑–¥–µ–ª–∏–º –ø—ä—Ä–≤–∏—Ç–µ $i$ –µ–ª–µ–º–µ–Ω—Ç–∞ –Ω–∞ $k$ –≥—Ä—É–ø–∏.

```cpp
const int MAXN = 5005;
const long long INF = 1e18;
long long dp[MAXN][MAXN];
long long cost[MAXN][MAXN]; // –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–æ –∏–∑—á–∏—Å–ª–µ–Ω–∞ —Ü–µ–Ω–∞

void compute(int k, int l, int r, int optL, int optR) {
    if (l > r) return;
    
    int mid = (l + r) / 2;
    long long best = INF;
    int bestPos = -1;
    
    // –¢—ä—Ä—Å–∏–º –æ–ø—Ç–∏–º–∞–ª–Ω–∞—Ç–∞ –ø–æ–∑–∏—Ü–∏—è –≤ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω –∏–Ω—Ç–µ—Ä–≤–∞–ª
    for (int j = optL; j <= min(mid, optR); j++) {
        long long curr = dp[j][k-1] + cost[j+1][mid];
        if (curr < best) {
            best = curr;
            bestPos = j;
        }
    }
    
    dp[mid][k] = best;
    
    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –∑–∞ –ª—è–≤–∞—Ç–∞ –∏ –¥—è—Å–Ω–∞—Ç–∞ –ø–æ–ª–æ–≤–∏–Ω–∞
    compute(k, l, mid - 1, optL, bestPos);
    compute(k, mid + 1, r, bestPos, optR);
}

void solve() {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    for (int i = 0; i < n; i++) {
        dp[i][0] = INF;
        dp[i][1] = cost[0][i];
    }
    
    // –ó–∞ –≤—Å—è–∫–æ k
    for (int k = 2; k <= maxK; k++) {
        compute(k, 0, n - 1, 0, n - 1);
    }
}
```

–°–ª–æ–∂–Ω–æ—Å—Ç: $O(K \cdot N \log N)$ –≤–º–µ—Å—Ç–æ $O(K \cdot N^2)$.

### 5.3. Knuth Optimization

–ü—Ä–∏–ª–æ–∂–∏–º–æ –∑–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–Ω–∏ DP –∑–∞–¥–∞—á–∏ —Å –∫–≤–∞–¥—Ä–∞—Ç–Ω–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ.

–£—Å–ª–æ–≤–∏—è:
1. $opt[i][j-1] \le opt[i][j] \le opt[i+1][j]$ (–º–æ–Ω–æ—Ç–æ–Ω–Ω–æ—Å—Ç –Ω–∞ –æ–ø—Ç–∏–º—É–º–∞)
2. $cost(i, j)$ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–≤–∞ –∫–≤–∞–¥—Ä–∞—Ç–Ω–æ—Ç–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ

**–ü—Ä–∏–º–µ—Ä:** –û–ø—Ç–∏–º–∞–ª–Ω–æ –¥–≤–æ–∏—á–Ω–æ –¥—ä—Ä–≤–æ –∑–∞ —Ç—ä—Ä—Å–µ–Ω–µ (Optimal BST).

```cpp
const int MAXN = 1005;
long long dp[MAXN][MAXN];  // dp[i][j] = –º–∏–Ω–∏–º–∞–ª–Ω–∞ —Ü–µ–Ω–∞ –∑–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª [i, j]
int opt[MAXN][MAXN];        // opt[i][j] = –æ–ø—Ç–∏–º–∞–ª–Ω–∞ –ø–æ–∑–∏—Ü–∏—è –Ω–∞ –∫–æ—Ä–µ–Ω–∞
long long cost[MAXN][MAXN]; // —Ü–µ–Ω–∞ –∑–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª

void solve() {
    // –ë–∞–∑–æ–≤ —Å–ª—É—á–∞–π
    for (int i = 0; i < n; i++) {
        dp[i][i] = cost[i][i];
        opt[i][i] = i;
    }
    
    // –ü–æ –¥—ä–ª–∂–∏–Ω–∞ –Ω–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i + len - 1 < n; i++) {
            int j = i + len - 1;
            dp[i][j] = INF;
            
            // –û–≥—Ä–∞–Ω–∏—á–∞–≤–∞–º–µ —Ç—ä—Ä—Å–µ–Ω–µ—Ç–æ —Å Knuth Optimization
            for (int k = opt[i][j-1]; k <= opt[i+1][j]; k++) {
                long long curr = dp[i][k-1] + dp[k+1][j] + cost[i][j];
                if (curr < dp[i][j]) {
                    dp[i][j] = curr;
                    opt[i][j] = k;
                }
            }
        }
    }
}
```

–°–ª–æ–∂–Ω–æ—Å—Ç: $O(N^2)$ –≤–º–µ—Å—Ç–æ $O(N^3)$.

## 6. SOS DP (Sum Over Subsets)

–ó–∞ –ø—Ä–µ—Å–º—è—Ç–∞–Ω–µ –Ω–∞ $F[mask] = \sum_{sub \subseteq mask} A[sub]$ –∑–∞ –≤—Å–∏—á–∫–∏ –º–∞—Å–∫–∏.

**–ù–∞–∏–≤–µ–Ω –ø–æ–¥—Ö–æ–¥:** –ó–∞ –≤—Å—è–∫–∞ –º–∞—Å–∫–∞ –∏—Ç–µ—Ä–∏—Ä–∞–º–µ –ø—Ä–µ–∑ –≤—Å–∏—á–∫–∏ –Ω–µ–π–Ω–∏ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞.
```cpp
for (int mask = 0; mask < (1 << n); mask++) {
    for (int sub = mask; ; sub = (sub - 1) & mask) {
        F[mask] += A[sub];
        if (sub == 0) break;
    }
}
```
–°–ª–æ–∂–Ω–æ—Å—Ç: $O(3^N)$ - –∑–∞—â–æ—Ç–æ –∏–º–∞ $\binom{N}{k}$ –º–∞—Å–∫–∏ —Å $k$ –µ–¥–∏–Ω–∏—Ü–∏, –≤—Å—è–∫–∞ –æ—Ç –∫–æ–∏—Ç–æ –∏–º–∞ $2^k$ –ø–æ–¥–º–∞—Å–∫–∏.

**SOS DP –ø–æ–¥—Ö–æ–¥:** –û–±—Ä–∞–±–æ—Ç–≤–∞–º–µ –±–∏—Ç–æ–≤–µ—Ç–µ –µ–¥–∏–Ω –ø–æ –µ–¥–∏–Ω.

–ò–¥–µ—è: $dp[mask][i]$ = —Å—É–º–∞ –Ω–∞ –≤—Å–∏—á–∫–∏ –ø–æ–¥–º–∞—Å–∫–∏ –Ω–∞ $mask$, –∫–æ–∏—Ç–æ —Å–µ —Ä–∞–∑–ª–∏—á–∞–≤–∞—Ç —Å–∞–º–æ –≤ –ø—ä—Ä–≤–∏—Ç–µ $i$ –±–∏—Ç–∞.

```cpp
// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
for (int mask = 0; mask < (1 << n); mask++) {
    dp[mask][0] = A[mask];
}

// –ò—Ç–µ—Ä–∏—Ä–∞–Ω–µ –ø–æ –±–∏—Ç–æ–≤–µ
for (int i = 0; i < n; i++) {
    for (int mask = 0; mask < (1 << n); mask++) {
        if (mask & (1 << i)) {
            // –ê–∫–æ i-—Ç–∏—è—Ç –±–∏—Ç –µ 1, –¥–æ–±–∞–≤—è–º–µ –ø–æ–¥–º–∞—Å–∫–∏—Ç–µ —Å 0 –Ω–∞ —Ç–∞–∑–∏ –ø–æ–∑–∏—Ü–∏—è
            dp[mask][i+1] = dp[mask][i] + dp[mask ^ (1 << i)][i];
        } else {
            // –ê–∫–æ i-—Ç–∏—è—Ç –±–∏—Ç –µ 0, –Ω–µ –¥–æ–±–∞–≤—è–º–µ –Ω–∏—â–æ –Ω–æ–≤–æ
            dp[mask][i+1] = dp[mask][i];
        }
    }
}

// –û–ø—Ç–∏–º–∏–∑–∏—Ä–∞–Ω–∞ –≤–µ—Ä—Å–∏—è –±–µ–∑ –≤—Ç–æ—Ä–æ –∏–∑–º–µ—Ä–µ–Ω–∏–µ
for (int i = 0; i < n; i++) {
    for (int mask = 0; mask < (1 << n); mask++) {
        if (mask & (1 << i)) {
            dp[mask] += dp[mask ^ (1 << i)];
        }
    }
}
```

–°–ª–æ–∂–Ω–æ—Å—Ç: $O(N \cdot 2^N)$.

**–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è:**
- –ë—Ä–æ–µ–Ω–µ –Ω–∞ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏ —Å–≤–æ–π—Å—Ç–≤–∞
- Convolution –Ω–∞ –¥–≤–∞ –º–∞—Å–∏–≤–∞ –≤—ä—Ä—Ö—É –±–∏—Ç–æ–≤–∏ –º–∞—Å–∫–∏
- –ó–∞–¥–∞—á–∏ —Å –æ–±–µ–¥–∏–Ω–µ–Ω–∏—è –∏ –ø—Ä–µ—Å–∏—á–∞–Ω–∏—è –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞

**–ü—Ä–∏–º–µ—Ä –∑–∞–¥–∞—á–∞:** –ò–º–∞–º–µ $N$ —Ü–µ–ª–∏ —á–∏—Å–ª–∞. –ó–∞ –≤—Å—è–∫–æ —á–∏—Å–ª–æ –∏—Å–∫–∞–º–µ –¥–∞ –∑–Ω–∞–µ–º –∫–æ–ª–∫–æ —á–∏—Å–ª–∞ –æ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ—Ç–æ —Å–∞ –Ω–µ–≥–æ–≤–∏ –ø–æ–¥–º–∞—Å–∫–∏ (–∏–º–∞—Ç —Å–∞–º–æ –±–∏—Ç–æ–≤–µ, –∫–æ–∏—Ç–æ —Å–∞ –≤–∫–ª—é—á–µ–Ω–∏ –≤ —Ç–µ–∫—É—â–æ—Ç–æ —á–∏—Å–ª–æ).

```cpp
int count[1 << 20];
int freq[1 << 20];

void countSubsets(vector<int>& nums) {
    // freq[mask] = –∫–æ–ª–∫–æ –ø—ä—Ç–∏ —Å–µ —Å—Ä–µ—â–∞ –º–∞—Å–∫–∞—Ç–∞
    for (int x : nums) {
        freq[x]++;
    }
    
    // SOS DP
    for (int i = 0; i < 20; i++) {
        for (int mask = 0; mask < (1 << 20); mask++) {
            if (mask & (1 << i)) {
                freq[mask] += freq[mask ^ (1 << i)];
            }
        }
    }
    
    // freq[mask] —Å–µ–≥–∞ —Å—ä–¥—ä—Ä–∂–∞ –±—Ä–æ—è –Ω–∞ –ø–æ–¥–º–∞—Å–∫–∏—Ç–µ
}
```

## 7. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ —Å—ä–≤–µ—Ç–∏ –∏ —á–µ—Å—Ç–æ —Å—Ä–µ—â–∞–Ω–∏ –≥—Ä–µ—à–∫–∏

### 7.1. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ –ø–∞–º–µ—Ç—Ç–∞

–ö–æ–≥–∞—Ç–æ DP –º–∞—Å–∏–≤—ä—Ç –µ –º–Ω–æ–≥–æ–º–µ—Ä–µ–Ω, —á–µ—Å—Ç–æ –º–æ–∂–µ–º –¥–∞ –Ω–∞–º–∞–ª–∏–º —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—Ç–∞:
- –ê–∫–æ $dp[i]$ –∑–∞–≤–∏—Å–∏ —Å–∞–º–æ –æ—Ç $dp[i-1]$, –∏–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ –¥–≤–∞ –º–∞—Å–∏–≤–∞ –∏–ª–∏ rolling array
- –ó–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–Ω–æ DP, –æ–±—Ä–∞–±–æ—Ç–≤–∞–π—Ç–µ –ø–æ –¥—ä–ª–∂–∏–Ω–∞ –Ω–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞

```cpp
// –í–º–µ—Å—Ç–æ dp[n][k], –∏–∑–ø–æ–ª–∑–≤–∞–º–µ —Å–∞–º–æ –¥–≤–∞ —Ä–µ–¥–∞
long long curr[MAXK], prev[MAXK];

for (int i = 0; i < n; i++) {
    for (int j = 0; j < k; j++) {
        curr[j] = prev[j] + transition[i][j];
    }
    swap(curr, prev);
}
```

### 7.2. –ò–∑–±–æ—Ä –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –æ—Ç –¥–∞–Ω–Ω–∏

–ó–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ DP –ø—Ä–µ—Ö–æ–¥–∏—Ç–µ:
- **Segment Tree / Fenwick Tree:** –ó–∞ range queries (min, max, sum)
- **Monotonic Deque:** –ó–∞ sliding window –º–∏–Ω–∏–º—É–º/–º–∞–∫—Å–∏–º—É–º
- **Set/Map:** –ó–∞ –¥–∏–Ω–∞–º–∏—á–Ω–æ –ø–æ–¥–¥—ä—Ä–∂–∞–Ω–µ –Ω–∞ –∫–∞–Ω–¥–∏–¥–∞—Ç–∏
- **Li Chao Tree:** –ó–∞ Convex Hull Trick —Å –ø—Ä–æ–∏–∑–≤–æ–ª–Ω–∏ –Ω–∞–∫–ª–æ–Ω–∏

### 7.3. –ß–µ—Å—Ç–æ —Å—Ä–µ—â–∞–Ω–∏ –≥—Ä–µ—à–∫–∏

1. **–ù–µ–ø—Ä–∞–≤–∏–ª–Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è:** –£–≤–µ—Ä–µ—Ç–µ —Å–µ, —á–µ –Ω–∞—á–∞–ª–Ω–∏—Ç–µ —Å—ä—Å—Ç–æ—è–Ω–∏—è —Å–∞ –ø—Ä–∞–≤–∏–ª–Ω–∏
2. **Overflow:** –ò–∑–ø–æ–ª–∑–≤–∞–π—Ç–µ `long long` –∫—ä–¥–µ—Ç–æ –µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
3. **–ù–µ–ø—Ä–∞–≤–∏–ª–µ–Ω —Ä–µ–¥ –Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏—è:** –ü—Ä–∏ –Ω—è–∫–æ–∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Ä–µ–¥—ä—Ç –µ –∫—Ä–∏—Ç–∏—á–µ–Ω
4. **–ó–∞–±—Ä–∞–≤—è–Ω–µ –Ω–∞ edge cases:** –ü—Ä–∞–∑–Ω–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–∞, –µ–¥–∏–Ω–∏—á–Ω–∏ –µ–ª–µ–º–µ–Ω—Ç–∏, etc.

```cpp
// –ü—Ä–∏–º–µ—Ä: –ü—Ä–∞–≤–∏–ª–Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞ –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏—è
const long long INF = 1e18;
for (int i = 0; i < n; i++) {
    dp[i] = INF; // –ù–µ 1e9, –∑–∞—â–æ—Ç–æ –º–æ–∂–µ –¥–∞ –∏–º–∞ overflow!
}
dp[0] = 0; // –ë–∞–∑–æ–≤ —Å–ª—É—á–∞–π
```

## 8. –ó–∞–¥–∞—á–∏ –∑–∞ –ø—Ä–∞–∫—Ç–∏–∫–∞

### 8.1. Tree DP
1. **CSES Tree Matching:** –ú–∞–∫—Å–∏–º–∞–ª–Ω–æ matching –≤ –¥—ä—Ä–≤–æ
2. **CSES Tree Distances I:** –ú–∞–∫—Å–∏–º–∞–ª–Ω–æ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –≤—Å–µ–∫–∏ –≤—Ä—ä—Ö
3. **CSES Tree Distances II:** –°—É–º–∞ –Ω–∞ —Ä–∞–∑—Å—Ç–æ—è–Ω–∏—è—Ç–∞ (Rerooting)
4. **Codeforces 1092F:** Tree with Maximum Cost

### 8.2. Bitmask DP
1. **CSES Hamiltonian Flights:** –ë—Ä–æ–µ–Ω–µ –Ω–∞ Hamiltonian paths
2. **CSES Elevator Rides:** –û–ø—Ç–∏–º–∞–ª–Ω–æ —Ä–∞–∑–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ
3. **Codeforces 453B:** Little Pony and Harmony Chest
4. **AtCoder DP Contest - O:** Matching

### 8.3. Digit DP
1. **SPOJ GONE:** –ß–∏—Å–ª–∞ —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ —Å—É–º–∞ –Ω–∞ —Ü–∏—Ñ—Ä–∏—Ç–µ
2. **Codeforces 628D:** Magic Numbers
3. **LightOJ 1068:** Investigating Palindromes (—Å digit DP)

### 8.4. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
1. **Codeforces 319C:** Kalila and Dimna (Convex Hull Trick)
2. **APIO 2010:** Commando (CHT)
3. **IOI 2014:** Holiday (Divide and Conquer)
4. **CEOI 2004:** Two Sawmills (Knuth Optimization)

### 8.5. SOS DP
1. **Codeforces 165E:** Compatible Numbers
2. **Codeforces 449D:** Jzzhu and Numbers
3. **CSES Sum of Four Values:** (—Å –±–∏—Ç–æ–≤–∏ –º–∞—Å–∫–∏)

## 9. –î–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–∏ —Ç–µ—Ö–Ω–∏–∫–∏

### 9.1. DP —Å Matrix Exponentiation

–ó–∞ DP —Å –ª–∏–Ω–µ–π–Ω–∏ –ø—Ä–µ—Ö–æ–¥–∏, –∫–æ–≥–∞—Ç–æ $N$ –µ –º–Ω–æ–≥–æ –≥–æ–ª—è–º–æ, –º–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –º–∞—Ç—Ä–∏—á–Ω–æ —É–º–Ω–æ–∂–µ–Ω–∏–µ.

**–ü—Ä–∏–º–µ—Ä:** Fibonacci —Å –º–∞—Ç—Ä–∏—Ü–∏ –∑–∞ $O(\log N)$:

```cpp
typedef vector<vector<long long>> Matrix;

Matrix multiply(Matrix& A, Matrix& B) {
    int n = A.size();
    Matrix C(n, vector<long long>(n, 0));
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < n; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    return C;
}

Matrix matPow(Matrix A, long long p) {
    int n = A.size();
    Matrix result(n, vector<long long>(n, 0));
    
    // –ï–¥–∏–Ω–∏—á–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞
    for (int i = 0; i < n; i++) result[i][i] = 1;
    
    while (p > 0) {
        if (p & 1) result = multiply(result, A);
        A = multiply(A, A);
        p >>= 1;
    }
    
    return result;
}
```

### 9.2. Monotone Queue Optimization

–ó–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–∞ DP –æ—Ç –≤–∏–¥–∞ $dp[i] = \min_{i-k \le j < i} dp[j] + cost[j]$.

```cpp
deque<int> dq; // —Å—ä—Ö—Ä–∞–Ω—è–≤–∞ –∏–Ω–¥–µ–∫—Å–∏

for (int i = 0; i < n; i++) {
    // –ü—Ä–µ–º–∞—Ö–≤–∞–º–µ –µ–ª–µ–º–µ–Ω—Ç–∏ –∏–∑–≤—ä–Ω –ø—Ä–æ–∑–æ—Ä–µ—Ü–∞
    while (!dq.empty() && dq.front() < i - k) {
        dq.pop_front();
    }
    
    // –ù–∞–º–∏—Ä–∞–º–µ –º–∏–Ω–∏–º—É–º–∞ –≤ –ø—Ä–æ–∑–æ—Ä–µ—Ü–∞
    if (!dq.empty()) {
        dp[i] = dp[dq.front()] + cost[i];
    }
    
    // –î–æ–±–∞–≤—è–º–µ —Ç–µ–∫—É—â–∏—è –µ–ª–µ–º–µ–Ω—Ç
    while (!dq.empty() && dp[dq.back()] >= dp[i]) {
        dq.pop_back();
    }
    dq.push_back(i);
}
```

## üèÅ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

Advanced DP –µ –∏–∑–∫—É—Å—Ç–≤–æ—Ç–æ –¥–∞ –ø—Ä–µ–≤—ä—Ä–Ω–µ—à "–Ω–µ–≤—ä–∑–º–æ–∂–Ω–æ—Ç–æ" $O(N^2)$ –∏–ª–∏ $O(N^3)$ —Ä–µ—à–µ–Ω–∏–µ –≤ $O(N \log N)$ –∏–ª–∏ $O(N)$ —á—Ä–µ–∑ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞–±–ª—é–¥–µ–Ω–∏—è –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –æ—Ç –¥–∞–Ω–Ω–∏.

**–ö–ª—é—á–æ–≤–∏ —Å—Ç—ä–ø–∫–∏ –ø—Ä–∏ —Ä–µ—à–∞–≤–∞–Ω–µ –Ω–∞ Advanced DP –∑–∞–¥–∞—á–∏:**

1. **–†–∞–∑–ø–æ–∑–Ω–∞–≤–∞–Ω–µ –Ω–∞ —Ç–∏–ø–∞:** Tree DP, Bitmask DP, Digit DP, Profile DP?
2. **–§–æ—Ä–º—É–ª–∏—Ä–∞–Ω–µ –Ω–∞ —Å—ä—Å—Ç–æ—è–Ω–∏—è—Ç–∞:** –ö–∞–∫–≤–æ —Ç—Ä—è–±–≤–∞ –¥–∞ –ø–æ–º–Ω–∏–º –∑–∞ –¥–∞ –∏–∑—á–∏—Å–ª–∏–º –æ—Ç–≥–æ–≤–æ—Ä–∞?
3. **–ù–∞–º–∏—Ä–∞–Ω–µ –Ω–∞ –ø—Ä–µ—Ö–æ–¥–∏—Ç–µ:** –ö–∞–∫ –∫–æ–º–±–∏–Ω–∏—Ä–∞–º–µ –ø–æ-–º–∞–ª–∫–∏—Ç–µ –ø–æ–¥–∑–∞–¥–∞—á–∏?
4. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è:** –ò–º–∞ –ª–∏ –º–æ–Ω–æ—Ç–æ–Ω–Ω–æ—Å—Ç? –ú–æ–∂–µ–º –ª–∏ –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ CHT, D&C, Knuth?
5. **–ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è:** –í–Ω–∏–º–∞–≤–∞–π—Ç–µ –∑–∞ overflow, –ø—Ä–∞–≤–∏–ª–Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è, edge cases

–ü—Ä–∞–∫—Ç–∏–∫—É–≤–∞–π—Ç–µ —Ä–µ–¥–æ–≤–Ω–æ –∏ –∞–Ω–∞–ª–∏–∑–∏—Ä–∞–π—Ç–µ —Ä–µ—à–µ–Ω–∏—è—Ç–∞ –Ω–∞ –∑–∞–¥–∞—á–∏ –æ—Ç —Å—ä—Å—Ç–µ–∑–∞–Ω–∏—è. –° –≤—Ä–µ–º–µ—Ç–æ —â–µ —Ä–∞–∑–≤–∏–µ—Ç–µ –∏–Ω—Ç—É–∏—Ü–∏—è –∫–æ–≥–∞ –∫–æ—è —Ç–µ—Ö–Ω–∏–∫–∞ –µ –ø—Ä–∏–ª–æ–∂–∏–º–∞.

**–†–µ—Å—É—Ä—Å–∏ –∑–∞ –¥–æ–ø—ä–ª–Ω–∏—Ç–µ–ª–Ω–æ –æ–±—É—á–µ–Ω–∏–µ:**
- CSES Problem Set (Advanced DP —Å–µ–∫—Ü–∏—è)
- Codeforces EDU section
- AtCoder DP Contest
- CP-Algorithms website
- IOI/CEOI/APIO –∞—Ä—Ö–∏–≤–∏ —Å—ä—Å –∑–∞–¥–∞—á–∏

–£—Å–ø–µ—Ö —Å –Ω–∞–ø—Ä–µ–¥–Ω–∞–ª–æ—Ç–æ –¥–∏–Ω–∞–º–∏—á–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞–Ω–µ! üöÄ
