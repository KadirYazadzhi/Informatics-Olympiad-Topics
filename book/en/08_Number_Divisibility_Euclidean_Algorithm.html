<html><head><meta charset='utf-8'><style>:root { --bg: #fff; --txt: #24292e; --side: #f6f8fa; --brd: #e1e4e8; --lnk: #0366d6; } [data-theme="dark"] { --bg: #0d1117; --txt: #c9d1d9; --side: #161b22; --brd: #30363d; --lnk: #58a6ff; } body { font-family: sans-serif; margin: 0; display: flex; height: 100vh; background: var(--bg); color: var(--txt); } .sidebar { width: 280px; background: var(--side); border-right: 1px solid var(--brd); overflow-y: auto; flex-shrink: 0; padding: 15px; } .main { flex-grow: 1; overflow-y: auto; padding: 40px; } details { margin-bottom: 8px; } summary { cursor: pointer; font-weight: bold; padding: 5px; } .items a { display: block; padding: 4px 15px; font-size: 0.9em; color: var(--txt); } .active { background: var(--lnk); color: #fff !important; border-radius: 4px; } .top { display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 20px; }</style></head><body><div class='sidebar'><h3>Informatics Topics</h3><details open><summary>I. Fundamentals</summary><div class="items"><a href="01_Cpp_Environment_Data_Types_IO.html" class="">1.. ğŸ–¥ï¸ **C++ Programming Environment. Simple Data Types. Input and Output.**</a><a href="02_Operations_Conditionals.html" class="">2.. â• **Operations in C++. Conditional Operators. Compound Operator.**</a><a href="03_Loops_Functions_Strings.html" class="">3.. ğŸ”„ **Loops. Nested Loops. Functions in C++. Strings.**</a><a href="04_Basic_Divisibility_Tasks.html" class="">4.. ğŸ”¢ **Basic Tasks Related to Number Divisibility.**</a><a href="05_Date_and_Time_Tasks.html" class="">5.. ğŸ“… **Tasks Related to Dates and Time.**</a></div></details><details open><summary>II. Arrays & Math</summary><div class="items"><a href="06_One_Dimensional_Array.html" class="">6.. ğŸ“‚ **One-dimensional Arrays.**</a><a href="07_Arrays_Basic_Tasks.html" class="">7.. ğŸ“‚ **One-dimensional Arrays and Basic Tasks.**</a><a href="07a_Sorting_and_Strings.html" class="">7.1.. ğŸ” **Introduction to sorting algorithms.**</a><a href="07a_Sorting_and_Strings.html" class="">7.2.. ğŸ“ **String manipulation and searching.**</a><a href="08_Number_Divisibility_Euclidean_Algorithm.html" class="active">8.. â— **Number Divisibility, Euclidean Algorithm and Applications.**</a><a href="08_Number_Divisibility_Euclidean_Algorithm.html" class="active">8.1.. ğŸ§® **Calculation with common fractions.**</a><a href="08_Number_Divisibility_Euclidean_Algorithm.html" class="active">8.2.. ğŸ§µ **Prime numbers and Sieve of Eratosthenes.**</a><a href="09_Numeral_Systems.html" class="">9.. ğŸ”¢ **Numeral Systems.**</a><a href="09a_BigInt_and_Random.html" class="">9.1.. ğŸ§® **BigInt and Long Numbers.**</a><a href="09a_BigInt_and_Random.html" class="">9.2.. ğŸ² **Random numbers.**</a><a href="10_Two_Dimensional_Arrays.html" class="">10.. ğŸ“Š **Two-dimensional Arrays and Tabular Data Processing.**</a></div></details><details open><summary>III. Algorithms</summary><div class="items"><a href="11_Basic_Computational_Geometry.html" class="">11.. ğŸ§­ **Basic Knowledge of Computational Geometry.**</a><a href="12_Intro_to_STL.html" class="">12.. ğŸ“š **Introduction to STL and Sorting/Searching Tools.**</a><a href="13_Data_Structures_Stack_Queue.html" class="">13.. ğŸ“¦ **Data Structures: Stack and Queue.**</a><a href="14_Recursion.html" class="">14.. ğŸ” **Concept of Recursion.**</a><a href="15_Intro_to_Combinatorics.html" class="">15.. ğŸ”€ **Introduction to Combinatorial Configurations.**</a></div></details><details open><summary>IV. Advanced Basics</summary><div class="items"><a href="16_Graph_Concept.html" class="">16.. ğŸŒ **Concept of a Graph.**</a><a href="17_STL_Containers_Iterators_Algorithms.html" class="">17.. ğŸ“š **STL Containers and Algorithms.**</a><a href="18_Algorithm_Analysis_Quick_Search_Sort.html" class="">18.. ğŸ“Š **Algorithm Analysis. Fast Search and Fast Sort.**</a><a href="19_Modular_Arithmetic.html" class="">19.. â• **Modular Arithmetic.**</a><a href="20_Polynomials_BigInt.html" class="">20.. ğŸ“ˆ **Polynomials. Implementation of Long Number Operations.**</a></div></details><details open><summary>V. Intermediate</summary><div class="items"><a href="21_Game_Theory.html" class="">21.. ğŸ® **Game Theory: Strategies and Analysis.**</a><a href="22_Bitwise_Operations.html" class="">22.. ğŸ’» **Bitwise Operations and Applications.**</a><a href="23_Dynamic_Programming.html" class="">23.. ğŸ”„ **Dynamic Programming: Advanced Techniques.**</a><a href="24_Graph_Algorithms.html" class="">24.. ğŸŒ **Graph Algorithms: Advanced Methods.**</a><a href="25_Union_Find.html" class="">25.. ğŸ”— **Union-Find (DSU): Advanced Techniques.**</a></div></details><details open><summary>VI. Structures</summary><div class="items"><a href="26_Tree_Structures.html" class="">26.. ğŸŒ² **Tree Data Structures: Expert Level.**</a><a href="27_Advanced_Geometry_SweepLine.html" class="">27.. ğŸ“ **Computational Geometry: Basics and Vectors.**</a><a href="28_Advanced_Combinatorics.html" class="">28.. ğŸ”€ **Advanced Combinatorics: Generation and Coding.**</a><a href="29_Arithmetic_Expressions.html" class="">29.. â— **Arithmetic Expressions: Parsing and Evaluation.**</a><a href="30_Hashing.html" class="">30.. ğŸ”‘ **Hashing: Expert Techniques.**</a></div></details><details open><summary>VII. Expert I</summary><div class="items"><a href="31_Special_Number_Sequences.html" class="">31.. â• **Special Number Sequences: Deep Theory.**</a><a href="32_Geometry_Polygons.html" class="">32.. ğŸ“ **Geometry: Polygons and Lattices.**</a><a href="33_Advanced_Graph_Algorithms.html" class="">33.. ğŸŒ **Advanced Graphs: Deep Theory.**</a><a href="34_Advanced_Data_Structures.html" class="">34.. ğŸ“‚ **Advanced Data Structures: Expert Level.**</a><a href="35_Advanced_DP.html" class="">35.. ğŸ”„ **Dynamic Programming: Expert Optimizations.**</a></div></details><details open><summary>VIII. Expert II</summary><div class="items"><a href="36_String_Algorithms.html" class="">36.. ğŸ“ **String Algorithms: Expert Level.**</a><a href="37_Advanced_Game_Theory.html" class="">37.. ğŸ® **Game Theory: Expert Games.**</a><a href="38_Matrices.html" class="">38.. ğŸ“Š **Matrices: Theorems and Applications.**</a><a href="39_Voronoi_Diagrams.html" class="">39.. ğŸ“ **Voronoi Diagrams and KD-Trees.**</a><a href="40_Flows_Cuts.html" class="">40.. ğŸŒŠ **Network Flows: Expert Problems.**</a></div></details><details open><summary>IX. Master</summary><div class="items"><a href="41_Advanced_Heaps.html" class="">41.. ğŸŒ² **Heaps: Mergeable Heaps.**</a><a href="42_Suffix_Structures.html" class="">42.. ğŸ”¤ **Suffix Automaton (SAM).**</a><a href="43_Linear_Systems.html" class="">43.. ğŸ§® **Linear Algebra: Bases and Rank.**</a><a href="44_Complex_Numbers_FFT.html" class="">44.. ğŸ“ **Complex Numbers and FFT: Expert Level.**</a></div></details></div><div class='main'><div class='top'><a href='../bg/index.html'>ğŸ‡§ğŸ‡¬ BG</a><button id='t'>Theme</button></div><h1>â— Number Divisibility, Euclidean Algorithm and Applications</h1>
<h2>ğŸ“š Number Divisibility</h2>
<p>Divisibility is a fundamental concept in number theory. Number <code>a</code> is divisible by number <code>b</code> (where <code>b â‰  0</code>) if there exists an integer <code>k</code> such that <code>a = b * k</code>. In this case, we say that <code>b</code> is a divisor of <code>a</code>, and <code>a</code> is a multiple of <code>b</code>.</p>
<p><strong>Example:</strong>
- The number <code>15</code> is divisible by <code>3</code> because <code>15 = 3 * 5</code>.</p>
<h3>Divisibility Checks</h3>
<p>Common divisibility rules include:
- <strong>Divisibility by 2:</strong> The number ends in an even digit (0, 2, 4, 6, 8).
- <strong>Divisibility by 3:</strong> The sum of the number's digits is divisible by 3.
- <strong>Divisibility by 5:</strong> The number ends in 0 or 5.</p>
<p><strong>Example Code:</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    int num;
    cout &lt;&lt; &quot;Enter a number: &quot;;
    cin &gt;&gt; num;

    if (num % 2 == 0) {
        cout &lt;&lt; num &lt;&lt; &quot; is even.&quot; &lt;&lt; endl;
    }
    if (num % 3 == 0) {
        cout &lt;&lt; num &lt;&lt; &quot; is divisible by 3.&quot; &lt;&lt; endl;
    }
    if (num % 5 == 0) {
        cout &lt;&lt; num &lt;&lt; &quot; is divisible by 5.&quot; &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h2>ğŸ”¢ Euclidean Algorithm and Applications</h2>
<h3>What is the Euclidean Algorithm?</h3>
<p>The Euclidean algorithm is an efficient method for finding the greatest common divisor (GCD) of two numbers. It is based on the principle that the GCD of two numbers does not change if the larger number is replaced by the difference between the two numbers.</p>
<p>Formulation:
  - If <code>b = 0</code>, then <code>GCD(a, b) = a</code>.
  - Otherwise, <code>GCD(a, b) = GCD(b, a % b)</code>.</p>
<p>Example
To find <code>GCD(48, 18)</code>:
  1. <code>48 % 18 = 12</code>
  2. <code>18 % 12 = 6</code>
  3. <code>12 % 6 = 0</code>, therefore <code>GCD(48, 18) = 6</code>.</p>
<p>Example Code</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main() {
    int a, b;
    cout &lt;&lt; &quot;Enter two numbers: &quot;;
    cin &gt;&gt; a &gt;&gt; b;

    cout &lt;&lt; &quot;GCD(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;) = &quot; &lt;&lt; gcd(a, b) &lt;&lt; endl;
    return 0;
}
</code></pre>
<h2>ğŸ§® Calculation with Common Fractions</h2>
<p>Common fractions represent a part of a whole number, expressed by a numerator (top part) and a denominator (bottom part).</p>
<h3>Basic Operations</h3>
<ul>
<li>
<p><strong>Addition of fractions</strong>
<code>(a / b) + (c / d) = (a * d + b * c) / (b * d)</code></p>
</li>
<li>
<p><strong>Subtraction of fractions</strong>
<code>(a / b) - (c / d) = (a * d - b * c) / (b * d)</code></p>
</li>
<li>
<p><strong>Multiplication of fractions</strong>
<code>(a / b) * (c / d) = (a * c) / (b * d)</code></p>
</li>
<li>
<p><strong>Division of fractions</strong>
<code>(a / b) Ã· (c / d) = (a * d) / (b * c)</code></p>
</li>
</ul>
<p>Example Code for Addition of Fractions</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    int a, b, c, d;
    cout &lt;&lt; &quot;Enter numerator and denominator for the first fraction: &quot;;
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; &quot;Enter numerator and denominator for the second fraction: &quot;;
    cin &gt;&gt; c &gt;&gt; d;

    int numerator = a * d + b * c;
    int denominator = b * d;

    cout &lt;&lt; &quot;Result: &quot; &lt;&lt; numerator &lt;&lt; &quot;/&quot; &lt;&lt; denominator &lt;&lt; endl;
    return 0;
}
</code></pre>
<h2>ğŸ§µ Prime Numbers and Sieve of Eratosthenes</h2>
<h3>What is a Prime Number?</h3>
<p>A prime number is a natural number greater than 1 that has exactly two divisors: 1 and itself.</p>
<h3>Sieve of Eratosthenes</h3>
<p>The Sieve of Eratosthenes is an efficient algorithm for finding all prime numbers up to a given number <code>n</code>.</p>
<h4>Algorithm:</h4>
<ol>
<li>Create a boolean array from 2 to <code>n</code>, where all elements are marked as "true" (initially all numbers are prime).</li>
<li>Start from <code>p = 2</code> and remove all its multiples.</li>
<li>Move to the next number that hasn't been removed.</li>
<li>Repeat the process up to <code>n</code>.</li>
</ol>
<p>Example Code:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void sieveOfEratosthenes(int n) {
    vector&lt;bool&gt; isPrime(n + 1, true);
    isPrime[0] = isPrime[1] = false;

    for (int p = 2; p * p &lt;= n; p++) {
        if (isPrime[p]) {
            for (int i = p * p; i &lt;= n; i += p) {
                isPrime[i] = false;
            }
        }
    }

    cout &lt;&lt; &quot;Prime numbers up to &quot; &lt;&lt; n &lt;&lt; &quot; are: &quot;;
    for (int i = 2; i &lt;= n; i++) {
        if (isPrime[i]) {
            cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        }
    }
    cout &lt;&lt; endl;
}

int main() {
    int n;
    cout &lt;&lt; &quot;Enter a number: &quot;;
    cin &gt;&gt; n;

    sieveOfEratosthenes(n);
    return 0;
}
</code></pre>
<h2>ğŸ¯ Conclusion</h2>
<p>The topics of divisibility, Euclidean algorithm, common fractions, and prime numbers are foundational for understanding number theory. They find application in numerous fields of mathematics and programming, including cryptography, data analysis, and algorithmic optimization.</p></div><script>const b=document.getElementById("t"); let t=localStorage.getItem("theme")||"light"; document.documentElement.setAttribute("data-theme",t); b.onclick=()=>{ t=t==="dark"?"light":"dark"; document.documentElement.setAttribute("data-theme",t); localStorage.setItem("theme",t); };</script></body></html>